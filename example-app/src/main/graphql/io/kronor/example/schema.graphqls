schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""Result of the addition"""
type AddNewUserResult {
  """The number of users added."""
  usersAdded: Int!
}

"""Add new user to merchant pool."""
input AddUserInput {
  """List of users that should be added."""
  addUsers: [AddUserSingleInput!]!
}

"""Add new user to merchant pool."""
input AddUserSingleInput {
  """Email of the user, for reference."""
  email: String!

  """
  One of "STAFF", "ADMIN" or "SUPERADMIN", role that this user should have.
  """
  role: String!

  """
  One of "google", "password" or "webauthn", indicates the type of user to be added.
  Max length: 64.
  """
  userType: String!
}

"""A physical address for a customer."""
input AddressInput {
  """
  Named intermediary.
  Max length: 100.
  """
  careOf: String

  """
  City.
  Max length: 100.
  """
  city: String!

  """
  Country.
  Example: `SE`, `DK`, `NO`, `IS`, `FI`
  """
  country: Country!

  """E-mail address."""
  email: String!

  """
  First name or Given Name.
  Max length: 100.
  """
  firstName: String!

  """
  Last name or Family Name.
  Max length: 100.
  """
  lastName: String!

  """
  Phone number
  Max length: 100.
  """
  phoneNumber: String!

  """Postal Code."""
  postalCode: String!

  """
  State or Region.
  Max length: 100.
  """
  region: String

  """
  Street address, first line.
  This should contain any free text as given by the customer

  Max length: 10000.
  """
  streetAddress: String!

  """
  Street address, second line.
  This should contain any free text as given by the customer

  Max length: 10000.
  """
  streetAddress2: String

  """
  Street name. Do not combine with streetAddress.
  Should only be used if this field has been validated by the merchant
  and known to be correct.

  Max length: 10000.
  """
  streetName: String

  """
  Street number. Do not combine with streetAddress.
  Should only be used if this field has been validated by the merchant
  and known to be correct.

  Max length: 10000.
  """
  streetNumber: String

  """
  Title used for addressing the customer.
  Max length: 100.
  """
  title: CustomerTitle
}

"""Arguments for authorizing future instalments for a purchase"""
input AuthorizeInstalmentsInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """Currently 'recurring_debit'"""
  paymentMethod: String!

  """
  The purchaseId is the purchase for which the customer
  is authorizing the instalments for.

  Max length: 64.
  """
  purchaseId: bigint!

  """The url to return to after the authorization is done."""
  returnUrl: String!
}

"""The result of initiating an authorization for instalments."""
type AuthorizeInstalmentsResult {
  """
  Once an authorization is initialized, we will start the payment workflow.
  You can use this token to query the current status of the authorization
  and where to redirect the user next for them to authorize the payments for the instalments.
  """
  waitToken: String!
}

"""BankID SCA status"""
type BankIdAuth {
  createdAt: timestamptz!
  hintCode: String
  id: uuid!
  orderRef: String
  polledAt: timestamptz!
  purchaseOrderId: String!
  status: BankidAuthStatusEnum!
}

"""
Boolean expression to filter rows from the table "runtime.bankid_auth". All fields are combined with a logical 'AND'.
"""
input BankIdAuthBoolExp {
  _and: [BankIdAuthBoolExp!]
  _not: BankIdAuthBoolExp
  _or: [BankIdAuthBoolExp!]
  createdAt: TimestamptzComparisonExp
  hintCode: StringComparisonExp
  id: UuidComparisonExp
  orderRef: StringComparisonExp
  polledAt: TimestamptzComparisonExp
  purchaseOrderId: StringComparisonExp
  status: BankidAuthStatusEnumComparisonExp
}

"""Ordering options when selecting data from "runtime.bankid_auth"."""
input BankIdAuthOrderBy {
  createdAt: OrderBy
  hintCode: OrderBy
  id: OrderBy
  orderRef: OrderBy
  polledAt: OrderBy
  purchaseOrderId: OrderBy
  status: OrderBy
}

"""
select columns of table "runtime.bankid_auth"
"""
enum BankIdAuthSelectColumn {
  """column name"""
  createdAt

  """column name"""
  hintCode

  """column name"""
  id

  """column name"""
  orderRef

  """column name"""
  polledAt

  """column name"""
  purchaseOrderId

  """column name"""
  status
}

"""
Streaming cursor of the table "BankIdAuth"
"""
input BankIdAuthStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: BankIdAuthStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input BankIdAuthStreamCursorValueInput {
  createdAt: timestamptz
  hintCode: String
  id: uuid
  orderRef: String
  polledAt: timestamptz
  purchaseOrderId: String
  status: BankidAuthStatusEnum
}

enum BankidAuthStatusEnum {
  CANCELLED
  CANCELLING
  COMPLETE
  FAILED
  INITIALIZING
  PENDING
}

"""
Boolean expression to compare columns of type "BankidAuthStatusEnum". All fields are combined with logical 'AND'.
"""
input BankidAuthStatusEnumComparisonExp {
  _eq: BankidAuthStatusEnum
  _in: [BankidAuthStatusEnum!]
  _isNull: Boolean
  _neq: BankidAuthStatusEnum
  _nin: [BankidAuthStatusEnum!]
}

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input BigintComparisonExp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _isNull: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""Block customer from buying from merchant by customer id"""
input BlockCustomerByIdInput {
  """Id of the customer"""
  customerId: bigint!
}

"""Block customer from buying from merchant"""
input BlockCustomerInput {
  """Email of the customer"""
  customerEmail: String

  """SSN of the customer"""
  customerSsn: String
}

"""Blocked customers"""
type BlockCustomerResult {
  """Email of the customer"""
  customerEmail: String

  """ID of the customer"""
  customerId: Int

  """SSN of the customer"""
  customerSsn: String

  """ID of the merchant blocking the customer"""
  merchantId: Int!
}

"""Arguments to for a blockToken mutation"""
input BlockTokenInput {
  """The merchant requesting for the reports."""
  merchantId: bigint!

  """
  The id of the token to block, can be found inside the token as "tid".
  Must be a valid UUID string.
  """
  tokenId: String!
}

"""The result of a blockToken mutation."""
type BlockTokenResult {
  """
  The number of tokens blocked in this request, if no tokens are blocked, verify that the provided uuid is correct and that the token you are trying to block is not already expired.
  """
  tokensBlocked: Int!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Captures made by the merchant. A capture is a partial or total shipment of a purchase. Capturing means that a customer has to pay for the item(s) that were captured (recorded) in this operation.

"""
type Capture {
  createdAt: timestamptz!
  description: String
  id: bigint!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinctOn: [CaptureItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CaptureItemOrderBy!]

    """filter the rows returned"""
    where: CaptureItemBoolExp
  ): [CaptureItem!]!
  purchaseId: bigint!

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: bigint!
}

"""
aggregated selection of "marketplace.purchase_capture"
"""
type CaptureAggregate {
  aggregate: CaptureAggregateFields
  nodes: [Capture!]!
}

input CaptureAggregateBoolExp {
  count: CaptureAggregateBoolExpCount
}

input CaptureAggregateBoolExpCount {
  arguments: [CaptureSelectColumn!]
  distinct: Boolean
  filter: CaptureBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "marketplace.purchase_capture"
"""
type CaptureAggregateFields {
  avg: CaptureAvgFields
  count(columns: [CaptureSelectColumn!], distinct: Boolean): Int!
  max: CaptureMaxFields
  min: CaptureMinFields
  stddev: CaptureStddevFields
  stddevPop: CaptureStddevPopFields
  stddevSamp: CaptureStddevSampFields
  sum: CaptureSumFields
  varPop: CaptureVarPopFields
  varSamp: CaptureVarSampFields
  variance: CaptureVarianceFields
}

"""
order by aggregate values of table "marketplace.purchase_capture"
"""
input CaptureAggregateOrderBy {
  avg: CaptureAvgOrderBy
  count: OrderBy
  max: CaptureMaxOrderBy
  min: CaptureMinOrderBy
  stddev: CaptureStddevOrderBy
  stddevPop: CaptureStddevPopOrderBy
  stddevSamp: CaptureStddevSampOrderBy
  sum: CaptureSumOrderBy
  varPop: CaptureVarPopOrderBy
  varSamp: CaptureVarSampOrderBy
  variance: CaptureVarianceOrderBy
}

"""aggregate avg on columns"""
type CaptureAvgFields {
  id: Float
  purchaseId: Float

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: Float
}

"""
order by avg() on columns of table "marketplace.purchase_capture"
"""
input CaptureAvgOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.purchase_capture". All fields are combined with a logical 'AND'.
"""
input CaptureBoolExp {
  _and: [CaptureBoolExp!]
  _not: CaptureBoolExp
  _or: [CaptureBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: BigintComparisonExp
  items: CaptureItemBoolExp
  purchaseId: BigintComparisonExp
  totalAmount: BigintComparisonExp
}

"""
Record of items purchased, for which the merchant has sent a capture request.
"""
type CaptureItem {
  """An object relationship"""
  item: PurchaseItem!

  """Unit price including tax in minor units."""
  pricePerItem: bigint!
  purchaseCaptureId: bigint!
  purchaseId: bigint!

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: smallint!

  """
  Item identification either provided by the merchant as bar code or generated by us.
  """
  reference: citext!

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: smallint!

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: bigint!

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: bigint!
}

"""
order by aggregate values of table "marketplace.purchase_capture_item"
"""
input CaptureItemAggregateOrderBy {
  avg: CaptureItemAvgOrderBy
  count: OrderBy
  max: CaptureItemMaxOrderBy
  min: CaptureItemMinOrderBy
  stddev: CaptureItemStddevOrderBy
  stddevPop: CaptureItemStddevPopOrderBy
  stddevSamp: CaptureItemStddevSampOrderBy
  sum: CaptureItemSumOrderBy
  varPop: CaptureItemVarPopOrderBy
  varSamp: CaptureItemVarSampOrderBy
  variance: CaptureItemVarianceOrderBy
}

"""
order by avg() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemAvgOrderBy {
  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.purchase_capture_item". All fields are combined with a logical 'AND'.
"""
input CaptureItemBoolExp {
  _and: [CaptureItemBoolExp!]
  _not: CaptureItemBoolExp
  _or: [CaptureItemBoolExp!]
  item: PurchaseItemBoolExp
  pricePerItem: BigintComparisonExp
  purchaseCaptureId: BigintComparisonExp
  purchaseId: BigintComparisonExp
  quantity: SmallintComparisonExp
  reference: CitextComparisonExp
  taxRate: SmallintComparisonExp
  totalAmount: BigintComparisonExp
  totalTaxAmount: BigintComparisonExp
}

"""
order by max() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemMaxOrderBy {
  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """
  Item identification either provided by the merchant as bar code or generated by us.
  """
  reference: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
order by min() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemMinOrderBy {
  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """
  Item identification either provided by the merchant as bar code or generated by us.
  """
  reference: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
Ordering options when selecting data from "marketplace.purchase_capture_item".
"""
input CaptureItemOrderBy {
  item: PurchaseItemOrderBy
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  reference: OrderBy
  taxRate: OrderBy
  totalAmount: OrderBy
  totalTaxAmount: OrderBy
}

"""
select columns of table "marketplace.purchase_capture_item"
"""
enum CaptureItemSelectColumn {
  """column name"""
  pricePerItem

  """column name"""
  purchaseCaptureId

  """column name"""
  purchaseId

  """column name"""
  quantity

  """column name"""
  reference

  """column name"""
  taxRate

  """column name"""
  totalAmount

  """column name"""
  totalTaxAmount
}

"""
order by stddev() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemStddevOrderBy {
  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
order by stddevPop() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemStddevPopOrderBy {
  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
order by stddevSamp() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemStddevSampOrderBy {
  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
order by sum() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemSumOrderBy {
  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
order by varPop() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemVarPopOrderBy {
  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
order by varSamp() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemVarSampOrderBy {
  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
order by variance() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemVarianceOrderBy {
  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""aggregate max on columns"""
type CaptureMaxFields {
  createdAt: timestamptz
  description: String
  id: bigint
  purchaseId: bigint

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: bigint
}

"""
order by max() on columns of table "marketplace.purchase_capture"
"""
input CaptureMaxOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""aggregate min on columns"""
type CaptureMinFields {
  createdAt: timestamptz
  description: String
  id: bigint
  purchaseId: bigint

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: bigint
}

"""
order by min() on columns of table "marketplace.purchase_capture"
"""
input CaptureMinOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""
Ordering options when selecting data from "marketplace.purchase_capture".
"""
input CaptureOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  itemsAggregate: CaptureItemAggregateOrderBy
  purchaseId: OrderBy
  totalAmount: OrderBy
}

"""Arguments for capturing a new PayPal payment"""
input CapturePayPalPaymentInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  The payment id of a PayPal payment, this is obtained
  with `newPayPalPayment`.

  Max length: 64.
  """
  paymentId: String!
}

"""The result of capturing a PayPal payment."""
type CapturePayPalPaymentResult {
  """The result of starting the PayPal payment capture."""
  paymentId: String!
}

"""
select columns of table "marketplace.purchase_capture"
"""
enum CaptureSelectColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  purchaseId

  """column name"""
  totalAmount
}

enum CaptureStatusEnum {
  """Purchase already captured."""
  CAPTURED

  """Something went wrong."""
  ERROR
}

"""
Boolean expression to compare columns of type "CaptureStatusEnum". All fields are combined with logical 'AND'.
"""
input CaptureStatusEnumComparisonExp {
  _eq: CaptureStatusEnum
  _in: [CaptureStatusEnum!]
  _isNull: Boolean
  _neq: CaptureStatusEnum
  _nin: [CaptureStatusEnum!]
}

"""aggregate stddev on columns"""
type CaptureStddevFields {
  id: Float
  purchaseId: Float

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: Float
}

"""
order by stddev() on columns of table "marketplace.purchase_capture"
"""
input CaptureStddevOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""aggregate stddevPop on columns"""
type CaptureStddevPopFields {
  id: Float
  purchaseId: Float

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: Float
}

"""
order by stddevPop() on columns of table "marketplace.purchase_capture"
"""
input CaptureStddevPopOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""aggregate stddevSamp on columns"""
type CaptureStddevSampFields {
  id: Float
  purchaseId: Float

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: Float
}

"""
order by stddevSamp() on columns of table "marketplace.purchase_capture"
"""
input CaptureStddevSampOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""aggregate sum on columns"""
type CaptureSumFields {
  id: bigint
  purchaseId: bigint

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: bigint
}

"""
order by sum() on columns of table "marketplace.purchase_capture"
"""
input CaptureSumOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""aggregate varPop on columns"""
type CaptureVarPopFields {
  id: Float
  purchaseId: Float

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: Float
}

"""
order by varPop() on columns of table "marketplace.purchase_capture"
"""
input CaptureVarPopOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""aggregate varSamp on columns"""
type CaptureVarSampFields {
  id: Float
  purchaseId: Float

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: Float
}

"""
order by varSamp() on columns of table "marketplace.purchase_capture"
"""
input CaptureVarSampOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""aggregate variance on columns"""
type CaptureVarianceFields {
  id: Float
  purchaseId: Float

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: Float
}

"""
order by variance() on columns of table "marketplace.purchase_capture"
"""
input CaptureVarianceOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input CitextComparisonExp {
  _eq: citext
  _gt: citext
  _gte: citext

  """does the column match the given case-insensitive pattern"""
  _ilike: citext
  _in: [citext!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: citext
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: citext
  _lt: citext
  _lte: citext
  _neq: citext

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: citext
  _nin: [citext!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: citext

  """does the column NOT match the given pattern"""
  _nlike: citext

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: citext

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: citext

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: citext

  """does the column match the given SQL regular expression"""
  _similar: citext
}

"""Supported countries"""
enum Country {
  AT
  BE
  CH
  CY
  CZ
  DE
  DK
  EE
  ES
  FI
  FR
  GR
  HR
  HU
  IE
  IS
  IT
  LT
  LU
  LV
  MT
  NL
  NO
  PL
  PT
  RO
  SE
  SI
  SK
}

"""
Boolean expression to compare columns of type "country". All fields are combined with logical 'AND'.
"""
input CountryComparisonExp {
  _eq: country
  _gt: country
  _gte: country
  _in: [country!]
  _isNull: Boolean
  _lt: country
  _lte: country
  _neq: country
  _nin: [country!]
}

"""Describes the schema for credit card details"""
type CreditCardDetails {
  """Acquirer Name"""
  acquirer: String

  """Acquirer Message"""
  acquirerMessage: String

  """Acquirer Reference"""
  acquirerReference: String

  """Bank"""
  bank: String

  """Card Country"""
  cardCountry: String

  """Card Expiry Date"""
  cardExpiryDate: date

  """
  Reepay credit card fingerprint that uniquely identifies this particular card number
  """
  cardFingerprint: String

  """Masked Card Number"""
  cardNumber: String

  """Card Type"""
  cardType: String

  """If the card is a corporate card or not (boolean)"""
  corporateCard: Boolean

  """Type of card, debit or credit"""
  debitOrCredit: String

  """Error message, null if not applicable"""
  errorMessage: String

  """If the card is prepaid or not (boolean)"""
  isPrepaid: Boolean

  """Strong Authentication Rule"""
  strongAuthenticationRule: String

  """Strong Authentication Scheme"""
  strongAuthenticationScheme: String

  """Strong Authentication Status"""
  strongAuthenticationStatus: String

  """3-D Secure ECI"""
  threeDSecureEci: String

  """3-D Secure Frictionless (boolean)"""
  threeDSecureFrictionless: Boolean

  """3-D Secure Status"""
  threeDSecureStatus: Boolean
}

"""
order by aggregate values of table "runtime.transaction_credit_card_details"
"""
input CreditCardDetailsAggregateOrderBy {
  count: OrderBy
  max: CreditCardDetailsMaxOrderBy
  min: CreditCardDetailsMinOrderBy
}

"""
Boolean expression to filter rows from the table "runtime.transaction_credit_card_details". All fields are combined with a logical 'AND'.
"""
input CreditCardDetailsBoolExp {
  _and: [CreditCardDetailsBoolExp!]
  _not: CreditCardDetailsBoolExp
  _or: [CreditCardDetailsBoolExp!]
  acquirer: StringComparisonExp
  acquirerMessage: StringComparisonExp
  acquirerReference: StringComparisonExp
  bank: StringComparisonExp
  cardCountry: StringComparisonExp
  cardExpiryDate: DateComparisonExp
  cardFingerprint: StringComparisonExp
  cardNumber: StringComparisonExp
  cardType: StringComparisonExp
  corporateCard: BooleanComparisonExp
  debitOrCredit: StringComparisonExp
  errorMessage: StringComparisonExp
  isPrepaid: BooleanComparisonExp
  strongAuthenticationRule: StringComparisonExp
  strongAuthenticationScheme: StringComparisonExp
  strongAuthenticationStatus: StringComparisonExp
  threeDSecureEci: StringComparisonExp
  threeDSecureFrictionless: BooleanComparisonExp
  threeDSecureStatus: BooleanComparisonExp
}

"""
order by max() on columns of table "runtime.transaction_credit_card_details"
"""
input CreditCardDetailsMaxOrderBy {
  """Acquirer Name"""
  acquirer: OrderBy

  """Acquirer Message"""
  acquirerMessage: OrderBy

  """Acquirer Reference"""
  acquirerReference: OrderBy

  """Bank"""
  bank: OrderBy

  """Card Country"""
  cardCountry: OrderBy

  """Card Expiry Date"""
  cardExpiryDate: OrderBy

  """
  Reepay credit card fingerprint that uniquely identifies this particular card number
  """
  cardFingerprint: OrderBy

  """Masked Card Number"""
  cardNumber: OrderBy

  """Card Type"""
  cardType: OrderBy

  """Type of card, debit or credit"""
  debitOrCredit: OrderBy

  """Error message, null if not applicable"""
  errorMessage: OrderBy

  """Strong Authentication Rule"""
  strongAuthenticationRule: OrderBy

  """Strong Authentication Scheme"""
  strongAuthenticationScheme: OrderBy

  """Strong Authentication Status"""
  strongAuthenticationStatus: OrderBy

  """3-D Secure ECI"""
  threeDSecureEci: OrderBy
}

"""
order by min() on columns of table "runtime.transaction_credit_card_details"
"""
input CreditCardDetailsMinOrderBy {
  """Acquirer Name"""
  acquirer: OrderBy

  """Acquirer Message"""
  acquirerMessage: OrderBy

  """Acquirer Reference"""
  acquirerReference: OrderBy

  """Bank"""
  bank: OrderBy

  """Card Country"""
  cardCountry: OrderBy

  """Card Expiry Date"""
  cardExpiryDate: OrderBy

  """
  Reepay credit card fingerprint that uniquely identifies this particular card number
  """
  cardFingerprint: OrderBy

  """Masked Card Number"""
  cardNumber: OrderBy

  """Card Type"""
  cardType: OrderBy

  """Type of card, debit or credit"""
  debitOrCredit: OrderBy

  """Error message, null if not applicable"""
  errorMessage: OrderBy

  """Strong Authentication Rule"""
  strongAuthenticationRule: OrderBy

  """Strong Authentication Scheme"""
  strongAuthenticationScheme: OrderBy

  """Strong Authentication Status"""
  strongAuthenticationStatus: OrderBy

  """3-D Secure ECI"""
  threeDSecureEci: OrderBy
}

"""
Ordering options when selecting data from "runtime.transaction_credit_card_details".
"""
input CreditCardDetailsOrderBy {
  acquirer: OrderBy
  acquirerMessage: OrderBy
  acquirerReference: OrderBy
  bank: OrderBy
  cardCountry: OrderBy
  cardExpiryDate: OrderBy
  cardFingerprint: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
  corporateCard: OrderBy
  debitOrCredit: OrderBy
  errorMessage: OrderBy
  isPrepaid: OrderBy
  strongAuthenticationRule: OrderBy
  strongAuthenticationScheme: OrderBy
  strongAuthenticationStatus: OrderBy
  threeDSecureEci: OrderBy
  threeDSecureFrictionless: OrderBy
  threeDSecureStatus: OrderBy
}

"""
select columns of table "runtime.transaction_credit_card_details"
"""
enum CreditCardDetailsSelectColumn {
  """column name"""
  acquirer

  """column name"""
  acquirerMessage

  """column name"""
  acquirerReference

  """column name"""
  bank

  """column name"""
  cardCountry

  """column name"""
  cardExpiryDate

  """column name"""
  cardFingerprint

  """column name"""
  cardNumber

  """column name"""
  cardType

  """column name"""
  corporateCard

  """column name"""
  debitOrCredit

  """column name"""
  errorMessage

  """column name"""
  isPrepaid

  """column name"""
  strongAuthenticationRule

  """column name"""
  strongAuthenticationScheme

  """column name"""
  strongAuthenticationStatus

  """column name"""
  threeDSecureEci

  """column name"""
  threeDSecureFrictionless

  """column name"""
  threeDSecureStatus
}

"""
Boolean expression to compare columns of type "currency". All fields are combined with logical 'AND'.
"""
input CurrencyComparisonExp {
  _eq: currency
  _gt: currency
  _gte: currency
  _in: [currency!]
  _isNull: Boolean
  _lt: currency
  _lte: currency
  _neq: currency
  _nin: [currency!]
}

"""
columns and relationships of "payment_gateway.current_capture_status"
"""
type CurrentCaptureStatus {
  enteredAt: timestamptz!
  status: PaymentCaptureStatusEnum!
}

"""
order by aggregate values of table "payment_gateway.current_capture_status"
"""
input CurrentCaptureStatusAggregateOrderBy {
  count: OrderBy
  max: CurrentCaptureStatusMaxOrderBy
  min: CurrentCaptureStatusMinOrderBy
}

"""
Boolean expression to filter rows from the table "payment_gateway.current_capture_status". All fields are combined with a logical 'AND'.
"""
input CurrentCaptureStatusBoolExp {
  _and: [CurrentCaptureStatusBoolExp!]
  _not: CurrentCaptureStatusBoolExp
  _or: [CurrentCaptureStatusBoolExp!]
  enteredAt: TimestamptzComparisonExp
  status: PaymentCaptureStatusEnumComparisonExp
}

"""
order by max() on columns of table "payment_gateway.current_capture_status"
"""
input CurrentCaptureStatusMaxOrderBy {
  enteredAt: OrderBy
}

"""
order by min() on columns of table "payment_gateway.current_capture_status"
"""
input CurrentCaptureStatusMinOrderBy {
  enteredAt: OrderBy
}

"""
Ordering options when selecting data from "payment_gateway.current_capture_status".
"""
input CurrentCaptureStatusOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
select columns of table "payment_gateway.current_capture_status"
"""
enum CurrentCaptureStatusSelectColumn {
  """column name"""
  enteredAt

  """column name"""
  status
}

"""
columns and relationships of "marketplace.current_instalment_status"
"""
type CurrentInstalmentStatus {
  enteredAt: timestamptz!
  status: citext!
}

"""
order by aggregate values of table "marketplace.current_instalment_status"
"""
input CurrentInstalmentStatusAggregateOrderBy {
  count: OrderBy
  max: CurrentInstalmentStatusMaxOrderBy
  min: CurrentInstalmentStatusMinOrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.current_instalment_status". All fields are combined with a logical 'AND'.
"""
input CurrentInstalmentStatusBoolExp {
  _and: [CurrentInstalmentStatusBoolExp!]
  _not: CurrentInstalmentStatusBoolExp
  _or: [CurrentInstalmentStatusBoolExp!]
  enteredAt: TimestamptzComparisonExp
  status: CitextComparisonExp
}

"""
order by max() on columns of table "marketplace.current_instalment_status"
"""
input CurrentInstalmentStatusMaxOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
order by min() on columns of table "marketplace.current_instalment_status"
"""
input CurrentInstalmentStatusMinOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
Ordering options when selecting data from "marketplace.current_instalment_status".
"""
input CurrentInstalmentStatusOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
select columns of table "marketplace.current_instalment_status"
"""
enum CurrentInstalmentStatusSelectColumn {
  """column name"""
  enteredAt

  """column name"""
  status
}

"""
columns and relationships of "runtime.current_payment_detail"
"""
type CurrentPaymentDetail {
  detail(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
order by aggregate values of table "runtime.current_payment_detail"
"""
input CurrentPaymentDetailAggregateOrderBy {
  count: OrderBy
}

"""
Boolean expression to filter rows from the table "runtime.current_payment_detail". All fields are combined with a logical 'AND'.
"""
input CurrentPaymentDetailBoolExp {
  _and: [CurrentPaymentDetailBoolExp!]
  _not: CurrentPaymentDetailBoolExp
  _or: [CurrentPaymentDetailBoolExp!]
  detail: JsonbComparisonExp
}

"""
Ordering options when selecting data from "runtime.current_payment_detail".
"""
input CurrentPaymentDetailOrderBy {
  detail: OrderBy
}

"""
select columns of table "runtime.current_payment_detail"
"""
enum CurrentPaymentDetailSelectColumn {
  """column name"""
  detail
}

"""
columns and relationships of "runtime.current_payment_status"
"""
type CurrentPaymentStatus {
  enteredAt: timestamptz!
  status: PaymentStatusEnum!
}

"""
order by aggregate values of table "runtime.current_payment_status"
"""
input CurrentPaymentStatusAggregateOrderBy {
  count: OrderBy
  max: CurrentPaymentStatusMaxOrderBy
  min: CurrentPaymentStatusMinOrderBy
}

"""
Boolean expression to filter rows from the table "runtime.current_payment_status". All fields are combined with a logical 'AND'.
"""
input CurrentPaymentStatusBoolExp {
  _and: [CurrentPaymentStatusBoolExp!]
  _not: CurrentPaymentStatusBoolExp
  _or: [CurrentPaymentStatusBoolExp!]
  enteredAt: TimestamptzComparisonExp
  status: PaymentStatusEnumComparisonExp
}

"""
order by max() on columns of table "runtime.current_payment_status"
"""
input CurrentPaymentStatusMaxOrderBy {
  enteredAt: OrderBy
}

"""
order by min() on columns of table "runtime.current_payment_status"
"""
input CurrentPaymentStatusMinOrderBy {
  enteredAt: OrderBy
}

"""
Ordering options when selecting data from "runtime.current_payment_status".
"""
input CurrentPaymentStatusOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
select columns of table "runtime.current_payment_status"
"""
enum CurrentPaymentStatusSelectColumn {
  """column name"""
  enteredAt

  """column name"""
  status
}

"""Statuses for the purchase order"""
type CurrentPurchaseOrderStatus {
  enteredAt: timestamptz!
  status: OrderStatusEnum!
}

"""
order by aggregate values of table "checkout.current_status"
"""
input CurrentPurchaseOrderStatusAggregateOrderBy {
  count: OrderBy
  max: CurrentPurchaseOrderStatusMaxOrderBy
  min: CurrentPurchaseOrderStatusMinOrderBy
}

"""
Boolean expression to filter rows from the table "checkout.current_status". All fields are combined with a logical 'AND'.
"""
input CurrentPurchaseOrderStatusBoolExp {
  _and: [CurrentPurchaseOrderStatusBoolExp!]
  _not: CurrentPurchaseOrderStatusBoolExp
  _or: [CurrentPurchaseOrderStatusBoolExp!]
  enteredAt: TimestamptzComparisonExp
  status: OrderStatusEnumComparisonExp
}

"""
order by max() on columns of table "checkout.current_status"
"""
input CurrentPurchaseOrderStatusMaxOrderBy {
  enteredAt: OrderBy
}

"""
order by min() on columns of table "checkout.current_status"
"""
input CurrentPurchaseOrderStatusMinOrderBy {
  enteredAt: OrderBy
}

"""Ordering options when selecting data from "checkout.current_status"."""
input CurrentPurchaseOrderStatusOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
select columns of table "checkout.current_status"
"""
enum CurrentPurchaseOrderStatusSelectColumn {
  """column name"""
  enteredAt

  """column name"""
  status
}

"""
columns and relationships of "marketplace.current_purchase_status"
"""
type CurrentPurchaseStatus {
  enteredAt: timestamptz!
  status: PurchaseStatusEnum!
}

"""
order by aggregate values of table "marketplace.current_purchase_status"
"""
input CurrentPurchaseStatusAggregateOrderBy {
  count: OrderBy
  max: CurrentPurchaseStatusMaxOrderBy
  min: CurrentPurchaseStatusMinOrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.current_purchase_status". All fields are combined with a logical 'AND'.
"""
input CurrentPurchaseStatusBoolExp {
  _and: [CurrentPurchaseStatusBoolExp!]
  _not: CurrentPurchaseStatusBoolExp
  _or: [CurrentPurchaseStatusBoolExp!]
  enteredAt: TimestamptzComparisonExp
  status: PurchaseStatusEnumComparisonExp
}

"""
order by max() on columns of table "marketplace.current_purchase_status"
"""
input CurrentPurchaseStatusMaxOrderBy {
  enteredAt: OrderBy
}

"""
order by min() on columns of table "marketplace.current_purchase_status"
"""
input CurrentPurchaseStatusMinOrderBy {
  enteredAt: OrderBy
}

"""
Ordering options when selecting data from "marketplace.current_purchase_status".
"""
input CurrentPurchaseStatusOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
select columns of table "marketplace.current_purchase_status"
"""
enum CurrentPurchaseStatusSelectColumn {
  """column name"""
  enteredAt

  """column name"""
  status
}

"""
columns and relationships of "payment_gateway.current_refund_status"
"""
type CurrentRefundStatus {
  enteredAt: timestamptz!
  status: RefundStatusEnum!
}

"""
order by aggregate values of table "payment_gateway.current_refund_status"
"""
input CurrentRefundStatusAggregateOrderBy {
  count: OrderBy
  max: CurrentRefundStatusMaxOrderBy
  min: CurrentRefundStatusMinOrderBy
}

"""
Boolean expression to filter rows from the table "payment_gateway.current_refund_status". All fields are combined with a logical 'AND'.
"""
input CurrentRefundStatusBoolExp {
  _and: [CurrentRefundStatusBoolExp!]
  _not: CurrentRefundStatusBoolExp
  _or: [CurrentRefundStatusBoolExp!]
  enteredAt: TimestamptzComparisonExp
  status: RefundStatusEnumComparisonExp
}

"""
order by max() on columns of table "payment_gateway.current_refund_status"
"""
input CurrentRefundStatusMaxOrderBy {
  enteredAt: OrderBy
}

"""
order by min() on columns of table "payment_gateway.current_refund_status"
"""
input CurrentRefundStatusMinOrderBy {
  enteredAt: OrderBy
}

"""
Ordering options when selecting data from "payment_gateway.current_refund_status".
"""
input CurrentRefundStatusOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
select columns of table "payment_gateway.current_refund_status"
"""
enum CurrentRefundStatusSelectColumn {
  """column name"""
  enteredAt

  """column name"""
  status
}

"""
columns and relationships of "payment_gateway.current_transaction_release_status"
"""
type CurrentTransactionReleaseStatus {
  enteredAt: timestamptz!
  status: TransactionReleaseStatusEnum!
}

"""
order by aggregate values of table "payment_gateway.current_transaction_release_status"
"""
input CurrentTransactionReleaseStatusAggregateOrderBy {
  count: OrderBy
  max: CurrentTransactionReleaseStatusMaxOrderBy
  min: CurrentTransactionReleaseStatusMinOrderBy
}

"""
Boolean expression to filter rows from the table "payment_gateway.current_transaction_release_status". All fields are combined with a logical 'AND'.
"""
input CurrentTransactionReleaseStatusBoolExp {
  _and: [CurrentTransactionReleaseStatusBoolExp!]
  _not: CurrentTransactionReleaseStatusBoolExp
  _or: [CurrentTransactionReleaseStatusBoolExp!]
  enteredAt: TimestamptzComparisonExp
  status: TransactionReleaseStatusEnumComparisonExp
}

"""
order by max() on columns of table "payment_gateway.current_transaction_release_status"
"""
input CurrentTransactionReleaseStatusMaxOrderBy {
  enteredAt: OrderBy
}

"""
order by min() on columns of table "payment_gateway.current_transaction_release_status"
"""
input CurrentTransactionReleaseStatusMinOrderBy {
  enteredAt: OrderBy
}

"""
Ordering options when selecting data from "payment_gateway.current_transaction_release_status".
"""
input CurrentTransactionReleaseStatusOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
select columns of table "payment_gateway.current_transaction_release_status"
"""
enum CurrentTransactionReleaseStatusSelectColumn {
  """column name"""
  enteredAt

  """column name"""
  status
}

"""ordering argument of a cursor"""
enum CursorOrdering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

"""A customer is a real person who can make purchases."""
type Customer {
  """An array relationship"""
  addresses(
    """distinct select on columns"""
    distinctOn: [CustomerAddressSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerAddressOrderBy!]

    """filter the rows returned"""
    where: CustomerAddressBoolExp
  ): [CustomerAddress!]!

  """An array relationship"""
  blocked(
    """distinct select on columns"""
    distinctOn: [CustomerBanSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerBanOrderBy!]

    """filter the rows returned"""
    where: CustomerBanBoolExp
  ): [CustomerBan!]!
  createdAt: timestamptz!

  """An array relationship"""
  emails(
    """distinct select on columns"""
    distinctOn: [CustomerEmailSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerEmailOrderBy!]

    """filter the rows returned"""
    where: CustomerEmailBoolExp
  ): [CustomerEmail!]!
  firstName: String!

  """Serial id for each customer"""
  id: bigint!
  lastName: String!
  locale: spoken_lang!

  """An object relationship"""
  merchant: Merchant!

  """An array relationship"""
  phoneNumbers(
    """distinct select on columns"""
    distinctOn: [CustomerPhoneNumberSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerPhoneNumberOrderBy!]

    """filter the rows returned"""
    where: CustomerPhoneNumberBoolExp
  ): [CustomerPhoneNumber!]!

  """An array relationship"""
  purchases(
    """distinct select on columns"""
    distinctOn: [PurchaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseOrderBy!]

    """filter the rows returned"""
    where: PurchaseBoolExp
  ): [Purchase!]!

  """An aggregate relationship"""
  purchasesAggregate(
    """distinct select on columns"""
    distinctOn: [PurchaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseOrderBy!]

    """filter the rows returned"""
    where: PurchaseBoolExp
  ): PurchaseAggregate!
}

"""
Addresses for a customer which may be their residence or a place they have shipped to.
"""
type CustomerAddress {
  """Address of the customer."""
  addressLine1: String!

  """Line 2 of the address"""
  addressLine2: String

  """Care of"""
  careOf: String
  city: String!
  country: country!
  createdAt: timestamptz!

  """An object relationship"""
  customer: Customer!
  email: citext!
  firstName: String!

  """
  Whether or not we have validated this address is safely associated with a customer
  """
  isKnownSafe: Boolean!

  """
  Whether or not the address is just a mailbox without a real person living there
  """
  isPostbox: Boolean!

  """
  The primary address for the customer, which may be their place of residence.
  There can be only one primary address for each customer under one merchant.
  """
  isPrimary: Boolean!
  lastName: String!
  phoneNumber: packed_phone_number!
  postalCode: String!

  """State or region."""
  region: String

  """Street name of the address. Not to be combined with address_line."""
  streetName: String

  """Street number. Not to be combined with address_line."""
  streetNumber: String

  """Mr., Ms, Mrs., Miss. ..."""
  title: String
}

"""
order by aggregate values of table "dna.customer_address"
"""
input CustomerAddressAggregateOrderBy {
  count: OrderBy
  max: CustomerAddressMaxOrderBy
  min: CustomerAddressMinOrderBy
}

"""
Boolean expression to filter rows from the table "dna.customer_address". All fields are combined with a logical 'AND'.
"""
input CustomerAddressBoolExp {
  _and: [CustomerAddressBoolExp!]
  _not: CustomerAddressBoolExp
  _or: [CustomerAddressBoolExp!]
  addressLine1: StringComparisonExp
  addressLine2: StringComparisonExp
  careOf: StringComparisonExp
  city: StringComparisonExp
  country: CountryComparisonExp
  createdAt: TimestamptzComparisonExp
  customer: CustomerBoolExp
  email: CitextComparisonExp
  firstName: StringComparisonExp
  isKnownSafe: BooleanComparisonExp
  isPostbox: BooleanComparisonExp
  isPrimary: BooleanComparisonExp
  lastName: StringComparisonExp
  phoneNumber: PackedPhoneNumberComparisonExp
  postalCode: StringComparisonExp
  region: StringComparisonExp
  streetName: StringComparisonExp
  streetNumber: StringComparisonExp
  title: StringComparisonExp
}

"""
order by max() on columns of table "dna.customer_address"
"""
input CustomerAddressMaxOrderBy {
  """Address of the customer."""
  addressLine1: OrderBy

  """Line 2 of the address"""
  addressLine2: OrderBy

  """Care of"""
  careOf: OrderBy
  city: OrderBy
  createdAt: OrderBy
  email: OrderBy
  firstName: OrderBy
  lastName: OrderBy
  postalCode: OrderBy

  """State or region."""
  region: OrderBy

  """Street name of the address. Not to be combined with address_line."""
  streetName: OrderBy

  """Street number. Not to be combined with address_line."""
  streetNumber: OrderBy

  """Mr., Ms, Mrs., Miss. ..."""
  title: OrderBy
}

"""
order by min() on columns of table "dna.customer_address"
"""
input CustomerAddressMinOrderBy {
  """Address of the customer."""
  addressLine1: OrderBy

  """Line 2 of the address"""
  addressLine2: OrderBy

  """Care of"""
  careOf: OrderBy
  city: OrderBy
  createdAt: OrderBy
  email: OrderBy
  firstName: OrderBy
  lastName: OrderBy
  postalCode: OrderBy

  """State or region."""
  region: OrderBy

  """Street name of the address. Not to be combined with address_line."""
  streetName: OrderBy

  """Street number. Not to be combined with address_line."""
  streetNumber: OrderBy

  """Mr., Ms, Mrs., Miss. ..."""
  title: OrderBy
}

"""Ordering options when selecting data from "dna.customer_address"."""
input CustomerAddressOrderBy {
  addressLine1: OrderBy
  addressLine2: OrderBy
  careOf: OrderBy
  city: OrderBy
  country: OrderBy
  createdAt: OrderBy
  customer: CustomerOrderBy
  email: OrderBy
  firstName: OrderBy
  isKnownSafe: OrderBy
  isPostbox: OrderBy
  isPrimary: OrderBy
  lastName: OrderBy
  phoneNumber: OrderBy
  postalCode: OrderBy
  region: OrderBy
  streetName: OrderBy
  streetNumber: OrderBy
  title: OrderBy
}

"""
select columns of table "dna.customer_address"
"""
enum CustomerAddressSelectColumn {
  """column name"""
  addressLine1

  """column name"""
  addressLine2

  """column name"""
  careOf

  """column name"""
  city

  """column name"""
  country

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  firstName

  """column name"""
  isKnownSafe

  """column name"""
  isPostbox

  """column name"""
  isPrimary

  """column name"""
  lastName

  """column name"""
  phoneNumber

  """column name"""
  postalCode

  """column name"""
  region

  """column name"""
  streetName

  """column name"""
  streetNumber

  """column name"""
  title
}

"""
aggregated selection of "dna.customer"
"""
type CustomerAggregate {
  aggregate: CustomerAggregateFields
  nodes: [Customer!]!
}

"""
aggregate fields of "dna.customer"
"""
type CustomerAggregateFields {
  avg: CustomerAvgFields
  count(columns: [CustomerSelectColumn!], distinct: Boolean): Int!
  max: CustomerMaxFields
  min: CustomerMinFields
  stddev: CustomerStddevFields
  stddevPop: CustomerStddevPopFields
  stddevSamp: CustomerStddevSampFields
  sum: CustomerSumFields
  varPop: CustomerVarPopFields
  varSamp: CustomerVarSampFields
  variance: CustomerVarianceFields
}

"""aggregate avg on columns"""
type CustomerAvgFields {
  """Serial id for each customer"""
  id: Float
}

"""A Customer Block directive based on person number or email"""
type CustomerBan {
  """An object relationship"""
  customer: Customer
  customerEmail: citext
  customerSsn: citext
}

"""
order by aggregate values of table "dna.blocked_customer"
"""
input CustomerBanAggregateOrderBy {
  count: OrderBy
  max: CustomerBanMaxOrderBy
  min: CustomerBanMinOrderBy
}

"""
Boolean expression to filter rows from the table "dna.blocked_customer". All fields are combined with a logical 'AND'.
"""
input CustomerBanBoolExp {
  _and: [CustomerBanBoolExp!]
  _not: CustomerBanBoolExp
  _or: [CustomerBanBoolExp!]
  customer: CustomerBoolExp
  customerEmail: CitextComparisonExp
  customerSsn: CitextComparisonExp
}

"""
order by max() on columns of table "dna.blocked_customer"
"""
input CustomerBanMaxOrderBy {
  customerEmail: OrderBy
  customerSsn: OrderBy
}

"""
order by min() on columns of table "dna.blocked_customer"
"""
input CustomerBanMinOrderBy {
  customerEmail: OrderBy
  customerSsn: OrderBy
}

"""Ordering options when selecting data from "dna.blocked_customer"."""
input CustomerBanOrderBy {
  customer: CustomerOrderBy
  customerEmail: OrderBy
  customerSsn: OrderBy
}

"""
select columns of table "dna.blocked_customer"
"""
enum CustomerBanSelectColumn {
  """column name"""
  customerEmail

  """column name"""
  customerSsn
}

"""
Boolean expression to filter rows from the table "dna.customer". All fields are combined with a logical 'AND'.
"""
input CustomerBoolExp {
  _and: [CustomerBoolExp!]
  _not: CustomerBoolExp
  _or: [CustomerBoolExp!]
  addresses: CustomerAddressBoolExp
  blocked: CustomerBanBoolExp
  createdAt: TimestamptzComparisonExp
  emails: CustomerEmailBoolExp
  firstName: StringComparisonExp
  id: BigintComparisonExp
  lastName: StringComparisonExp
  locale: SpokenLangComparisonExp
  merchant: MerchantBoolExp
  phoneNumbers: CustomerPhoneNumberBoolExp
  purchases: PurchaseBoolExp
  purchasesAggregate: PurchaseAggregateBoolExp
}

"""Emails associated with the customer."""
type CustomerEmail {
  createdAt: timestamptz!

  """Email address of the customer."""
  email: citext!

  """

  Whether this email address is the primary email for the customer.
  There should only be one primary email per customer.

  """
  isPrimary: Boolean!
}

"""
order by aggregate values of table "dna.customer_email"
"""
input CustomerEmailAggregateOrderBy {
  count: OrderBy
  max: CustomerEmailMaxOrderBy
  min: CustomerEmailMinOrderBy
}

"""
Boolean expression to filter rows from the table "dna.customer_email". All fields are combined with a logical 'AND'.
"""
input CustomerEmailBoolExp {
  _and: [CustomerEmailBoolExp!]
  _not: CustomerEmailBoolExp
  _or: [CustomerEmailBoolExp!]
  createdAt: TimestamptzComparisonExp
  email: CitextComparisonExp
  isPrimary: BooleanComparisonExp
}

"""
order by max() on columns of table "dna.customer_email"
"""
input CustomerEmailMaxOrderBy {
  createdAt: OrderBy

  """Email address of the customer."""
  email: OrderBy
}

"""
order by min() on columns of table "dna.customer_email"
"""
input CustomerEmailMinOrderBy {
  createdAt: OrderBy

  """Email address of the customer."""
  email: OrderBy
}

"""Ordering options when selecting data from "dna.customer_email"."""
input CustomerEmailOrderBy {
  createdAt: OrderBy
  email: OrderBy
  isPrimary: OrderBy
}

"""
select columns of table "dna.customer_email"
"""
enum CustomerEmailSelectColumn {
  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  isPrimary
}

"""aggregate max on columns"""
type CustomerMaxFields {
  createdAt: timestamptz
  firstName: String

  """Serial id for each customer"""
  id: bigint
  lastName: String
}

"""aggregate min on columns"""
type CustomerMinFields {
  createdAt: timestamptz
  firstName: String

  """Serial id for each customer"""
  id: bigint
  lastName: String
}

"""Ordering options when selecting data from "dna.customer"."""
input CustomerOrderBy {
  addressesAggregate: CustomerAddressAggregateOrderBy
  blockedAggregate: CustomerBanAggregateOrderBy
  createdAt: OrderBy
  emailsAggregate: CustomerEmailAggregateOrderBy
  firstName: OrderBy
  id: OrderBy
  lastName: OrderBy
  locale: OrderBy
  merchant: MerchantOrderBy
  phoneNumbersAggregate: CustomerPhoneNumberAggregateOrderBy
  purchasesAggregate: PurchaseAggregateOrderBy
}

"""Additional payment data"""
type CustomerPaymentData {
  """An object relationship"""
  device: Device
  email: citext!

  """IP address of the customer where the payment originated from"""
  ip: String!
  locale: spoken_lang!
  name: String!
  reference: String!
}

"""
Boolean expression to filter rows from the table "dna.customer_payment_data". All fields are combined with a logical 'AND'.
"""
input CustomerPaymentDataBoolExp {
  _and: [CustomerPaymentDataBoolExp!]
  _not: CustomerPaymentDataBoolExp
  _or: [CustomerPaymentDataBoolExp!]
  device: DeviceBoolExp
  email: CitextComparisonExp
  ip: StringComparisonExp
  locale: SpokenLangComparisonExp
  name: StringComparisonExp
  reference: StringComparisonExp
}

"""Ordering options when selecting data from "dna.customer_payment_data"."""
input CustomerPaymentDataOrderBy {
  device: DeviceOrderBy
  email: OrderBy
  ip: OrderBy
  locale: OrderBy
  name: OrderBy
  reference: OrderBy
}

"""
select columns of table "dna.customer_payment_data"
"""
enum CustomerPaymentDataSelectColumn {
  """column name"""
  email

  """column name"""
  ip

  """column name"""
  locale

  """column name"""
  name

  """column name"""
  reference
}

"""
Streaming cursor of the table "CustomerPaymentData"
"""
input CustomerPaymentDataStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: CustomerPaymentDataStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input CustomerPaymentDataStreamCursorValueInput {
  email: citext

  """IP address of the customer where the payment originated from"""
  ip: String
  locale: spoken_lang
  name: String
  reference: String
}

"""Phone numbers of the customer."""
type CustomerPhoneNumber {
  createdAt: timestamptz!

  """An object relationship"""
  customer: Customer!
  customerId: bigint!

  """Whether this is the primary phone number of the customer."""
  isPrimary: Boolean!

  """Phone number of the customer."""
  phoneNumber: packed_phone_number!
}

"""
order by aggregate values of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberAggregateOrderBy {
  avg: CustomerPhoneNumberAvgOrderBy
  count: OrderBy
  max: CustomerPhoneNumberMaxOrderBy
  min: CustomerPhoneNumberMinOrderBy
  stddev: CustomerPhoneNumberStddevOrderBy
  stddevPop: CustomerPhoneNumberStddevPopOrderBy
  stddevSamp: CustomerPhoneNumberStddevSampOrderBy
  sum: CustomerPhoneNumberSumOrderBy
  varPop: CustomerPhoneNumberVarPopOrderBy
  varSamp: CustomerPhoneNumberVarSampOrderBy
  variance: CustomerPhoneNumberVarianceOrderBy
}

"""
order by avg() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberAvgOrderBy {
  customerId: OrderBy
}

"""
Boolean expression to filter rows from the table "dna.customer_phone_number". All fields are combined with a logical 'AND'.
"""
input CustomerPhoneNumberBoolExp {
  _and: [CustomerPhoneNumberBoolExp!]
  _not: CustomerPhoneNumberBoolExp
  _or: [CustomerPhoneNumberBoolExp!]
  createdAt: TimestamptzComparisonExp
  customer: CustomerBoolExp
  customerId: BigintComparisonExp
  isPrimary: BooleanComparisonExp
  phoneNumber: PackedPhoneNumberComparisonExp
}

"""
order by max() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberMaxOrderBy {
  createdAt: OrderBy
  customerId: OrderBy
}

"""
order by min() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberMinOrderBy {
  createdAt: OrderBy
  customerId: OrderBy
}

"""Ordering options when selecting data from "dna.customer_phone_number"."""
input CustomerPhoneNumberOrderBy {
  createdAt: OrderBy
  customer: CustomerOrderBy
  customerId: OrderBy
  isPrimary: OrderBy
  phoneNumber: OrderBy
}

"""
select columns of table "dna.customer_phone_number"
"""
enum CustomerPhoneNumberSelectColumn {
  """column name"""
  createdAt

  """column name"""
  customerId

  """column name"""
  isPrimary

  """column name"""
  phoneNumber
}

"""
order by stddev() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberStddevOrderBy {
  customerId: OrderBy
}

"""
order by stddevPop() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberStddevPopOrderBy {
  customerId: OrderBy
}

"""
order by stddevSamp() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberStddevSampOrderBy {
  customerId: OrderBy
}

"""
order by sum() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberSumOrderBy {
  customerId: OrderBy
}

"""
order by varPop() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberVarPopOrderBy {
  customerId: OrderBy
}

"""
order by varSamp() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberVarSampOrderBy {
  customerId: OrderBy
}

"""
order by variance() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberVarianceOrderBy {
  customerId: OrderBy
}

"""
select columns of table "dna.customer"
"""
enum CustomerSelectColumn {
  """column name"""
  createdAt

  """column name"""
  firstName

  """column name"""
  id

  """column name"""
  lastName

  """column name"""
  locale
}

"""aggregate stddev on columns"""
type CustomerStddevFields {
  """Serial id for each customer"""
  id: Float
}

"""aggregate stddevPop on columns"""
type CustomerStddevPopFields {
  """Serial id for each customer"""
  id: Float
}

"""aggregate stddevSamp on columns"""
type CustomerStddevSampFields {
  """Serial id for each customer"""
  id: Float
}

"""aggregate sum on columns"""
type CustomerSumFields {
  """Serial id for each customer"""
  id: bigint
}

"""Customer's preferred title when addressed."""
enum CustomerTitle {
  Miss
  Mr
  Mrs
  Ms
}

"""aggregate varPop on columns"""
type CustomerVarPopFields {
  """Serial id for each customer"""
  id: Float
}

"""aggregate varSamp on columns"""
type CustomerVarSampFields {
  """Serial id for each customer"""
  id: Float
}

"""aggregate variance on columns"""
type CustomerVarianceFields {
  """Serial id for each customer"""
  id: Float
}

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input DateComparisonExp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _isNull: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
Stops the sending of webhooks to the provided URL. Any queued up
webhooks for that URL will be discarded.
"""
input DeleteWebhookUrlInput {
  """
  URL to which the webhook notifications will be sent

  Max length: 1000.
  """
  webhookUrl: String!
}

"""The result of deleting a webhook URL."""
type DeleteWebhookUrlResult {
  """Whether or not a webhook URL was deleted."""
  found: Boolean!
}

"""Device used by a customer"""
type Device {
  browserName: String
  browserVersion: String
  createdAt: timestamptz!

  """Fingerprint of the device. This should be generated on the client side"""
  fingerprint: String!
  ipAddress: inet!

  """City of the device when accessing our service calculated using the ip."""
  ipCity: String

  """
  Continent of the device when accessing our service calculated using the ip.
  """
  ipContinent: String

  """
  Country of the device when accessing our service calculated using the ip.
  """
  ipCountry: String

  """
  Location coordinates of the device when accessing our service calculated using the ip.
  """
  ipLocation: geography
  osName: String
  osVersion: String
  userAgent: String!
}

"""
Boolean expression to filter rows from the table "dna.device". All fields are combined with a logical 'AND'.
"""
input DeviceBoolExp {
  _and: [DeviceBoolExp!]
  _not: DeviceBoolExp
  _or: [DeviceBoolExp!]
  browserName: StringComparisonExp
  browserVersion: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  fingerprint: StringComparisonExp
  ipAddress: InetComparisonExp
  ipCity: StringComparisonExp
  ipContinent: StringComparisonExp
  ipCountry: StringComparisonExp
  ipLocation: GeographyComparisonExp
  osName: StringComparisonExp
  osVersion: StringComparisonExp
  userAgent: StringComparisonExp
}

"""Ordering options when selecting data from "dna.device"."""
input DeviceOrderBy {
  browserName: OrderBy
  browserVersion: OrderBy
  createdAt: OrderBy
  fingerprint: OrderBy
  ipAddress: OrderBy
  ipCity: OrderBy
  ipContinent: OrderBy
  ipCountry: OrderBy
  ipLocation: OrderBy
  osName: OrderBy
  osVersion: OrderBy
  userAgent: OrderBy
}

"""
select columns of table "dna.device"
"""
enum DeviceSelectColumn {
  """column name"""
  browserName

  """column name"""
  browserVersion

  """column name"""
  createdAt

  """column name"""
  fingerprint

  """column name"""
  ipAddress

  """column name"""
  ipCity

  """column name"""
  ipContinent

  """column name"""
  ipCountry

  """column name"""
  ipLocation

  """column name"""
  osName

  """column name"""
  osVersion

  """column name"""
  userAgent
}

"""
Streaming cursor of the table "Device"
"""
input DeviceStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: DeviceStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input DeviceStreamCursorValueInput {
  browserName: String
  browserVersion: String
  createdAt: timestamptz

  """Fingerprint of the device. This should be generated on the client side"""
  fingerprint: String
  ipAddress: inet

  """City of the device when accessing our service calculated using the ip."""
  ipCity: String

  """
  Continent of the device when accessing our service calculated using the ip.
  """
  ipContinent: String

  """
  Country of the device when accessing our service calculated using the ip.
  """
  ipCountry: String

  """
  Location coordinates of the device when accessing our service calculated using the ip.
  """
  ipLocation: geography
  osName: String
  osVersion: String
  userAgent: String
}

"""Arguments for creating a new direct debit payment"""
input DirectDebitPaymentInput {
  """
  The amount the customer pays in minor units.
  So 100,56 kr would be 10056
  """
  amount: Int!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  Merchant's own internal reference that may help the
  merchant in identifying this payment. These have to
  be globally unique but they should be reused for retrying
  a payment.

  Max length: 64.
  """
  merchantReference: String!

  """
  A message to show to the customer on their bank statement.
  It could be an order id or a reference.

  Max length: 50.
  """
  message: String!

  """Payment category that determines the payment flow"""
  paymentCategory: PaymentCategory!

  """
  Our system's own internal reference that can be used uniquely
  in identifying this payment.
  """
  paymentReference: String!

  """The url to return to after the payment is done."""
  returnUrl: String!
}

"""The result of initiating a direct debit payment."""
type DirectDebitPaymentResult {
  """
  Once a payment is initialized, we will start the direct debit payment
  workflow. You can use this token to query the current status
  of the payment.
  """
  waitToken: String!
}

"""
Discount on items made on a purchase after it was captured. The purchase must be captured before it can have discounts.

"""
type Discount {
  createdAt: timestamptz!

  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: bigint!
  id: bigint!

  """An object relationship"""
  item: PurchaseItem!
  purchaseId: bigint!
  reference: citext!
}

"""
aggregated selection of "marketplace.purchase_capture_item_discount"
"""
type DiscountAggregate {
  aggregate: DiscountAggregateFields
  nodes: [Discount!]!
}

input DiscountAggregateBoolExp {
  count: DiscountAggregateBoolExpCount
}

input DiscountAggregateBoolExpCount {
  arguments: [DiscountSelectColumn!]
  distinct: Boolean
  filter: DiscountBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "marketplace.purchase_capture_item_discount"
"""
type DiscountAggregateFields {
  avg: DiscountAvgFields
  count(columns: [DiscountSelectColumn!], distinct: Boolean): Int!
  max: DiscountMaxFields
  min: DiscountMinFields
  stddev: DiscountStddevFields
  stddevPop: DiscountStddevPopFields
  stddevSamp: DiscountStddevSampFields
  sum: DiscountSumFields
  varPop: DiscountVarPopFields
  varSamp: DiscountVarSampFields
  variance: DiscountVarianceFields
}

"""
order by aggregate values of table "marketplace.purchase_capture_item_discount"
"""
input DiscountAggregateOrderBy {
  avg: DiscountAvgOrderBy
  count: OrderBy
  max: DiscountMaxOrderBy
  min: DiscountMinOrderBy
  stddev: DiscountStddevOrderBy
  stddevPop: DiscountStddevPopOrderBy
  stddevSamp: DiscountStddevSampOrderBy
  sum: DiscountSumOrderBy
  varPop: DiscountVarPopOrderBy
  varSamp: DiscountVarSampOrderBy
  variance: DiscountVarianceOrderBy
}

"""aggregate avg on columns"""
type DiscountAvgFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: Float
  id: Float
  purchaseId: Float
}

"""
order by avg() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountAvgOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.purchase_capture_item_discount". All fields are combined with a logical 'AND'.
"""
input DiscountBoolExp {
  _and: [DiscountBoolExp!]
  _not: DiscountBoolExp
  _or: [DiscountBoolExp!]
  createdAt: TimestamptzComparisonExp
  discountAmount: BigintComparisonExp
  id: BigintComparisonExp
  item: PurchaseItemBoolExp
  purchaseId: BigintComparisonExp
  reference: CitextComparisonExp
}

"""aggregate max on columns"""
type DiscountMaxFields {
  createdAt: timestamptz

  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: bigint
  id: bigint
  purchaseId: bigint
  reference: citext
}

"""
order by max() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountMaxOrderBy {
  createdAt: OrderBy

  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
  reference: OrderBy
}

"""aggregate min on columns"""
type DiscountMinFields {
  createdAt: timestamptz

  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: bigint
  id: bigint
  purchaseId: bigint
  reference: citext
}

"""
order by min() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountMinOrderBy {
  createdAt: OrderBy

  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
  reference: OrderBy
}

"""
Ordering options when selecting data from "marketplace.purchase_capture_item_discount".
"""
input DiscountOrderBy {
  createdAt: OrderBy
  discountAmount: OrderBy
  id: OrderBy
  item: PurchaseItemOrderBy
  purchaseId: OrderBy
  reference: OrderBy
}

"""
select columns of table "marketplace.purchase_capture_item_discount"
"""
enum DiscountSelectColumn {
  """column name"""
  createdAt

  """column name"""
  discountAmount

  """column name"""
  id

  """column name"""
  purchaseId

  """column name"""
  reference
}

"""aggregate stddev on columns"""
type DiscountStddevFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: Float
  id: Float
  purchaseId: Float
}

"""
order by stddev() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountStddevOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""aggregate stddevPop on columns"""
type DiscountStddevPopFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: Float
  id: Float
  purchaseId: Float
}

"""
order by stddevPop() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountStddevPopOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""aggregate stddevSamp on columns"""
type DiscountStddevSampFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: Float
  id: Float
  purchaseId: Float
}

"""
order by stddevSamp() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountStddevSampOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""aggregate sum on columns"""
type DiscountSumFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: bigint
  id: bigint
  purchaseId: bigint
}

"""
order by sum() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountSumOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""aggregate varPop on columns"""
type DiscountVarPopFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: Float
  id: Float
  purchaseId: Float
}

"""
order by varPop() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountVarPopOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""aggregate varSamp on columns"""
type DiscountVarSampFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: Float
  id: Float
  purchaseId: Float
}

"""
order by varSamp() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountVarSampOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""aggregate variance on columns"""
type DiscountVarianceFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: Float
  id: Float
  purchaseId: Float
}

"""
order by variance() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountVarianceOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""Edit user's role."""
input EditUserInput {
  """List of users that should be changed."""
  editUsers: [EditUserSingleInput!]!
}

"""Result of the editions"""
type EditUserResult {
  """The number of users modified."""
  usersChanged: Int!
}

"""The information needed to edit a user role."""
input EditUserSingleInput {
  """Email of the user, for reference."""
  email: String!

  """Role that this user should have."""
  role: String!

  """
  One of "google", "password" or "webauthn", indicates the type of user to be modify.
  Max length: 64.
  """
  userType: String!
}

"""
Describes the schema for the finshark payment transaction details to be used by hasura
"""
type FinsharkDetails {
  customerAccountBic: String

  """Currency code of the account if known"""
  customerAccountCurrencyCode: String

  """Account number of the customer"""
  customerAccountNumber: String

  """Account type (IBAN or BBAN)"""
  customerAccountType: String

  """Customer's email if known"""
  customerEmail: String

  """Customer's own message if set"""
  customerMessage: String
  customerName: String

  """Customer's phone number if known"""
  customerPhoneNumber: String

  """Payment ID as created in Finshark"""
  finsharkId: String
}

"""
order by aggregate values of table "runtime.transaction_finshark_details"
"""
input FinsharkDetailsAggregateOrderBy {
  count: OrderBy
  max: FinsharkDetailsMaxOrderBy
  min: FinsharkDetailsMinOrderBy
}

"""
Boolean expression to filter rows from the table "runtime.transaction_finshark_details". All fields are combined with a logical 'AND'.
"""
input FinsharkDetailsBoolExp {
  _and: [FinsharkDetailsBoolExp!]
  _not: FinsharkDetailsBoolExp
  _or: [FinsharkDetailsBoolExp!]
  customerAccountBic: StringComparisonExp
  customerAccountCurrencyCode: StringComparisonExp
  customerAccountNumber: StringComparisonExp
  customerAccountType: StringComparisonExp
  customerEmail: StringComparisonExp
  customerMessage: StringComparisonExp
  customerName: StringComparisonExp
  customerPhoneNumber: StringComparisonExp
  finsharkId: StringComparisonExp
}

"""
order by max() on columns of table "runtime.transaction_finshark_details"
"""
input FinsharkDetailsMaxOrderBy {
  customerAccountBic: OrderBy

  """Currency code of the account if known"""
  customerAccountCurrencyCode: OrderBy

  """Account number of the customer"""
  customerAccountNumber: OrderBy

  """Account type (IBAN or BBAN)"""
  customerAccountType: OrderBy

  """Customer's email if known"""
  customerEmail: OrderBy

  """Customer's own message if set"""
  customerMessage: OrderBy
  customerName: OrderBy

  """Customer's phone number if known"""
  customerPhoneNumber: OrderBy

  """Payment ID as created in Finshark"""
  finsharkId: OrderBy
}

"""
order by min() on columns of table "runtime.transaction_finshark_details"
"""
input FinsharkDetailsMinOrderBy {
  customerAccountBic: OrderBy

  """Currency code of the account if known"""
  customerAccountCurrencyCode: OrderBy

  """Account number of the customer"""
  customerAccountNumber: OrderBy

  """Account type (IBAN or BBAN)"""
  customerAccountType: OrderBy

  """Customer's email if known"""
  customerEmail: OrderBy

  """Customer's own message if set"""
  customerMessage: OrderBy
  customerName: OrderBy

  """Customer's phone number if known"""
  customerPhoneNumber: OrderBy

  """Payment ID as created in Finshark"""
  finsharkId: OrderBy
}

"""
Ordering options when selecting data from "runtime.transaction_finshark_details".
"""
input FinsharkDetailsOrderBy {
  customerAccountBic: OrderBy
  customerAccountCurrencyCode: OrderBy
  customerAccountNumber: OrderBy
  customerAccountType: OrderBy
  customerEmail: OrderBy
  customerMessage: OrderBy
  customerName: OrderBy
  customerPhoneNumber: OrderBy
  finsharkId: OrderBy
}

"""
select columns of table "runtime.transaction_finshark_details"
"""
enum FinsharkDetailsSelectColumn {
  """column name"""
  customerAccountBic

  """column name"""
  customerAccountCurrencyCode

  """column name"""
  customerAccountNumber

  """column name"""
  customerAccountType

  """column name"""
  customerEmail

  """column name"""
  customerMessage

  """column name"""
  customerName

  """column name"""
  customerPhoneNumber

  """column name"""
  finsharkId
}

"""Arguments to generate presigned URLs for the merchant"""
input GeneratePaymentCSVInput {
  """
  A date in yyyy-mm-dd format, non-nullable, filters payments in CSV, only including payments created till this date.
  Has to be greater or equal than start_date and no dates bigger than current date in UTC are allowed.
  """
  endDate: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  A date in yyyy-mm-dd format, non-nullable, filters payments in CSV, only including payments created from this date.
  Has to be smaller or equal than end_date.
  """
  startDate: String!
}

"""The result of a generatePaymentCSV mutation."""
type GeneratePaymentCSVResult {
  """You can use this token to query the generated payments csv link."""
  waitToken: bigint!
}

"""Arguments to generate presigned URLs for the merchant"""
input GeneratePaymentRequestCSVInput {
  """The credit card number of the payment request."""
  creditCardNumber: String

  """List of credit card types to be included in the CSV."""
  creditCardTypeIn: [String!]

  """List of currencies to be included in the CSV."""
  currencyIn: [String!]

  """The email address of the customer that initiated the payment request."""
  customerEmail: String

  """The name of the customer that initiated the payment request."""
  customerName: String

  """The phone number of the customer that initiated the payment request."""
  customerPhoneNumber: String

  """
  A date in yyyy-mm-dd format, non-nullable, filters payment requests
  in CSV, only including payment requests created till this date. Has
  to be greater than or equal to start_date and no dates bigger than
  current date in UTC are allowed.
  """
  endDate: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """The highest amount, in minor units, to include."""
  maxAmount: Int

  """The lowest amount, in minor units, to include."""
  minAmount: Int

  """List of payment methods to be included in the CSV."""
  paymentMethodIn: [PaymentRequestMethod!]

  """The reference number of the payment request."""
  reference: String

  """List of refund statuses to be included in the CSV."""
  refundStatusIn: [PaymentRequestRefundStatus!]

  """
  A date in yyyy-mm-dd format, non-nullable, filters payment requests
  in CSV, only including payment requests created from this date. Has
  to be smaller than or equal to end_date.
  """
  startDate: String!

  """List of statuses to be included in the CSV."""
  statusIn: [PaymentRequestStatus!]
}

"""The result of a generatePaymentRequestCSV mutation."""
type GeneratePaymentRequestCSVResult {
  """
  You can use this token to query the generated payment requests csv link.
  """
  waitToken: bigint!
}

"""Arguments to generate presigned URLs for the merchant"""
input GeneratePurchaseCSVInput {
  """
  A date in yyyy-mm-dd format, non-nullable, filters purchases in CSV, only including purchases created before this date.
  Has to be greater or equal than start_date and no dates bigger than current date in UTC are allowed.
  """
  endDate: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  A list of statuses to filter, will only include purchases in CSV that contain one of the given statuses,
  empty list will omit this filter.
  """
  purchaseStatus: [String!]!

  """
  A date in yyyy-mm-dd format, non-nullable, filters purchases in CSV, only including purchases created after this date.
  Has to be smaller or equal than end_date.
  """
  startDate: String!
}

"""The result of a generatePurchaseCSV mutation."""
type GeneratePurchaseCSVResult {
  """You can use this token to query the generated purchases csv link."""
  waitToken: bigint!
}

"""
Arguments to generate presigned URLs for the merchant for a reconciliation report
"""
input GenerateReconciliationCSVInput {
  """
  A date in yyyy-mm-dd format, non-nullable, filters elements in CSV, only including elements created before this date.
  Has to be greater or equal than start_date and no dates bigger than current date in UTC are allowed.
  """
  endDate: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  A date in yyyy-mm-dd format, non-nullable, filters elements in CSV, only including elements created after this date.
  Has to be smaller or equal than end_date.
  """
  startDate: String!
}

"""The result of a generateReconciliationCSV mutation."""
type GenerateReconciliationCSVResult {
  """You can use this token to query the generated reconciliation csv link."""
  waitToken: bigint!
}

"""Arguments to generate presigned URLs for the merchant"""
input GenerateReportInput {
  """
  The end date till when the report is to be generated for.
  Provide the dates in the merchant's own time zone. Only CET for now.
  """
  endDate: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  The start date from when the report is to be generated for.
  Provide the dates in the merchant's own time zone. Only CET for now.
  """
  startDate: String!
}

"""The result of a generateReport mutation."""
type GenerateReportResult {
  """You can use this token to query the generated reports link."""
  waitToken: Int!
}

"""
Arguments to generate presigned URLs for the merchant for a Valitor transactions CSV file
"""
input GenerateValitorTransactionsCSVLinkInput {
  """The ID of the CSV file that is requested."""
  csvId: bigint!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!
}

"""The result of a generateValitorTransactionsCSVLink mutation."""
type GenerateValitorTransactionsCSVLinkResult {
  """You can use this id to query the Valitor transaction CSV link."""
  id: bigint!
}

input GeographyCastExp {
  geometry: GeometryComparisonExp
}

"""
Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'.
"""
input GeographyComparisonExp {
  _cast: GeographyCastExp
  _eq: geography
  _gt: geography
  _gte: geography
  _in: [geography!]
  _isNull: Boolean
  _lt: geography
  _lte: geography
  _neq: geography
  _nin: [geography!]

  """is the column within a given distance from the given geography value"""
  _stDWithin: st_d_within_geography_input

  """does the column spatially intersect the given geography value"""
  _stIntersects: geography
}

input GeometryCastExp {
  geography: GeographyComparisonExp
}

"""
Boolean expression to compare columns of type "geometry". All fields are combined with logical 'AND'.
"""
input GeometryComparisonExp {
  _cast: GeometryCastExp
  _eq: geometry
  _gt: geometry
  _gte: geometry
  _in: [geometry!]
  _isNull: Boolean
  _lt: geometry
  _lte: geometry
  _neq: geometry
  _nin: [geometry!]

  """is the column within a given 3D distance from the given geometry value"""
  _st3dDWithin: st_d_within_input

  """does the column spatially intersect the given geometry value in 3D"""
  _st3dIntersects: geometry

  """does the column contain the given geometry value"""
  _stContains: geometry

  """does the column cross the given geometry value"""
  _stCrosses: geometry

  """is the column within a given distance from the given geometry value"""
  _stDWithin: st_d_within_input

  """
  is the column equal to given geometry value (directionality is ignored)
  """
  _stEquals: geometry

  """does the column spatially intersect the given geometry value"""
  _stIntersects: geometry

  """
  does the column 'spatially overlap' (intersect but not completely contain) the given geometry value
  """
  _stOverlaps: geometry

  """
  does the column have atleast one point in common with the given geometry value
  """
  _stTouches: geometry

  """is the column contained in the given geometry value"""
  _stWithin: geometry
}

"""
Boolean expression to compare columns of type "inet". All fields are combined with logical 'AND'.
"""
input InetComparisonExp {
  _eq: inet
  _gt: inet
  _gte: inet
  _in: [inet!]
  _isNull: Boolean
  _lt: inet
  _lte: inet
  _neq: inet
  _nin: [inet!]
}

"""

One of the parts into with a debt is divided for a purchase.
Payment is dived in intervals of 30 days.

"""
type Instalment {
  """Contains the total amount to pay, including fees"""
  amountDue: bigint!
  amountPaid: bigint!

  """Date the payment for the instalment is due"""
  dueDate: timestamptz!
  id: bigint!

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: bigint!

  """The part number for the debt, in sequential numbering"""
  partNumber: smallint!
  paymentMethod: PaymentMethodEnum
  purchaseId: bigint!
  reminderFee: bigint!
  serviceFee: bigint!
  status: String!
}

"""
order by aggregate values of table "instalment.instalment"
"""
input InstalmentAggregateOrderBy {
  avg: InstalmentAvgOrderBy
  count: OrderBy
  max: InstalmentMaxOrderBy
  min: InstalmentMinOrderBy
  stddev: InstalmentStddevOrderBy
  stddevPop: InstalmentStddevPopOrderBy
  stddevSamp: InstalmentStddevSampOrderBy
  sum: InstalmentSumOrderBy
  varPop: InstalmentVarPopOrderBy
  varSamp: InstalmentVarSampOrderBy
  variance: InstalmentVarianceOrderBy
}

"""
order by avg() on columns of table "instalment.instalment"
"""
input InstalmentAvgOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
Boolean expression to filter rows from the table "instalment.instalment". All fields are combined with a logical 'AND'.
"""
input InstalmentBoolExp {
  _and: [InstalmentBoolExp!]
  _not: InstalmentBoolExp
  _or: [InstalmentBoolExp!]
  amountDue: BigintComparisonExp
  amountPaid: BigintComparisonExp
  dueDate: TimestamptzComparisonExp
  id: BigintComparisonExp
  monthlyInstalment: BigintComparisonExp
  partNumber: SmallintComparisonExp
  paymentMethod: PaymentMethodEnumComparisonExp
  purchaseId: BigintComparisonExp
  reminderFee: BigintComparisonExp
  serviceFee: BigintComparisonExp
  status: StringComparisonExp
}

"""
order by max() on columns of table "instalment.instalment"
"""
input InstalmentMaxOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy

  """Date the payment for the instalment is due"""
  dueDate: OrderBy
  id: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
  status: OrderBy
}

"""
order by min() on columns of table "instalment.instalment"
"""
input InstalmentMinOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy

  """Date the payment for the instalment is due"""
  dueDate: OrderBy
  id: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
  status: OrderBy
}

"""Ordering options when selecting data from "instalment.instalment"."""
input InstalmentOrderBy {
  amountDue: OrderBy
  amountPaid: OrderBy
  dueDate: OrderBy
  id: OrderBy
  monthlyInstalment: OrderBy
  partNumber: OrderBy
  paymentMethod: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
  status: OrderBy
}

"""
select columns of table "instalment.instalment"
"""
enum InstalmentSelectColumn {
  """column name"""
  amountDue

  """column name"""
  amountPaid

  """column name"""
  dueDate

  """column name"""
  id

  """column name"""
  monthlyInstalment

  """column name"""
  partNumber

  """column name"""
  paymentMethod

  """column name"""
  purchaseId

  """column name"""
  reminderFee

  """column name"""
  serviceFee

  """column name"""
  status
}

"""
order by stddev() on columns of table "instalment.instalment"
"""
input InstalmentStddevOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
order by stddevPop() on columns of table "instalment.instalment"
"""
input InstalmentStddevPopOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
order by stddevSamp() on columns of table "instalment.instalment"
"""
input InstalmentStddevSampOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
order by sum() on columns of table "instalment.instalment"
"""
input InstalmentSumOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
order by varPop() on columns of table "instalment.instalment"
"""
input InstalmentVarPopOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
order by varSamp() on columns of table "instalment.instalment"
"""
input InstalmentVarSampOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
order by variance() on columns of table "instalment.instalment"
"""
input InstalmentVarianceOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "interval". All fields are combined with logical 'AND'.
"""
input IntervalComparisonExp {
  _eq: interval
  _gt: interval
  _gte: interval
  _in: [interval!]
  _isNull: Boolean
  _lt: interval
  _lte: interval
  _neq: interval
  _nin: [interval!]
}

"""
Purchase invoice containing current balance, deadline dates and customer data.
"""
type Invoice {
  createdAt: timestamptz!
  dueDate: timestamptz!
  expectedAmount: bigint!
  invoiceNumber: bigint!

  """An object relationship"""
  invoicePage: InvoicePage
  invoicePageJwt: String!
  merchantReference: String!

  """An array relationship"""
  notes(
    """distinct select on columns"""
    distinctOn: [InvoiceNoteSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceNoteOrderBy!]

    """filter the rows returned"""
    where: InvoiceNoteBoolExp
  ): [InvoiceNote!]!

  """An aggregate relationship"""
  notesAggregate(
    """distinct select on columns"""
    distinctOn: [InvoiceNoteSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceNoteOrderBy!]

    """filter the rows returned"""
    where: InvoiceNoteBoolExp
  ): InvoiceNoteAggregate!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinctOn: [InvoicePaymentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoicePaymentOrderBy!]

    """filter the rows returned"""
    where: InvoicePaymentBoolExp
  ): [InvoicePayment!]!
  purchaseId: bigint!
}

"""
aggregated selection of "invoice.invoice"
"""
type InvoiceAggregate {
  aggregate: InvoiceAggregateFields
  nodes: [Invoice!]!
}

"""
aggregate fields of "invoice.invoice"
"""
type InvoiceAggregateFields {
  avg: InvoiceAvgFields
  count(columns: [InvoiceSelectColumn!], distinct: Boolean): Int!
  max: InvoiceMaxFields
  min: InvoiceMinFields
  stddev: InvoiceStddevFields
  stddevPop: InvoiceStddevPopFields
  stddevSamp: InvoiceStddevSampFields
  sum: InvoiceSumFields
  varPop: InvoiceVarPopFields
  varSamp: InvoiceVarSampFields
  variance: InvoiceVarianceFields
}

"""aggregate avg on columns"""
type InvoiceAvgFields {
  expectedAmount: Float
  invoiceNumber: Float
  purchaseId: Float
}

"""
Boolean expression to filter rows from the table "invoice.invoice". All fields are combined with a logical 'AND'.
"""
input InvoiceBoolExp {
  _and: [InvoiceBoolExp!]
  _not: InvoiceBoolExp
  _or: [InvoiceBoolExp!]
  createdAt: TimestamptzComparisonExp
  dueDate: TimestamptzComparisonExp
  expectedAmount: BigintComparisonExp
  invoiceNumber: BigintComparisonExp
  invoicePage: InvoicePageBoolExp
  invoicePageJwt: StringComparisonExp
  merchantReference: StringComparisonExp
  notes: InvoiceNoteBoolExp
  notesAggregate: InvoiceNoteAggregateBoolExp
  payments: InvoicePaymentBoolExp
  purchaseId: BigintComparisonExp
}

"""A new date for an invoiced purchase"""
input InvoiceDueDateAdjustInput {
  """
  The new invoice due date. Only CET for now.
  The due date should be within 60 days of the current date.
  """
  dueDate: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """This is the id of the purchase associated with the invoice."""
  purchaseId: bigint!
}

"""The result of processing an invoice due date adjustment."""
type InvoiceDueDateAdjustResult {
  """The adjusted due date."""
  dueDate: String!

  """The id of the newly created adjustment."""
  returnId: Int!
}

"""aggregate max on columns"""
type InvoiceMaxFields {
  createdAt: timestamptz
  dueDate: timestamptz
  expectedAmount: bigint
  invoiceNumber: bigint
  invoicePageJwt: String
  merchantReference: String
  purchaseId: bigint
}

"""aggregate min on columns"""
type InvoiceMinFields {
  createdAt: timestamptz
  dueDate: timestamptz
  expectedAmount: bigint
  invoiceNumber: bigint
  invoicePageJwt: String
  merchantReference: String
  purchaseId: bigint
}

"""A note added by a merchant admin on an invoice"""
type InvoiceNote {
  createdAt: timestamptz!
  createdBy: String!
  id: bigint!
  invoiceNumber: bigint!
  note: String!
  purchaseId: bigint!
}

"""
aggregated selection of "invoice.note"
"""
type InvoiceNoteAggregate {
  aggregate: InvoiceNoteAggregateFields
  nodes: [InvoiceNote!]!
}

input InvoiceNoteAggregateBoolExp {
  count: InvoiceNoteAggregateBoolExpCount
}

input InvoiceNoteAggregateBoolExpCount {
  arguments: [InvoiceNoteSelectColumn!]
  distinct: Boolean
  filter: InvoiceNoteBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "invoice.note"
"""
type InvoiceNoteAggregateFields {
  avg: InvoiceNoteAvgFields
  count(columns: [InvoiceNoteSelectColumn!], distinct: Boolean): Int!
  max: InvoiceNoteMaxFields
  min: InvoiceNoteMinFields
  stddev: InvoiceNoteStddevFields
  stddevPop: InvoiceNoteStddevPopFields
  stddevSamp: InvoiceNoteStddevSampFields
  sum: InvoiceNoteSumFields
  varPop: InvoiceNoteVarPopFields
  varSamp: InvoiceNoteVarSampFields
  variance: InvoiceNoteVarianceFields
}

"""
order by aggregate values of table "invoice.note"
"""
input InvoiceNoteAggregateOrderBy {
  avg: InvoiceNoteAvgOrderBy
  count: OrderBy
  max: InvoiceNoteMaxOrderBy
  min: InvoiceNoteMinOrderBy
  stddev: InvoiceNoteStddevOrderBy
  stddevPop: InvoiceNoteStddevPopOrderBy
  stddevSamp: InvoiceNoteStddevSampOrderBy
  sum: InvoiceNoteSumOrderBy
  varPop: InvoiceNoteVarPopOrderBy
  varSamp: InvoiceNoteVarSampOrderBy
  variance: InvoiceNoteVarianceOrderBy
}

"""aggregate avg on columns"""
type InvoiceNoteAvgFields {
  id: Float
  invoiceNumber: Float
  purchaseId: Float
}

"""
order by avg() on columns of table "invoice.note"
"""
input InvoiceNoteAvgOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  purchaseId: OrderBy
}

"""
Boolean expression to filter rows from the table "invoice.note". All fields are combined with a logical 'AND'.
"""
input InvoiceNoteBoolExp {
  _and: [InvoiceNoteBoolExp!]
  _not: InvoiceNoteBoolExp
  _or: [InvoiceNoteBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: StringComparisonExp
  id: BigintComparisonExp
  invoiceNumber: BigintComparisonExp
  note: StringComparisonExp
  purchaseId: BigintComparisonExp
}

"""Arguments for adding a note to an invoice"""
input InvoiceNoteInput {
  """The invoice the note corresponds to."""
  invoiceNumber: bigint!

  """
  The message the admin wants to add to the invoice.

  Max length: 1000.
  """
  message: String!

  """
  The purchaseId corresponding to the invoice to which the note is to be added.
  """
  purchaseId: bigint!
}

"""aggregate max on columns"""
type InvoiceNoteMaxFields {
  createdAt: timestamptz
  createdBy: String
  id: bigint
  invoiceNumber: bigint
  note: String
  purchaseId: bigint
}

"""
order by max() on columns of table "invoice.note"
"""
input InvoiceNoteMaxOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  id: OrderBy
  invoiceNumber: OrderBy
  note: OrderBy
  purchaseId: OrderBy
}

"""aggregate min on columns"""
type InvoiceNoteMinFields {
  createdAt: timestamptz
  createdBy: String
  id: bigint
  invoiceNumber: bigint
  note: String
  purchaseId: bigint
}

"""
order by min() on columns of table "invoice.note"
"""
input InvoiceNoteMinOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  id: OrderBy
  invoiceNumber: OrderBy
  note: OrderBy
  purchaseId: OrderBy
}

"""Ordering options when selecting data from "invoice.note"."""
input InvoiceNoteOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  id: OrderBy
  invoiceNumber: OrderBy
  note: OrderBy
  purchaseId: OrderBy
}

"""The result of adding a note to the invoice."""
type InvoiceNoteResult {
  """The resulting id of adding a note to the invoice."""
  resultingNoteId: bigint!
}

"""
select columns of table "invoice.note"
"""
enum InvoiceNoteSelectColumn {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  id

  """column name"""
  invoiceNumber

  """column name"""
  note

  """column name"""
  purchaseId
}

"""aggregate stddev on columns"""
type InvoiceNoteStddevFields {
  id: Float
  invoiceNumber: Float
  purchaseId: Float
}

"""
order by stddev() on columns of table "invoice.note"
"""
input InvoiceNoteStddevOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  purchaseId: OrderBy
}

"""aggregate stddevPop on columns"""
type InvoiceNoteStddevPopFields {
  id: Float
  invoiceNumber: Float
  purchaseId: Float
}

"""
order by stddevPop() on columns of table "invoice.note"
"""
input InvoiceNoteStddevPopOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  purchaseId: OrderBy
}

"""aggregate stddevSamp on columns"""
type InvoiceNoteStddevSampFields {
  id: Float
  invoiceNumber: Float
  purchaseId: Float
}

"""
order by stddevSamp() on columns of table "invoice.note"
"""
input InvoiceNoteStddevSampOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  purchaseId: OrderBy
}

"""aggregate sum on columns"""
type InvoiceNoteSumFields {
  id: bigint
  invoiceNumber: bigint
  purchaseId: bigint
}

"""
order by sum() on columns of table "invoice.note"
"""
input InvoiceNoteSumOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  purchaseId: OrderBy
}

"""aggregate varPop on columns"""
type InvoiceNoteVarPopFields {
  id: Float
  invoiceNumber: Float
  purchaseId: Float
}

"""
order by varPop() on columns of table "invoice.note"
"""
input InvoiceNoteVarPopOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  purchaseId: OrderBy
}

"""aggregate varSamp on columns"""
type InvoiceNoteVarSampFields {
  id: Float
  invoiceNumber: Float
  purchaseId: Float
}

"""
order by varSamp() on columns of table "invoice.note"
"""
input InvoiceNoteVarSampOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  purchaseId: OrderBy
}

"""aggregate variance on columns"""
type InvoiceNoteVarianceFields {
  id: Float
  invoiceNumber: Float
  purchaseId: Float
}

"""
order by variance() on columns of table "invoice.note"
"""
input InvoiceNoteVarianceOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  purchaseId: OrderBy
}

"""Ordering options when selecting data from "invoice.invoice"."""
input InvoiceOrderBy {
  createdAt: OrderBy
  dueDate: OrderBy
  expectedAmount: OrderBy
  invoiceNumber: OrderBy
  invoicePage: InvoicePageOrderBy
  invoicePageJwt: OrderBy
  merchantReference: OrderBy
  notesAggregate: InvoiceNoteAggregateOrderBy
  paymentsAggregate: InvoicePaymentAggregateOrderBy
  purchaseId: OrderBy
}

"""A view of everything needed to render an invoice"""
type InvoicePage {
  currency: String!
  dueDate: timestamptz!
  expectedAmount: bigint!
  invoiceNumber: bigint!
  invoicePageJwt: String!
  locale: spoken_lang!
  merchantReference: String
  minimumExpected: bigint!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinctOn: [InvoicePaymentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoicePaymentOrderBy!]

    """filter the rows returned"""
    where: InvoicePaymentBoolExp
  ): [InvoicePayment!]!
  purchaseId: bigint!
  status: String!

  """An array relationship"""
  surcharges(
    """distinct select on columns"""
    distinctOn: [InvoiceSurchargeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceSurchargeOrderBy!]

    """filter the rows returned"""
    where: InvoiceSurchargeBoolExp
  ): [InvoiceSurcharge!]!

  """An array relationship"""
  transactions(
    """distinct select on columns"""
    distinctOn: [InvoiceTransactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceTransactionOrderBy!]

    """filter the rows returned"""
    where: InvoiceTransactionBoolExp
  ): [InvoiceTransaction!]!
}

"""
Boolean expression to filter rows from the table "invoice_page.invoice_page". All fields are combined with a logical 'AND'.
"""
input InvoicePageBoolExp {
  _and: [InvoicePageBoolExp!]
  _not: InvoicePageBoolExp
  _or: [InvoicePageBoolExp!]
  currency: StringComparisonExp
  dueDate: TimestamptzComparisonExp
  expectedAmount: BigintComparisonExp
  invoiceNumber: BigintComparisonExp
  invoicePageJwt: StringComparisonExp
  locale: SpokenLangComparisonExp
  merchantReference: StringComparisonExp
  minimumExpected: BigintComparisonExp
  payments: InvoicePaymentBoolExp
  purchaseId: BigintComparisonExp
  status: StringComparisonExp
  surcharges: InvoiceSurchargeBoolExp
  transactions: InvoiceTransactionBoolExp
}

"""Ordering options when selecting data from "invoice_page.invoice_page"."""
input InvoicePageOrderBy {
  currency: OrderBy
  dueDate: OrderBy
  expectedAmount: OrderBy
  invoiceNumber: OrderBy
  invoicePageJwt: OrderBy
  locale: OrderBy
  merchantReference: OrderBy
  minimumExpected: OrderBy
  paymentsAggregate: InvoicePaymentAggregateOrderBy
  purchaseId: OrderBy
  status: OrderBy
  surchargesAggregate: InvoiceSurchargeAggregateOrderBy
  transactionsAggregate: InvoiceTransactionAggregateOrderBy
}

"""
select columns of table "invoice_page.invoice_page"
"""
enum InvoicePageSelectColumn {
  """column name"""
  currency

  """column name"""
  dueDate

  """column name"""
  expectedAmount

  """column name"""
  invoiceNumber

  """column name"""
  invoicePageJwt

  """column name"""
  locale

  """column name"""
  merchantReference

  """column name"""
  minimumExpected

  """column name"""
  purchaseId

  """column name"""
  status
}

"""A payment done towards an invoice"""
type InvoicePayment {
  amountPaid: bigint!
  createdAt: timestamptz!
  currency: currency!
  id: bigint!
  paymentMethod: String!
  purchaseId: bigint!
}

"""
order by aggregate values of table "invoice_page.invoice_payment"
"""
input InvoicePaymentAggregateOrderBy {
  avg: InvoicePaymentAvgOrderBy
  count: OrderBy
  max: InvoicePaymentMaxOrderBy
  min: InvoicePaymentMinOrderBy
  stddev: InvoicePaymentStddevOrderBy
  stddevPop: InvoicePaymentStddevPopOrderBy
  stddevSamp: InvoicePaymentStddevSampOrderBy
  sum: InvoicePaymentSumOrderBy
  varPop: InvoicePaymentVarPopOrderBy
  varSamp: InvoicePaymentVarSampOrderBy
  variance: InvoicePaymentVarianceOrderBy
}

"""
order by avg() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentAvgOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
Boolean expression to filter rows from the table "invoice_page.invoice_payment". All fields are combined with a logical 'AND'.
"""
input InvoicePaymentBoolExp {
  _and: [InvoicePaymentBoolExp!]
  _not: InvoicePaymentBoolExp
  _or: [InvoicePaymentBoolExp!]
  amountPaid: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  currency: CurrencyComparisonExp
  id: BigintComparisonExp
  paymentMethod: StringComparisonExp
  purchaseId: BigintComparisonExp
}

"""
order by max() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentMaxOrderBy {
  amountPaid: OrderBy
  createdAt: OrderBy
  id: OrderBy
  paymentMethod: OrderBy
  purchaseId: OrderBy
}

"""
order by min() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentMinOrderBy {
  amountPaid: OrderBy
  createdAt: OrderBy
  id: OrderBy
  paymentMethod: OrderBy
  purchaseId: OrderBy
}

"""
Ordering options when selecting data from "invoice_page.invoice_payment".
"""
input InvoicePaymentOrderBy {
  amountPaid: OrderBy
  createdAt: OrderBy
  currency: OrderBy
  id: OrderBy
  paymentMethod: OrderBy
  purchaseId: OrderBy
}

"""
select columns of table "invoice_page.invoice_payment"
"""
enum InvoicePaymentSelectColumn {
  """column name"""
  amountPaid

  """column name"""
  createdAt

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  paymentMethod

  """column name"""
  purchaseId
}

"""
order by stddev() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentStddevOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by stddevPop() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentStddevPopOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by stddevSamp() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentStddevSampOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by sum() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentSumOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by varPop() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentVarPopOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by varSamp() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentVarSampOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by variance() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentVarianceOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
select columns of table "invoice.invoice"
"""
enum InvoiceSelectColumn {
  """column name"""
  createdAt

  """column name"""
  dueDate

  """column name"""
  expectedAmount

  """column name"""
  invoiceNumber

  """column name"""
  invoicePageJwt

  """column name"""
  merchantReference

  """column name"""
  purchaseId
}

"""aggregate stddev on columns"""
type InvoiceStddevFields {
  expectedAmount: Float
  invoiceNumber: Float
  purchaseId: Float
}

"""aggregate stddevPop on columns"""
type InvoiceStddevPopFields {
  expectedAmount: Float
  invoiceNumber: Float
  purchaseId: Float
}

"""aggregate stddevSamp on columns"""
type InvoiceStddevSampFields {
  expectedAmount: Float
  invoiceNumber: Float
  purchaseId: Float
}

"""aggregate sum on columns"""
type InvoiceSumFields {
  expectedAmount: bigint
  invoiceNumber: bigint
  purchaseId: bigint
}

"""A surcharge (fee) added to an invoice"""
type InvoiceSurcharge {
  amount: bigint!
  createdAt: timestamptz!
  currency: currency!
  id: bigint!
  purchaseId: bigint!
  surchargeType: citext!
}

"""
order by aggregate values of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeAggregateOrderBy {
  avg: InvoiceSurchargeAvgOrderBy
  count: OrderBy
  max: InvoiceSurchargeMaxOrderBy
  min: InvoiceSurchargeMinOrderBy
  stddev: InvoiceSurchargeStddevOrderBy
  stddevPop: InvoiceSurchargeStddevPopOrderBy
  stddevSamp: InvoiceSurchargeStddevSampOrderBy
  sum: InvoiceSurchargeSumOrderBy
  varPop: InvoiceSurchargeVarPopOrderBy
  varSamp: InvoiceSurchargeVarSampOrderBy
  variance: InvoiceSurchargeVarianceOrderBy
}

"""
order by avg() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeAvgOrderBy {
  amount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
Boolean expression to filter rows from the table "invoice_page.invoice_surcharge". All fields are combined with a logical 'AND'.
"""
input InvoiceSurchargeBoolExp {
  _and: [InvoiceSurchargeBoolExp!]
  _not: InvoiceSurchargeBoolExp
  _or: [InvoiceSurchargeBoolExp!]
  amount: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  currency: CurrencyComparisonExp
  id: BigintComparisonExp
  purchaseId: BigintComparisonExp
  surchargeType: CitextComparisonExp
}

"""
order by max() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeMaxOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  id: OrderBy
  purchaseId: OrderBy
  surchargeType: OrderBy
}

"""
order by min() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeMinOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  id: OrderBy
  purchaseId: OrderBy
  surchargeType: OrderBy
}

"""
Ordering options when selecting data from "invoice_page.invoice_surcharge".
"""
input InvoiceSurchargeOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  currency: OrderBy
  id: OrderBy
  purchaseId: OrderBy
  surchargeType: OrderBy
}

"""
select columns of table "invoice_page.invoice_surcharge"
"""
enum InvoiceSurchargeSelectColumn {
  """column name"""
  amount

  """column name"""
  createdAt

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  purchaseId

  """column name"""
  surchargeType
}

"""
order by stddev() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeStddevOrderBy {
  amount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by stddevPop() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeStddevPopOrderBy {
  amount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by stddevSamp() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeStddevSampOrderBy {
  amount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by sum() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeSumOrderBy {
  amount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by varPop() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeVarPopOrderBy {
  amount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by varSamp() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeVarSampOrderBy {
  amount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by variance() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeVarianceOrderBy {
  amount: OrderBy
  id: OrderBy
  purchaseId: OrderBy
}

"""A transaction (capture, return, discount, etc.) for an invoice"""
type InvoiceTransaction {
  createdAt: timestamptz!
  id: bigint!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinctOn: [InvoiceTransactionItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceTransactionItemOrderBy!]

    """filter the rows returned"""
    where: InvoiceTransactionItemBoolExp
  ): [InvoiceTransactionItem!]!
  purchaseId: bigint!

  """An enum value of possible transaction types"""
  transactionType: invoice_transaction_type!
}

"""
order by aggregate values of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionAggregateOrderBy {
  avg: InvoiceTransactionAvgOrderBy
  count: OrderBy
  max: InvoiceTransactionMaxOrderBy
  min: InvoiceTransactionMinOrderBy
  stddev: InvoiceTransactionStddevOrderBy
  stddevPop: InvoiceTransactionStddevPopOrderBy
  stddevSamp: InvoiceTransactionStddevSampOrderBy
  sum: InvoiceTransactionSumOrderBy
  varPop: InvoiceTransactionVarPopOrderBy
  varSamp: InvoiceTransactionVarSampOrderBy
  variance: InvoiceTransactionVarianceOrderBy
}

"""
order by avg() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionAvgOrderBy {
  id: OrderBy
  purchaseId: OrderBy
}

"""
Boolean expression to filter rows from the table "invoice_page.invoice_transaction". All fields are combined with a logical 'AND'.
"""
input InvoiceTransactionBoolExp {
  _and: [InvoiceTransactionBoolExp!]
  _not: InvoiceTransactionBoolExp
  _or: [InvoiceTransactionBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  items: InvoiceTransactionItemBoolExp
  purchaseId: BigintComparisonExp
  transactionType: InvoiceTransactionTypeComparisonExp
}

"""Items apprearing on invoice transactions"""
type InvoiceTransactionItem {
  currency: currency!
  imageUrl: String
  itemUrl: String
  name: String!
  purchaseId: bigint!
  quantity: Int!
  reference: citext!
  totalAmount: bigint!
  totalDiscount: bigint!
  transactionId: bigint!
  transactionType: invoice_transaction_type!
}

"""
order by aggregate values of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemAggregateOrderBy {
  avg: InvoiceTransactionItemAvgOrderBy
  count: OrderBy
  max: InvoiceTransactionItemMaxOrderBy
  min: InvoiceTransactionItemMinOrderBy
  stddev: InvoiceTransactionItemStddevOrderBy
  stddevPop: InvoiceTransactionItemStddevPopOrderBy
  stddevSamp: InvoiceTransactionItemStddevSampOrderBy
  sum: InvoiceTransactionItemSumOrderBy
  varPop: InvoiceTransactionItemVarPopOrderBy
  varSamp: InvoiceTransactionItemVarSampOrderBy
  variance: InvoiceTransactionItemVarianceOrderBy
}

"""
order by avg() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemAvgOrderBy {
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
Boolean expression to filter rows from the table "invoice_page.invoice_transaction_item". All fields are combined with a logical 'AND'.
"""
input InvoiceTransactionItemBoolExp {
  _and: [InvoiceTransactionItemBoolExp!]
  _not: InvoiceTransactionItemBoolExp
  _or: [InvoiceTransactionItemBoolExp!]
  currency: CurrencyComparisonExp
  imageUrl: StringComparisonExp
  itemUrl: StringComparisonExp
  name: StringComparisonExp
  purchaseId: BigintComparisonExp
  quantity: IntComparisonExp
  reference: CitextComparisonExp
  totalAmount: BigintComparisonExp
  totalDiscount: BigintComparisonExp
  transactionId: BigintComparisonExp
  transactionType: InvoiceTransactionTypeComparisonExp
}

"""
order by max() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemMaxOrderBy {
  imageUrl: OrderBy
  itemUrl: OrderBy
  name: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  reference: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
  transactionType: OrderBy
}

"""
order by min() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemMinOrderBy {
  imageUrl: OrderBy
  itemUrl: OrderBy
  name: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  reference: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
  transactionType: OrderBy
}

"""
Ordering options when selecting data from "invoice_page.invoice_transaction_item".
"""
input InvoiceTransactionItemOrderBy {
  currency: OrderBy
  imageUrl: OrderBy
  itemUrl: OrderBy
  name: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  reference: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
  transactionType: OrderBy
}

"""
select columns of table "invoice_page.invoice_transaction_item"
"""
enum InvoiceTransactionItemSelectColumn {
  """column name"""
  currency

  """column name"""
  imageUrl

  """column name"""
  itemUrl

  """column name"""
  name

  """column name"""
  purchaseId

  """column name"""
  quantity

  """column name"""
  reference

  """column name"""
  totalAmount

  """column name"""
  totalDiscount

  """column name"""
  transactionId

  """column name"""
  transactionType
}

"""
order by stddev() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemStddevOrderBy {
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
order by stddevPop() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemStddevPopOrderBy {
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
order by stddevSamp() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemStddevSampOrderBy {
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
order by sum() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemSumOrderBy {
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
order by varPop() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemVarPopOrderBy {
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
order by varSamp() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemVarSampOrderBy {
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
order by variance() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemVarianceOrderBy {
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
order by max() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  purchaseId: OrderBy

  """An enum value of possible transaction types"""
  transactionType: OrderBy
}

"""
order by min() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  purchaseId: OrderBy

  """An enum value of possible transaction types"""
  transactionType: OrderBy
}

"""
Ordering options when selecting data from "invoice_page.invoice_transaction".
"""
input InvoiceTransactionOrderBy {
  createdAt: OrderBy
  id: OrderBy
  itemsAggregate: InvoiceTransactionItemAggregateOrderBy
  purchaseId: OrderBy
  transactionType: OrderBy
}

"""
select columns of table "invoice_page.invoice_transaction"
"""
enum InvoiceTransactionSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  purchaseId

  """column name"""
  transactionType
}

"""
order by stddev() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionStddevOrderBy {
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by stddevPop() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionStddevPopOrderBy {
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by stddevSamp() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionStddevSampOrderBy {
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by sum() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionSumOrderBy {
  id: OrderBy
  purchaseId: OrderBy
}

"""
Boolean expression to compare columns of type "invoice_transaction_type". All fields are combined with logical 'AND'.
"""
input InvoiceTransactionTypeComparisonExp {
  _eq: invoice_transaction_type
  _gt: invoice_transaction_type
  _gte: invoice_transaction_type
  _in: [invoice_transaction_type!]
  _isNull: Boolean
  _lt: invoice_transaction_type
  _lte: invoice_transaction_type
  _neq: invoice_transaction_type
  _nin: [invoice_transaction_type!]
}

"""
order by varPop() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionVarPopOrderBy {
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by varSamp() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionVarSampOrderBy {
  id: OrderBy
  purchaseId: OrderBy
}

"""
order by variance() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionVarianceOrderBy {
  id: OrderBy
  purchaseId: OrderBy
}

"""aggregate varPop on columns"""
type InvoiceVarPopFields {
  expectedAmount: Float
  invoiceNumber: Float
  purchaseId: Float
}

"""aggregate varSamp on columns"""
type InvoiceVarSampFields {
  expectedAmount: Float
  invoiceNumber: Float
  purchaseId: Float
}

"""aggregate variance on columns"""
type InvoiceVarianceFields {
  expectedAmount: Float
  invoiceNumber: Float
  purchaseId: Float
}

"""
A list of discounts to apply on items that has been captured and are in an invoice.
"""
input ItemDiscountInput {
  """List of discounts to apply."""
  discounts: [ItemDiscountLineInput!]!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!
}

"""List of discount items that are part of this request."""
input ItemDiscountLineInput {
  """
  Total amount of the discount. Includes tax discounts.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.
  """
  discountAmount: Int!

  """
  Merchant's own internal item number or any other reference that may help the
  merchant in identifying this purchase.
  """
  itemReference: String!

  """Id of the purchase"""
  purchaseId: bigint!
}

"""The result of adding the item discount."""
type ItemDiscountResult {
  """Ids of the discounts created."""
  captureItemDiscountIds: [Int!]!
}

input JsonbCastExp {
  String: StringComparisonExp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input JsonbComparisonExp {
  _cast: JsonbCastExp

  """is the column contained in the given json value"""
  _containedIn: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _hasKey: String

  """do all of these strings exist as top-level keys in the column"""
  _hasKeysAll: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""Supported languages"""
enum Language {
  CS
  DA
  DE
  EL
  EN
  ES
  ET
  FI
  FR
  HR
  HU
  IS
  IT
  LB
  LT
  LV
  MT
  NL
  NO
  PL
  PT
  RO
  SK
  SL
  SV
}

"""List of merchants registered with us."""
type Merchant {
  """

  Interval after which a purchase expires and can no more be captured.

  """
  captureExpiryWindow: interval!

  """

  Currency in which the purchase and other operations are done.
  Only currencies in ISO-4217 format are recognized.
  The currency needs to match the supported currencies for the merchant.
  Example: SEK, EUR.

  """
  currency: currency!
  id: bigint!
  name: String!

  """

  Interval after which a partially captured purchase expires after which it can no more be captured.

  """
  partialCaptureWindow: interval!
}

"""
Boolean expression to filter rows from the table "tenant.merchant". All fields are combined with a logical 'AND'.
"""
input MerchantBoolExp {
  _and: [MerchantBoolExp!]
  _not: MerchantBoolExp
  _or: [MerchantBoolExp!]
  captureExpiryWindow: IntervalComparisonExp
  currency: CurrencyComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  partialCaptureWindow: IntervalComparisonExp
}

enum MerchantMetricEnum {
  INSTALMENT_PURCHASES
  INVOICE_PURCHASES
  REFUNDS
  SUCCESSFUL_CREDIT_CARD_PAYMENTS
  SUCCESSFUL_DIRECT_DEBIT_PAYMENTS
  SUCCESSFUL_MOBILEPAY_PAYMENTS
  SUCCESSFUL_PAYMENTS
  SUCCESSFUL_SWISH_PAYMENTS
  SUCCESSFUL_VIPPS_PAYMENTS
}

"""
Boolean expression to compare columns of type "MerchantMetricEnum". All fields are combined with logical 'AND'.
"""
input MerchantMetricEnumComparisonExp {
  _eq: MerchantMetricEnum
  _in: [MerchantMetricEnum!]
  _isNull: Boolean
  _neq: MerchantMetricEnum
  _nin: [MerchantMetricEnum!]
}

"""Ordering options when selecting data from "tenant.merchant"."""
input MerchantOrderBy {
  captureExpiryWindow: OrderBy
  currency: OrderBy
  id: OrderBy
  name: OrderBy
  partialCaptureWindow: OrderBy
}

"""Describe the schema for mobilepay details."""
type MobilePayDetails {
  """Acquirer Name"""
  acquirer: String
  cardCountry: String
  cardExpiryDate: date

  """
  Reepay credit card fingerprint that uniquely identifies this particular card number
  """
  cardFingerprint: String
  cardNumber: String
  cardType: String
  threeDSecureStatus: Boolean
}

"""
order by aggregate values of table "runtime.transaction_mobilepay_details"
"""
input MobilePayDetailsAggregateOrderBy {
  count: OrderBy
  max: MobilePayDetailsMaxOrderBy
  min: MobilePayDetailsMinOrderBy
}

"""
Boolean expression to filter rows from the table "runtime.transaction_mobilepay_details". All fields are combined with a logical 'AND'.
"""
input MobilePayDetailsBoolExp {
  _and: [MobilePayDetailsBoolExp!]
  _not: MobilePayDetailsBoolExp
  _or: [MobilePayDetailsBoolExp!]
  acquirer: StringComparisonExp
  cardCountry: StringComparisonExp
  cardExpiryDate: DateComparisonExp
  cardFingerprint: StringComparisonExp
  cardNumber: StringComparisonExp
  cardType: StringComparisonExp
  threeDSecureStatus: BooleanComparisonExp
}

"""
order by max() on columns of table "runtime.transaction_mobilepay_details"
"""
input MobilePayDetailsMaxOrderBy {
  """Acquirer Name"""
  acquirer: OrderBy
  cardCountry: OrderBy
  cardExpiryDate: OrderBy

  """
  Reepay credit card fingerprint that uniquely identifies this particular card number
  """
  cardFingerprint: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
}

"""
order by min() on columns of table "runtime.transaction_mobilepay_details"
"""
input MobilePayDetailsMinOrderBy {
  """Acquirer Name"""
  acquirer: OrderBy
  cardCountry: OrderBy
  cardExpiryDate: OrderBy

  """
  Reepay credit card fingerprint that uniquely identifies this particular card number
  """
  cardFingerprint: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
}

"""
Ordering options when selecting data from "runtime.transaction_mobilepay_details".
"""
input MobilePayDetailsOrderBy {
  acquirer: OrderBy
  cardCountry: OrderBy
  cardExpiryDate: OrderBy
  cardFingerprint: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
  threeDSecureStatus: OrderBy
}

"""
select columns of table "runtime.transaction_mobilepay_details"
"""
enum MobilePayDetailsSelectColumn {
  """column name"""
  acquirer

  """column name"""
  cardCountry

  """column name"""
  cardExpiryDate

  """column name"""
  cardFingerprint

  """column name"""
  cardNumber

  """column name"""
  cardType

  """column name"""
  threeDSecureStatus
}

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input NumericComparisonExp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _isNull: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC

  """in ascending order, nulls first"""
  ASC_NULLS_FIRST

  """in ascending order, nulls last"""
  ASC_NULLS_LAST

  """in descending order, nulls first"""
  DESC

  """in descending order, nulls first"""
  DESC_NULLS_FIRST

  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

enum OrderStatusEnum {
  """The order was cancelled by the merchant"""
  CANCELLED

  """The order has been fully captured by the merchant"""
  CAPTURE_DONE

  """The customer needs to setup recurring payments"""
  INSTALMENTS_AUTHORIZE

  """The customer needs to pay the first instalment"""
  INSTALMENT_PRE_PAYMENT

  """The order has been captured partially by the merchant"""
  PARTIALLY_CAPTURED

  """Validating the order and the customer"""
  PRE_FLIGHT_SCORING

  """The order was rejected because of its risk profile"""
  REJECTED

  """Assessing the customer"""
  RISK_SCORING

  """Strong Customer Authentication is needed before completing the order"""
  SCA_REQUIRED

  """The order has been processed as is waiting for capture"""
  WAITING_FOR_CAPTURE
}

"""
Boolean expression to compare columns of type "OrderStatusEnum". All fields are combined with logical 'AND'.
"""
input OrderStatusEnumComparisonExp {
  _eq: OrderStatusEnum
  _in: [OrderStatusEnum!]
  _isNull: Boolean
  _neq: OrderStatusEnum
  _nin: [OrderStatusEnum!]
}

"""
Boolean expression to compare columns of type "packed_phone_number". All fields are combined with logical 'AND'.
"""
input PackedPhoneNumberComparisonExp {
  _eq: packed_phone_number
  _gt: packed_phone_number
  _gte: packed_phone_number
  _in: [packed_phone_number!]
  _isNull: Boolean
  _lt: packed_phone_number
  _lte: packed_phone_number
  _neq: packed_phone_number
  _nin: [packed_phone_number!]
}

"""Arguments for paying an instalment"""
input PayInstalmentInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  The purchaseId is the purchase for which the customer
  is paying the instalment.

  Max length: 64.
  """
  purchaseId: bigint!
}

"""The result of initiating a payment for an instalment."""
type PayInstalmentResult {
  """
  Once a payment is initialized, we will return a bearer token.
  You can use this token to start the payment flow either with
  swish or finshark.
  """
  token: String!
}

"""Arguments for onboarding a new PayPal merchant"""
input PayPalMerchantOnboardingInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """The url to return to after the merchant is onboarded."""
  returnUrl: String!
}

"""The result of starting the PayPal onboarding process."""
type PayPalMerchantOnboardingResult {
  """The result of starting the PayPal onboarding process."""
  trackingId: String!
}

"""Data pertaining to merchant onboarding via PayPal"""
type PayPalOnboardingStatus {
  country: country
  currency: String
  errorMessage: String

  """
  Unique tracking ID we send to PayPal to track Partner onboarding status
  """
  id: uuid!

  """
  Whether the onboarded merchant is active to receive payments according to PayPal
  """
  isActive: Boolean!

  """
  Partner action URL returned by PayPal to be used for partner onboarding
  """
  partnerActionUrl: String
  returnUrl: String!
  sellerPaypalEmail: String

  """
  Merchant ID of merchant partner according to PayPal's systems. This is the merchant signing up on our platform
  """
  sellerPaypalMerchantId: String
}

"""
Boolean expression to filter rows from the table "tenant.paypal_onboarding". All fields are combined with a logical 'AND'.
"""
input PayPalOnboardingStatusBoolExp {
  _and: [PayPalOnboardingStatusBoolExp!]
  _not: PayPalOnboardingStatusBoolExp
  _or: [PayPalOnboardingStatusBoolExp!]
  country: CountryComparisonExp
  currency: StringComparisonExp
  errorMessage: StringComparisonExp
  id: UuidComparisonExp
  isActive: BooleanComparisonExp
  partnerActionUrl: StringComparisonExp
  returnUrl: StringComparisonExp
  sellerPaypalEmail: StringComparisonExp
  sellerPaypalMerchantId: StringComparisonExp
}

"""Ordering options when selecting data from "tenant.paypal_onboarding"."""
input PayPalOnboardingStatusOrderBy {
  country: OrderBy
  currency: OrderBy
  errorMessage: OrderBy
  id: OrderBy
  isActive: OrderBy
  partnerActionUrl: OrderBy
  returnUrl: OrderBy
  sellerPaypalEmail: OrderBy
  sellerPaypalMerchantId: OrderBy
}

"""
select columns of table "tenant.paypal_onboarding"
"""
enum PayPalOnboardingStatusSelectColumn {
  """column name"""
  country

  """column name"""
  currency

  """column name"""
  errorMessage

  """column name"""
  id

  """column name"""
  isActive

  """column name"""
  partnerActionUrl

  """column name"""
  returnUrl

  """column name"""
  sellerPaypalEmail

  """column name"""
  sellerPaypalMerchantId
}

"""
Streaming cursor of the table "PayPalOnboardingStatus"
"""
input PayPalOnboardingStatusStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PayPalOnboardingStatusStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PayPalOnboardingStatusStreamCursorValueInput {
  country: country
  currency: String
  errorMessage: String

  """
  Unique tracking ID we send to PayPal to track Partner onboarding status
  """
  id: uuid

  """
  Whether the onboarded merchant is active to receive payments according to PayPal
  """
  isActive: Boolean

  """
  Partner action URL returned by PayPal to be used for partner onboarding
  """
  partnerActionUrl: String
  returnUrl: String
  sellerPaypalEmail: String

  """
  Merchant ID of merchant partner according to PayPal's systems. This is the merchant signing up on our platform
  """
  sellerPaypalMerchantId: String
}

"""Arguments for creating a new PayPal payment"""
input PayPalPaymentInput {
  """
  The amount the customer pays in minor units.
  So 100,56 kr would be 10056
  """
  amount: Int!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  Merchant's own internal reference that may help the
  merchant in identifying this payment. These have to
  be globally unique but they should be reused for retrying
  a payment.

  Max length: 64.
  """
  merchantReference: String!

  """
  A message to show to the customer on their bank statement.
  It could be an order id or a reference.

  Max length: 50.
  """
  message: String!

  """Payment category that determines the payment flow"""
  paymentCategory: PaymentCategory!

  """
  Our system's own internal reference that can be used uniquely
  in identifying this payment.
  """
  paymentReference: String!

  """The url to return to after the payment is done."""
  returnUrl: String!
}

"""The result of initiating a PayPal payment."""
type PayPalPaymentResult {
  """
  Once a payment is initialized, we will start the PayPal payment
  workflow. You can use this id to query the current status of the
  payment.
  """
  paymentId: String!
}

"""Record of payment made to a merchant that we processed."""
type Payment {
  amountAuthorized: bigint

  """Amount paid by the customer to the merchant."""
  amountPaid: bigint!

  """An array relationship"""
  captures(
    """distinct select on columns"""
    distinctOn: [PaymentCaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCaptureOrderBy!]

    """filter the rows returned"""
    where: PaymentCaptureBoolExp
  ): [PaymentCapture!]!

  """An aggregate relationship"""
  capturesAggregate(
    """distinct select on columns"""
    distinctOn: [PaymentCaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCaptureOrderBy!]

    """filter the rows returned"""
    where: PaymentCaptureBoolExp
  ): PaymentCaptureAggregate!
  createdAt: timestamptz!
  currency: SupportedCurrencyEnum!

  """An object relationship"""
  customer: CustomerPaymentData
  id: bigint!

  """An object relationship"""
  merchant: Merchant!

  """Reference use by the merchant when creating the payment"""
  merchantReference: String!
  paymentMethod: PaymentMethodEnum!
  paymentRefundStatus: PaymentRefundStatusEnum

  """An object relationship"""
  payment_method_used: PaymentMethodStatus

  """An array relationship"""
  refunds(
    """distinct select on columns"""
    distinctOn: [RefundSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RefundOrderBy!]

    """filter the rows returned"""
    where: RefundBoolExp
  ): [Refund!]!

  """An aggregate relationship"""
  refundsAggregate(
    """distinct select on columns"""
    distinctOn: [RefundSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RefundOrderBy!]

    """filter the rows returned"""
    where: RefundBoolExp
  ): RefundAggregate!

  """
  A computed field, executes function "payment_gateway.get_transaction_credit_card_details"
  """
  transactionCreditCardDetails(
    """distinct select on columns"""
    distinctOn: [CreditCardDetailsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CreditCardDetailsOrderBy!]

    """filter the rows returned"""
    where: CreditCardDetailsBoolExp
  ): [CreditCardDetails!]

  """
  This id uniquely identifies the transaction in kronor among other types of transactions
  """
  transactionId: String!

  """
  A computed field, executes function "payment_gateway.get_transaction_mobilepay_details"
  """
  transactionMobilePayDetails(
    """distinct select on columns"""
    distinctOn: [MobilePayDetailsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MobilePayDetailsOrderBy!]

    """filter the rows returned"""
    where: MobilePayDetailsBoolExp
  ): [MobilePayDetails!]

  """Get the list of transaction releases"""
  transactionReleases(
    """distinct select on columns"""
    distinctOn: [TransactionReleaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TransactionReleaseOrderBy!]

    """filter the rows returned"""
    where: TransactionReleaseBoolExp
  ): [TransactionRelease!]!

  """Run aggregations on the list of transaction releases"""
  transactionReleasesAggregate(
    """distinct select on columns"""
    distinctOn: [TransactionReleaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TransactionReleaseOrderBy!]

    """filter the rows returned"""
    where: TransactionReleaseBoolExp
  ): TransactionReleaseAggregate!

  """
  A computed field, executes function "payment_gateway.get_transaction_swish_details"
  """
  transactionSwishDetails(
    """distinct select on columns"""
    distinctOn: [SwishDetailsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SwishDetailsOrderBy!]

    """filter the rows returned"""
    where: SwishDetailsBoolExp
  ): [SwishDetails!]

  """
  A computed field, executes function "payment_gateway.get_transaction_vipps_details"
  """
  transactionVippsDetails(
    """distinct select on columns"""
    distinctOn: [VippsDetailsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [VippsDetailsOrderBy!]

    """filter the rows returned"""
    where: VippsDetailsBoolExp
  ): [VippsDetails!]
}

"""
aggregated selection of "payment_gateway.payment"
"""
type PaymentAggregate {
  aggregate: PaymentAggregateFields
  nodes: [Payment!]!
}

"""
aggregate fields of "payment_gateway.payment"
"""
type PaymentAggregateFields {
  avg: PaymentAvgFields
  count(columns: [PaymentSelectColumn!], distinct: Boolean): Int!
  max: PaymentMaxFields
  min: PaymentMinFields
  stddev: PaymentStddevFields
  stddevPop: PaymentStddevPopFields
  stddevSamp: PaymentStddevSampFields
  sum: PaymentSumFields
  varPop: PaymentVarPopFields
  varSamp: PaymentVarSampFields
  variance: PaymentVarianceFields
}

"""aggregate avg on columns"""
type PaymentAvgFields {
  amountAuthorized: Float

  """Amount paid by the customer to the merchant."""
  amountPaid: Float
  id: Float
}

"""
Boolean expression to filter rows from the table "payment_gateway.payment". All fields are combined with a logical 'AND'.
"""
input PaymentBoolExp {
  _and: [PaymentBoolExp!]
  _not: PaymentBoolExp
  _or: [PaymentBoolExp!]
  amountAuthorized: BigintComparisonExp
  amountPaid: BigintComparisonExp
  captures: PaymentCaptureBoolExp
  capturesAggregate: PaymentCaptureAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  currency: SupportedCurrencyEnumComparisonExp
  customer: CustomerPaymentDataBoolExp
  id: BigintComparisonExp
  merchant: MerchantBoolExp
  merchantReference: StringComparisonExp
  paymentMethod: PaymentMethodEnumComparisonExp
  paymentRefundStatus: PaymentRefundStatusEnumComparisonExp
  payment_method_used: PaymentMethodStatusBoolExp
  refunds: RefundBoolExp
  refundsAggregate: RefundAggregateBoolExp
  transactionCreditCardDetails: CreditCardDetailsBoolExp
  transactionId: StringComparisonExp
  transactionMobilePayDetails: MobilePayDetailsBoolExp
  transactionReleases: TransactionReleaseBoolExp
  transactionReleasesAggregate: TransactionReleaseAggregateBoolExp
  transactionSwishDetails: SwishDetailsBoolExp
  transactionVippsDetails: VippsDetailsBoolExp
}

"""URL containing a downloadable CSV with payment data"""
type PaymentCSV {
  createdAt: timestamptz!

  """

  End date till which the csv is generated.

  """
  endDate: date!

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String
  expiresAt: timestamptz

  """This is the key that we send to query for the links."""
  id: bigint!

  """
  The Amazon S3 presigned URL shared with merchant for them to download the csv.
  """
  link: String

  """

  Start date from which the csv is generated.

  """
  startDate: date!

  """The status of creating the presigned URL."""
  status: ReportLinkStatusEnum!
}

"""
aggregated selection of "merchant_portal.generated_payments_csv"
"""
type PaymentCSVAggregate {
  aggregate: PaymentCSVAggregateFields
  nodes: [PaymentCSV!]!
}

"""
aggregate fields of "merchant_portal.generated_payments_csv"
"""
type PaymentCSVAggregateFields {
  avg: PaymentCSVAvgFields
  count(columns: [PaymentCSVSelectColumn!], distinct: Boolean): Int!
  max: PaymentCSVMaxFields
  min: PaymentCSVMinFields
  stddev: PaymentCSVStddevFields
  stddevPop: PaymentCSVStddevPopFields
  stddevSamp: PaymentCSVStddevSampFields
  sum: PaymentCSVSumFields
  varPop: PaymentCSVVarPopFields
  varSamp: PaymentCSVVarSampFields
  variance: PaymentCSVVarianceFields
}

"""aggregate avg on columns"""
type PaymentCSVAvgFields {
  """This is the key that we send to query for the links."""
  id: Float
}

"""
Boolean expression to filter rows from the table "merchant_portal.generated_payments_csv". All fields are combined with a logical 'AND'.
"""
input PaymentCSVBoolExp {
  _and: [PaymentCSVBoolExp!]
  _not: PaymentCSVBoolExp
  _or: [PaymentCSVBoolExp!]
  createdAt: TimestamptzComparisonExp
  endDate: DateComparisonExp
  errMessage: StringComparisonExp
  expiresAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  link: StringComparisonExp
  startDate: DateComparisonExp
  status: ReportLinkStatusEnumComparisonExp
}

"""aggregate max on columns"""
type PaymentCSVMaxFields {
  createdAt: timestamptz

  """

  End date till which the csv is generated.

  """
  endDate: date

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String
  expiresAt: timestamptz

  """This is the key that we send to query for the links."""
  id: bigint

  """
  The Amazon S3 presigned URL shared with merchant for them to download the csv.
  """
  link: String

  """

  Start date from which the csv is generated.

  """
  startDate: date
}

"""aggregate min on columns"""
type PaymentCSVMinFields {
  createdAt: timestamptz

  """

  End date till which the csv is generated.

  """
  endDate: date

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String
  expiresAt: timestamptz

  """This is the key that we send to query for the links."""
  id: bigint

  """
  The Amazon S3 presigned URL shared with merchant for them to download the csv.
  """
  link: String

  """

  Start date from which the csv is generated.

  """
  startDate: date
}

"""
Ordering options when selecting data from "merchant_portal.generated_payments_csv".
"""
input PaymentCSVOrderBy {
  createdAt: OrderBy
  endDate: OrderBy
  errMessage: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  link: OrderBy
  startDate: OrderBy
  status: OrderBy
}

"""
select columns of table "merchant_portal.generated_payments_csv"
"""
enum PaymentCSVSelectColumn {
  """column name"""
  createdAt

  """column name"""
  endDate

  """column name"""
  errMessage

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  link

  """column name"""
  startDate

  """column name"""
  status
}

"""aggregate stddev on columns"""
type PaymentCSVStddevFields {
  """This is the key that we send to query for the links."""
  id: Float
}

"""aggregate stddevPop on columns"""
type PaymentCSVStddevPopFields {
  """This is the key that we send to query for the links."""
  id: Float
}

"""aggregate stddevSamp on columns"""
type PaymentCSVStddevSampFields {
  """This is the key that we send to query for the links."""
  id: Float
}

"""
Streaming cursor of the table "PaymentCSV"
"""
input PaymentCSVStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PaymentCSVStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PaymentCSVStreamCursorValueInput {
  createdAt: timestamptz

  """

  End date till which the csv is generated.

  """
  endDate: date

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String
  expiresAt: timestamptz

  """This is the key that we send to query for the links."""
  id: bigint

  """
  The Amazon S3 presigned URL shared with merchant for them to download the csv.
  """
  link: String

  """

  Start date from which the csv is generated.

  """
  startDate: date

  """The status of creating the presigned URL."""
  status: ReportLinkStatusEnum
}

"""aggregate sum on columns"""
type PaymentCSVSumFields {
  """This is the key that we send to query for the links."""
  id: bigint
}

"""aggregate varPop on columns"""
type PaymentCSVVarPopFields {
  """This is the key that we send to query for the links."""
  id: Float
}

"""aggregate varSamp on columns"""
type PaymentCSVVarSampFields {
  """This is the key that we send to query for the links."""
  id: Float
}

"""aggregate variance on columns"""
type PaymentCSVVarianceFields {
  """This is the key that we send to query for the links."""
  id: Float
}

"""Arguments for cancelling payment"""
input PaymentCancelInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """The payment reference to cancel."""
  paymentReference: String!
}

"""The result of cancelling a payment request."""
type PaymentCancelResult {
  """
  The returned token can be used to query whether the payment has
  been cancelled or not.
  """
  waitToken: String
}

"""Table to store payment captures."""
type PaymentCapture {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: bigint!
  createdAt: timestamptz!
  id: bigint!

  """Message for this capture."""
  message: String

  """An object relationship"""
  payment: Payment

  """Payment to which this capture belongs to."""
  paymentId: bigint!

  """List of statuses the capture is currently on"""
  status(
    """distinct select on columns"""
    distinctOn: [CurrentCaptureStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentCaptureStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentCaptureStatusBoolExp
  ): [CurrentCaptureStatus!]

  """List of statuses the capture has been on"""
  statusHistory(
    """distinct select on columns"""
    distinctOn: [CurrentCaptureStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentCaptureStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentCaptureStatusBoolExp
  ): [CurrentCaptureStatus!]

  """
  This id uniquely identifies the transaction in kronor among other types of transactions
  """
  transactionId: String!
}

"""
aggregated selection of "payment_gateway.payment_capture"
"""
type PaymentCaptureAggregate {
  aggregate: PaymentCaptureAggregateFields
  nodes: [PaymentCapture!]!
}

input PaymentCaptureAggregateBoolExp {
  count: PaymentCaptureAggregateBoolExpCount
}

input PaymentCaptureAggregateBoolExpCount {
  arguments: [PaymentCaptureSelectColumn!]
  distinct: Boolean
  filter: PaymentCaptureBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "payment_gateway.payment_capture"
"""
type PaymentCaptureAggregateFields {
  avg: PaymentCaptureAvgFields
  count(columns: [PaymentCaptureSelectColumn!], distinct: Boolean): Int!
  max: PaymentCaptureMaxFields
  min: PaymentCaptureMinFields
  stddev: PaymentCaptureStddevFields
  stddevPop: PaymentCaptureStddevPopFields
  stddevSamp: PaymentCaptureStddevSampFields
  sum: PaymentCaptureSumFields
  varPop: PaymentCaptureVarPopFields
  varSamp: PaymentCaptureVarSampFields
  variance: PaymentCaptureVarianceFields
}

"""
order by aggregate values of table "payment_gateway.payment_capture"
"""
input PaymentCaptureAggregateOrderBy {
  avg: PaymentCaptureAvgOrderBy
  count: OrderBy
  max: PaymentCaptureMaxOrderBy
  min: PaymentCaptureMinOrderBy
  stddev: PaymentCaptureStddevOrderBy
  stddevPop: PaymentCaptureStddevPopOrderBy
  stddevSamp: PaymentCaptureStddevSampOrderBy
  sum: PaymentCaptureSumOrderBy
  varPop: PaymentCaptureVarPopOrderBy
  varSamp: PaymentCaptureVarSampOrderBy
  variance: PaymentCaptureVarianceOrderBy
}

"""Arguments for fully capturing a payment."""
input PaymentCaptureAllInput {
  """
  The amount to capture in minor units.
  So 100,56 kr would be 10056.
  Amount should be in between 0 and authorized amount.
  If omited, a capture would be created for the amount required to capture all that was authorized.
  If lower than authorized amount - amount paid, a refund will be created if the capture is successful.
  """
  amount: Int

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  A message to be displayed on the portal associated with this capture.
  Message will appear in the customer's account statement.

  Max length: 50.
  """
  message: String

  """Id of the payment to capture."""
  paymentId: bigint!

  """
  A message to be displayed to the customer in case a refund is made
  when returning excess amount. This message will appear in the customer's account statement if any refund is made.

  Max length: 50.
  """
  refundMessage: String
}

"""aggregate avg on columns"""
type PaymentCaptureAvgFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: Float
  id: Float

  """Payment to which this capture belongs to."""
  paymentId: Float
}

"""
order by avg() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureAvgOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""
Boolean expression to filter rows from the table "payment_gateway.payment_capture". All fields are combined with a logical 'AND'.
"""
input PaymentCaptureBoolExp {
  _and: [PaymentCaptureBoolExp!]
  _not: PaymentCaptureBoolExp
  _or: [PaymentCaptureBoolExp!]
  amount: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  message: StringComparisonExp
  payment: PaymentBoolExp
  paymentId: BigintComparisonExp
  status: CurrentCaptureStatusBoolExp
  statusHistory: CurrentCaptureStatusBoolExp
  transactionId: StringComparisonExp
}

"""Arguments for partially capturing a payment."""
input PaymentCaptureInput {
  """
  The amount to capture in minor units.
  So 100,56 kr would be 10056.
  Amount should be in between 0 and authorized amount.
  """
  amount: Int!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  A message to be displayed on the portal associated with this capture.
  Message will appear in the customer's account statement.

  Max length: 50.
  """
  message: String

  """Id of the payment to capture."""
  paymentId: bigint!
}

"""aggregate max on columns"""
type PaymentCaptureMaxFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: bigint
  createdAt: timestamptz
  id: bigint

  """Message for this capture."""
  message: String

  """Payment to which this capture belongs to."""
  paymentId: bigint

  """
  This id uniquely identifies the transaction in kronor among other types of transactions
  """
  transactionId: String
}

"""
order by max() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureMaxOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  createdAt: OrderBy
  id: OrderBy

  """Message for this capture."""
  message: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy

  """
  This id uniquely identifies the transaction in kronor among other types of transactions
  """
  transactionId: OrderBy
}

"""aggregate min on columns"""
type PaymentCaptureMinFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: bigint
  createdAt: timestamptz
  id: bigint

  """Message for this capture."""
  message: String

  """Payment to which this capture belongs to."""
  paymentId: bigint

  """
  This id uniquely identifies the transaction in kronor among other types of transactions
  """
  transactionId: String
}

"""
order by min() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureMinOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  createdAt: OrderBy
  id: OrderBy

  """Message for this capture."""
  message: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy

  """
  This id uniquely identifies the transaction in kronor among other types of transactions
  """
  transactionId: OrderBy
}

"""
Ordering options when selecting data from "payment_gateway.payment_capture".
"""
input PaymentCaptureOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  id: OrderBy
  message: OrderBy
  payment: PaymentOrderBy
  paymentId: OrderBy
  statusAggregate: CurrentCaptureStatusAggregateOrderBy
  statusHistoryAggregate: CurrentCaptureStatusAggregateOrderBy
  transactionId: OrderBy
}

"""The result of capturing a payment."""
type PaymentCaptureResult {
  """
  Once a payment is captured. We will start processing the capture.
  You can use this token to query the created capture.
  """
  captureId: bigint!
}

"""
select columns of table "payment_gateway.payment_capture"
"""
enum PaymentCaptureSelectColumn {
  """column name"""
  amount

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  message

  """column name"""
  paymentId

  """column name"""
  transactionId
}

enum PaymentCaptureStatusEnum {
  CAPTURE_COOLDOWN
  CAPTURE_DECLINED
  CAPTURE_DONE
  CAPTURING
  ERROR
  WAITING_FOR_CAPTURE
}

"""
Boolean expression to compare columns of type "PaymentCaptureStatusEnum". All fields are combined with logical 'AND'.
"""
input PaymentCaptureStatusEnumComparisonExp {
  _eq: PaymentCaptureStatusEnum
  _in: [PaymentCaptureStatusEnum!]
  _isNull: Boolean
  _neq: PaymentCaptureStatusEnum
  _nin: [PaymentCaptureStatusEnum!]
}

"""aggregate stddev on columns"""
type PaymentCaptureStddevFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: Float
  id: Float

  """Payment to which this capture belongs to."""
  paymentId: Float
}

"""
order by stddev() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureStddevOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""aggregate stddevPop on columns"""
type PaymentCaptureStddevPopFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: Float
  id: Float

  """Payment to which this capture belongs to."""
  paymentId: Float
}

"""
order by stddevPop() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureStddevPopOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""aggregate stddevSamp on columns"""
type PaymentCaptureStddevSampFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: Float
  id: Float

  """Payment to which this capture belongs to."""
  paymentId: Float
}

"""
order by stddevSamp() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureStddevSampOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""
Streaming cursor of the table "PaymentCapture"
"""
input PaymentCaptureStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PaymentCaptureStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PaymentCaptureStreamCursorValueInput {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: bigint
  createdAt: timestamptz
  id: bigint

  """Message for this capture."""
  message: String

  """Payment to which this capture belongs to."""
  paymentId: bigint

  """
  This id uniquely identifies the transaction in kronor among other types of transactions
  """
  transactionId: String
}

"""aggregate sum on columns"""
type PaymentCaptureSumFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: bigint
  id: bigint

  """Payment to which this capture belongs to."""
  paymentId: bigint
}

"""
order by sum() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureSumOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""aggregate varPop on columns"""
type PaymentCaptureVarPopFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: Float
  id: Float

  """Payment to which this capture belongs to."""
  paymentId: Float
}

"""
order by varPop() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureVarPopOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""aggregate varSamp on columns"""
type PaymentCaptureVarSampFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: Float
  id: Float

  """Payment to which this capture belongs to."""
  paymentId: Float
}

"""
order by varSamp() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureVarSampOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""aggregate variance on columns"""
type PaymentCaptureVarianceFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: Float
  id: Float

  """Payment to which this capture belongs to."""
  paymentId: Float
}

"""
order by variance() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureVarianceOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""Payment Category that determines the payment flow"""
enum PaymentCategory {
  Account
  Instalment
  Invoice
  StandAlone
}

"""aggregate max on columns"""
type PaymentMaxFields {
  amountAuthorized: bigint

  """Amount paid by the customer to the merchant."""
  amountPaid: bigint
  createdAt: timestamptz
  id: bigint

  """Reference use by the merchant when creating the payment"""
  merchantReference: String

  """
  This id uniquely identifies the transaction in kronor among other types of transactions
  """
  transactionId: String
}

enum PaymentMethodEnum {
  """Credit or Debit cards"""
  CREDIT_CARD

  """Open Banking direct debit via Finshark"""
  FINSHARK_DIRECT_DEBIT

  """Open Banking recurring debit via Finshark"""
  FINSHARK_RECURRING_DEBIT

  """Pay with MobilePay Online"""
  MOBILEPAY

  """Pay with PayPal"""
  PAYPAL

  """Swish"""
  SWISH

  """Pay with Vipps"""
  VIPPS
}

"""
Boolean expression to compare columns of type "PaymentMethodEnum". All fields are combined with logical 'AND'.
"""
input PaymentMethodEnumComparisonExp {
  _eq: PaymentMethodEnum
  _in: [PaymentMethodEnum!]
  _isNull: Boolean
  _neq: PaymentMethodEnum
  _nin: [PaymentMethodEnum!]
}

"""Payment methods available for a merchant."""
type PaymentMethodStatus {
  country: country!
  currency: currency!
  enabled: Boolean
  gateway: String!
  gatewayPaymentMethod: String

  """The payment method supported / available for this merchant.."""
  paymentMethod: PaymentMethodEnum!
}

"""
Boolean expression to filter rows from the table "tenant.payment_method_available". All fields are combined with a logical 'AND'.
"""
input PaymentMethodStatusBoolExp {
  _and: [PaymentMethodStatusBoolExp!]
  _not: PaymentMethodStatusBoolExp
  _or: [PaymentMethodStatusBoolExp!]
  country: CountryComparisonExp
  currency: CurrencyComparisonExp
  enabled: BooleanComparisonExp
  gateway: StringComparisonExp
  gatewayPaymentMethod: StringComparisonExp
  paymentMethod: PaymentMethodEnumComparisonExp
}

"""
Ordering options when selecting data from "tenant.payment_method_available".
"""
input PaymentMethodStatusOrderBy {
  country: OrderBy
  currency: OrderBy
  enabled: OrderBy
  gateway: OrderBy
  gatewayPaymentMethod: OrderBy
  paymentMethod: OrderBy
}

"""
select columns of table "tenant.payment_method_available"
"""
enum PaymentMethodStatusSelectColumn {
  """column name"""
  country

  """column name"""
  currency

  """column name"""
  enabled

  """column name"""
  gateway

  """column name"""
  gatewayPaymentMethod

  """column name"""
  paymentMethod
}

"""
Streaming cursor of the table "PaymentMethodStatus"
"""
input PaymentMethodStatusStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PaymentMethodStatusStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PaymentMethodStatusStreamCursorValueInput {
  country: country
  currency: currency
  enabled: Boolean
  gateway: String
  gatewayPaymentMethod: String

  """The payment method supported / available for this merchant.."""
  paymentMethod: PaymentMethodEnum
}

"""aggregate min on columns"""
type PaymentMinFields {
  amountAuthorized: bigint

  """Amount paid by the customer to the merchant."""
  amountPaid: bigint
  createdAt: timestamptz
  id: bigint

  """Reference use by the merchant when creating the payment"""
  merchantReference: String

  """
  This id uniquely identifies the transaction in kronor among other types of transactions
  """
  transactionId: String
}

"""Ordering options when selecting data from "payment_gateway.payment"."""
input PaymentOrderBy {
  amountAuthorized: OrderBy
  amountPaid: OrderBy
  capturesAggregate: PaymentCaptureAggregateOrderBy
  createdAt: OrderBy
  currency: OrderBy
  customer: CustomerPaymentDataOrderBy
  id: OrderBy
  merchant: MerchantOrderBy
  merchantReference: OrderBy
  paymentMethod: OrderBy
  paymentRefundStatus: OrderBy
  payment_method_used: PaymentMethodStatusOrderBy
  refundsAggregate: RefundAggregateOrderBy
  transactionCreditCardDetailsAggregate: CreditCardDetailsAggregateOrderBy
  transactionId: OrderBy
  transactionMobilePayDetailsAggregate: MobilePayDetailsAggregateOrderBy
  transactionReleasesAggregate: TransactionReleaseAggregateOrderBy
  transactionSwishDetailsAggregate: SwishDetailsAggregateOrderBy
  transactionVippsDetailsAggregate: VippsDetailsAggregateOrderBy
}

enum PaymentRefundStatusEnum {
  """The payment is fully refunded"""
  FULLY_REFUNDED

  """The payment has no refunds"""
  NO_REFUND

  """The payment is partially refunded"""
  PARTIALLY_REFUNDED
}

"""
Boolean expression to compare columns of type "PaymentRefundStatusEnum". All fields are combined with logical 'AND'.
"""
input PaymentRefundStatusEnumComparisonExp {
  _eq: PaymentRefundStatusEnum
  _in: [PaymentRefundStatusEnum!]
  _isNull: Boolean
  _neq: PaymentRefundStatusEnum
  _nin: [PaymentRefundStatusEnum!]
}

"""A payment requested"""
type PaymentRequest {
  amount: bigint!
  createdAt: timestamptz!
  currency: SupportedCurrencyEnum!

  """An object relationship"""
  customer: CustomerPaymentData

  """Additional information specific to the payment"""
  detail(
    """distinct select on columns"""
    distinctOn: [CurrentPaymentDetailSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentPaymentDetailOrderBy!]

    """filter the rows returned"""
    where: CurrentPaymentDetailBoolExp
  ): [CurrentPaymentDetail!]

  """Gives the latest status that the payment is on."""
  latestStatus(
    """distinct select on columns"""
    distinctOn: [CurrentPaymentStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentPaymentStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentPaymentStatusBoolExp
  ): [CurrentPaymentStatus!]

  """An object relationship"""
  merchant: Merchant!
  message: String!

  """An object relationship"""
  payment: Payment
  paymentFlow: String
  paymentProvider: PaymentMethodEnum

  """An object relationship"""
  payment_method_used: PaymentMethodStatus

  """

  Payments are linked to a reference, this can be a purchase id or
  any reference the merchant sends when making a stand alone payment.

  """
  reference: String!

  """Id of the generated gateway payment (stand alone payments only)."""
  resultingPaymentId: bigint

  """List of statuses the payment is currently on"""
  status(
    """distinct select on columns"""
    distinctOn: [CurrentPaymentStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentPaymentStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentPaymentStatusBoolExp
  ): [CurrentPaymentStatus!]

  """List of statuses the payment has been on"""
  statusHistory(
    """distinct select on columns"""
    distinctOn: [CurrentPaymentStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentPaymentStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentPaymentStatusBoolExp
  ): [CurrentPaymentStatus!]

  """
  A computed field, executes function "runtime.get_transaction_credit_card_details"
  """
  transactionCreditCardDetails(
    """distinct select on columns"""
    distinctOn: [CreditCardDetailsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CreditCardDetailsOrderBy!]

    """filter the rows returned"""
    where: CreditCardDetailsBoolExp
  ): [CreditCardDetails!]

  """
  A computed field, executes function "runtime.get_transaction_finshark_details"
  """
  transactionFinsharkDetails(
    """distinct select on columns"""
    distinctOn: [FinsharkDetailsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [FinsharkDetailsOrderBy!]

    """filter the rows returned"""
    where: FinsharkDetailsBoolExp
  ): [FinsharkDetails!]

  """
  This id uniquely identifies the transaction in kronor among other types of transactions
  """
  transactionId: String!

  """
  A computed field, executes function "runtime.get_transaction_mobilepay_details"
  """
  transactionMobilePayDetails(
    """distinct select on columns"""
    distinctOn: [MobilePayDetailsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MobilePayDetailsOrderBy!]

    """filter the rows returned"""
    where: MobilePayDetailsBoolExp
  ): [MobilePayDetails!]

  """
  A computed field, executes function "runtime.get_transaction_swish_details"
  """
  transactionSwishDetails(
    """distinct select on columns"""
    distinctOn: [SwishDetailsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SwishDetailsOrderBy!]

    """filter the rows returned"""
    where: SwishDetailsBoolExp
  ): [SwishDetails!]

  """
  A computed field, executes function "runtime.get_transaction_vipps_details"
  """
  transactionVippsDetails(
    """distinct select on columns"""
    distinctOn: [VippsDetailsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [VippsDetailsOrderBy!]

    """filter the rows returned"""
    where: VippsDetailsBoolExp
  ): [VippsDetails!]
  waitToken: uuid!
}

"""
Boolean expression to filter rows from the table "runtime.payment". All fields are combined with a logical 'AND'.
"""
input PaymentRequestBoolExp {
  _and: [PaymentRequestBoolExp!]
  _not: PaymentRequestBoolExp
  _or: [PaymentRequestBoolExp!]
  amount: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  currency: SupportedCurrencyEnumComparisonExp
  customer: CustomerPaymentDataBoolExp
  detail: CurrentPaymentDetailBoolExp
  latestStatus: CurrentPaymentStatusBoolExp
  merchant: MerchantBoolExp
  message: StringComparisonExp
  payment: PaymentBoolExp
  paymentFlow: StringComparisonExp
  paymentProvider: PaymentMethodEnumComparisonExp
  payment_method_used: PaymentMethodStatusBoolExp
  reference: StringComparisonExp
  resultingPaymentId: BigintComparisonExp
  status: CurrentPaymentStatusBoolExp
  statusHistory: CurrentPaymentStatusBoolExp
  transactionCreditCardDetails: CreditCardDetailsBoolExp
  transactionFinsharkDetails: FinsharkDetailsBoolExp
  transactionId: StringComparisonExp
  transactionMobilePayDetails: MobilePayDetailsBoolExp
  transactionSwishDetails: SwishDetailsBoolExp
  transactionVippsDetails: VippsDetailsBoolExp
  waitToken: UuidComparisonExp
}

"""URL containing a downloadable CSV with payment request data"""
type PaymentRequestCSV {
  createdAt: timestamptz!
  customerEmail: String

  """

  End date till which the csv is generated.

  """
  endDate: date!

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String
  expiresAt: timestamptz

  """This is the key that we send to query for the links."""
  id: bigint!

  """
  The Amazon S3 presigned URL shared with merchant for them to download the csv.
  """
  link: String
  maxAmount: bigint
  minAmount: bigint
  reference: String

  """

  Start date from which the csv is generated.

  """
  startDate: date!

  """The status of creating the presigned URL."""
  status: ReportLinkStatusEnum!
}

"""
Boolean expression to filter rows from the table "merchant_portal.generated_payment_requests_csv". All fields are combined with a logical 'AND'.
"""
input PaymentRequestCSVBoolExp {
  _and: [PaymentRequestCSVBoolExp!]
  _not: PaymentRequestCSVBoolExp
  _or: [PaymentRequestCSVBoolExp!]
  createdAt: TimestamptzComparisonExp
  customerEmail: StringComparisonExp
  endDate: DateComparisonExp
  errMessage: StringComparisonExp
  expiresAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  link: StringComparisonExp
  maxAmount: BigintComparisonExp
  minAmount: BigintComparisonExp
  reference: StringComparisonExp
  startDate: DateComparisonExp
  status: ReportLinkStatusEnumComparisonExp
}

"""
Ordering options when selecting data from "merchant_portal.generated_payment_requests_csv".
"""
input PaymentRequestCSVOrderBy {
  createdAt: OrderBy
  customerEmail: OrderBy
  endDate: OrderBy
  errMessage: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  link: OrderBy
  maxAmount: OrderBy
  minAmount: OrderBy
  reference: OrderBy
  startDate: OrderBy
  status: OrderBy
}

"""
select columns of table "merchant_portal.generated_payment_requests_csv"
"""
enum PaymentRequestCSVSelectColumn {
  """column name"""
  createdAt

  """column name"""
  customerEmail

  """column name"""
  endDate

  """column name"""
  errMessage

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  link

  """column name"""
  maxAmount

  """column name"""
  minAmount

  """column name"""
  reference

  """column name"""
  startDate

  """column name"""
  status
}

"""
Streaming cursor of the table "PaymentRequestCSV"
"""
input PaymentRequestCSVStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: PaymentRequestCSVStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input PaymentRequestCSVStreamCursorValueInput {
  createdAt: timestamptz
  customerEmail: String

  """

  End date till which the csv is generated.

  """
  endDate: date

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String
  expiresAt: timestamptz

  """This is the key that we send to query for the links."""
  id: bigint

  """
  The Amazon S3 presigned URL shared with merchant for them to download the csv.
  """
  link: String
  maxAmount: bigint
  minAmount: bigint
  reference: String

  """

  Start date from which the csv is generated.

  """
  startDate: date

  """The status of creating the presigned URL."""
  status: ReportLinkStatusEnum
}

"""Payment method"""
enum PaymentRequestMethod {
  """Credit or Debit cards"""
  CREDIT_CARD

  """Open Banking direct debit via Finshark"""
  FINSHARK_DIRECT_DEBIT

  """Open Banking recurring debit via Finshark"""
  FINSHARK_RECURRING_DEBIT

  """Pay with MobilePay Online"""
  MOBILEPAY

  """Pay with PayPal"""
  PAYPAL

  """Swish"""
  SWISH

  """Pay with Vipps"""
  VIPPS
}

"""Ordering options when selecting data from "runtime.payment"."""
input PaymentRequestOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  currency: OrderBy
  customer: CustomerPaymentDataOrderBy
  detailAggregate: CurrentPaymentDetailAggregateOrderBy
  latestStatusAggregate: CurrentPaymentStatusAggregateOrderBy
  merchant: MerchantOrderBy
  message: OrderBy
  payment: PaymentOrderBy
  paymentFlow: OrderBy
  paymentProvider: OrderBy
  payment_method_used: PaymentMethodStatusOrderBy
  reference: OrderBy
  resultingPaymentId: OrderBy
  statusAggregate: CurrentPaymentStatusAggregateOrderBy
  statusHistoryAggregate: CurrentPaymentStatusAggregateOrderBy
  transactionCreditCardDetailsAggregate: CreditCardDetailsAggregateOrderBy
  transactionFinsharkDetailsAggregate: FinsharkDetailsAggregateOrderBy
  transactionId: OrderBy
  transactionMobilePayDetailsAggregate: MobilePayDetailsAggregateOrderBy
  transactionSwishDetailsAggregate: SwishDetailsAggregateOrderBy
  transactionVippsDetailsAggregate: VippsDetailsAggregateOrderBy
  waitToken: OrderBy
}

"""The refund status of the resulting payment"""
enum PaymentRequestRefundStatus {
  """The payment is fully refunded"""
  FULLY_REFUNDED

  """The payment has no refunds"""
  NO_REFUND

  """The payment is partially refunded"""
  PARTIALLY_REFUNDED
}

"""
select columns of table "runtime.payment"
"""
enum PaymentRequestSelectColumn {
  """column name"""
  amount

  """column name"""
  createdAt

  """column name"""
  currency

  """column name"""
  message

  """column name"""
  paymentFlow

  """column name"""
  paymentProvider

  """column name"""
  reference

  """column name"""
  resultingPaymentId

  """column name"""
  transactionId

  """column name"""
  waitToken
}

"""Payment status"""
enum PaymentRequestStatus {
  """Payment is authorized. Can be captured now."""
  AUTHORIZED

  """Payment was cancelled."""
  CANCELLED

  """Attempting to cancel the payment."""
  CANCELLING

  """
  Payment capture is declined. Please create a new payment. (Only applicable for payments that support reservation)
  """
  CAPTURE_DECLINED

  """Payment was declined by the customer."""
  DECLINED

  """Payment errored."""
  ERROR

  """Payment is initialising."""
  INITIALIZING

  """Payment is paid."""
  PAID

  """
  Payment is partially captured. (Only applicable for payments that support reservation)
  """
  PARTIALLY_CAPTURED

  """Payment is undergoing check."""
  PRE_FLIGHT_CHECK

  """
  Payment reservation is released. (Only applicable for payments that support reservation)
  """
  RELEASED

  """Payment is requested and waiting for confirmation."""
  WAITING_FOR_PAYMENT
}

"""
select columns of table "payment_gateway.payment"
"""
enum PaymentSelectColumn {
  """column name"""
  amountAuthorized

  """column name"""
  amountPaid

  """column name"""
  createdAt

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  merchantReference

  """column name"""
  paymentMethod

  """column name"""
  paymentRefundStatus

  """column name"""
  transactionId
}

"""Arguments for adding additional data to a payment."""
input PaymentSessionAdditionalData {
  """The E-mail address of the customer."""
  email: String!

  """IP address of the customer attempting the payment."""
  ip: String!

  """
  Language in which the payment is being handled
  Only languages in two-letter `ISO-639-1` format are recognized.
  Example: `SV`, `DA`, `NO`, `IS`, `EN`.
  """
  language: Language!

  """
  The name of the customer that the payment is associated with.

  Max length: 100.
  """
  name: String!

  """A list with all purchase items in this order."""
  orderLines: [PurchaseOrderLineInput!]

  """
  Phone number
  Max length: 100.
  """
  phoneNumber: String

  """Shipping Address for the order."""
  shippingAddress: AddressInput
}

"""Arguments for creating a new payment session."""
input PaymentSessionInput {
  """Additional data about the customer attempting the payment."""
  additionalData: PaymentSessionAdditionalData

  """
  The amount the customer pays in minor units.
  So 100,56 kr would be 10056
  """
  amount: Int!

  """
  The country where the payment is taking place.
  Example: `SE`, `DK`, `NO`, `IS`, `FI`
  """
  country: Country

  """
  When `currency` is not set, it defaults to the merchant's default currency.

  When no payment method is available for the given currency, then
  `newPaymentSession` fails with an error. Similarly, attempting to
  create a payment with a payment method that is not available for
  the given currency also results in an error.
  """
  currency: SupportedCurrencyEnum

  """
  Session expiry timestamp in ISO8601 format.
  E.g. '1970-01-01T00:00:00Z'
  Max is 24 hrs from creation of session.
  """
  expiresAt: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  Merchant's own internal reference that may help the
  merchant in identifying this payment. These have to
  be globally unique but they should be reused for retrying
  a payment.

  Max length: 64.
  """
  merchantReference: String!

  """
  A message to show to the customer. It could be an order id or a reference.
  Only alphanumeric, Swedish characters, and the following are allowed:
  - ':'
  - ';'
  - '.'
  - ','
  - '?'
  - '!'
  - '('
  - ')'
  - '”'
  - '"'
  - ' '

  Max length: 50.
  """
  message: String!
}

"""The result of starting a new payment session."""
type PaymentSessionResult {
  """
  Once a payment session is initialized, you can use this token to start the payment flow.
  """
  token: String!
}

"""Arguments for creating a new payment session."""
input PaymentSessionWithReferenceCheckInput {
  """Additional data about the customer attempting the payment."""
  additionalData: PaymentSessionAdditionalData

  """
  The amount the customer pays in minor units.
  So 100,56 kr would be 10056
  """
  amount: Int!

  """
  The country where the payment is taking place.
  Example: `SE`, `DK`, `NO`, `IS`, `FI`
  """
  country: Country!

  """
  The currency the customer pays in.

  When no payment method is available for the given currency, then
  `newPaymentSession` fails with an error. Similarly, attempting to
  create a payment with a payment method that is not available for
  the given currency also results in an error.
  """
  currency: SupportedCurrencyEnum!

  """
  Session expiry timestamp in ISO8601 format.
  E.g. '1970-01-01T00:00:00Z'
  Max is 24 hrs from creation of session.
  """
  expiresAt: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  Merchant's own internal reference that may help the
  merchant in identifying this payment.

  This identifier will be used for checking existing payment sessions,
  if another session with the same reference exists, and the amount
  and currency are the same, then the existing session will be returned.

  Max length: 64.
  """
  merchantReference: String!

  """
  A message to show to the customer. It could be an order id or a reference.
  Only alphanumeric, Swedish characters, and the following are allowed:
  - ':'
  - ';'
  - '.'
  - ','
  - '?'
  - '!'
  - '('
  - ')'
  - '”'
  - '"'
  - ' '

  Max length: 50.
  """
  message: String!
}

"""The result of starting a new payment session."""
type PaymentSessionWithReferenceCheckResult {
  """
  If a successfult payment was already made for the same `merchantReference`,
  this field will contain the ID of the payment.
  """
  paymentId: String

  """
  Once a payment session is initialized, you can use this token to start the payment flow.
  """
  token: String!
}

enum PaymentStatusEnum {
  """Payment is authorized. Can be captured now."""
  AUTHORIZED

  """Payment was cancelled."""
  CANCELLED

  """Attempting to cancel the payment."""
  CANCELLING

  """
  Payment capture is declined. Please create a new payment. (Only applicable for payments that support reservation)
  """
  CAPTURE_DECLINED

  """Payment was declined by the customer."""
  DECLINED

  """Payment errored."""
  ERROR

  """Payment is initialising."""
  INITIALIZING

  """Payment is paid."""
  PAID

  """
  Payment is partially captured. (Only applicable for payments that support reservation)
  """
  PARTIALLY_CAPTURED

  """Payment is undergoing check."""
  PRE_FLIGHT_CHECK

  """
  Payment reservation is released. (Only applicable for payments that support reservation)
  """
  RELEASED

  """Payment is requested and waiting for confirmation."""
  WAITING_FOR_PAYMENT
}

"""
Boolean expression to compare columns of type "PaymentStatusEnum". All fields are combined with logical 'AND'.
"""
input PaymentStatusEnumComparisonExp {
  _eq: PaymentStatusEnum
  _in: [PaymentStatusEnum!]
  _isNull: Boolean
  _neq: PaymentStatusEnum
  _nin: [PaymentStatusEnum!]
}

"""aggregate stddev on columns"""
type PaymentStddevFields {
  amountAuthorized: Float

  """Amount paid by the customer to the merchant."""
  amountPaid: Float
  id: Float
}

"""aggregate stddevPop on columns"""
type PaymentStddevPopFields {
  amountAuthorized: Float

  """Amount paid by the customer to the merchant."""
  amountPaid: Float
  id: Float
}

"""aggregate stddevSamp on columns"""
type PaymentStddevSampFields {
  amountAuthorized: Float

  """Amount paid by the customer to the merchant."""
  amountPaid: Float
  id: Float
}

"""aggregate sum on columns"""
type PaymentSumFields {
  amountAuthorized: bigint

  """Amount paid by the customer to the merchant."""
  amountPaid: bigint
  id: bigint
}

"""aggregate varPop on columns"""
type PaymentVarPopFields {
  amountAuthorized: Float

  """Amount paid by the customer to the merchant."""
  amountPaid: Float
  id: Float
}

"""aggregate varSamp on columns"""
type PaymentVarSampFields {
  amountAuthorized: Float

  """Amount paid by the customer to the merchant."""
  amountPaid: Float
  id: Float
}

"""aggregate variance on columns"""
type PaymentVarianceFields {
  amountAuthorized: Float

  """Amount paid by the customer to the merchant."""
  amountPaid: Float
  id: Float
}

enum PaypalIntentEnum {
  """Authorize to capture funds later."""
  AUTHORIZE

  """Instant capture funds."""
  CAPTURE
}

"""
Boolean expression to compare columns of type "PaypalIntentEnum". All fields are combined with logical 'AND'.
"""
input PaypalIntentEnumComparisonExp {
  _eq: PaypalIntentEnum
  _in: [PaypalIntentEnum!]
  _isNull: Boolean
  _neq: PaypalIntentEnum
  _nin: [PaypalIntentEnum!]
}

"""

A purchase is an order that has been fully acknowledged by us and linked to an authenticated customer.

"""
type Purchase {
  """An object relationship"""
  billingAddress: CustomerAddress!
  billingAddressId: bigint!

  """An array relationship"""
  captureItemDiscounts(
    """distinct select on columns"""
    distinctOn: [DiscountSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DiscountOrderBy!]

    """filter the rows returned"""
    where: DiscountBoolExp
  ): [Discount!]!

  """An aggregate relationship"""
  captureItemDiscountsAggregate(
    """distinct select on columns"""
    distinctOn: [DiscountSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DiscountOrderBy!]

    """filter the rows returned"""
    where: DiscountBoolExp
  ): DiscountAggregate!

  """An array relationship"""
  captures(
    """distinct select on columns"""
    distinctOn: [CaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CaptureOrderBy!]

    """filter the rows returned"""
    where: CaptureBoolExp
  ): [Capture!]!

  """An aggregate relationship"""
  capturesAggregate(
    """distinct select on columns"""
    distinctOn: [CaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CaptureOrderBy!]

    """filter the rows returned"""
    where: CaptureBoolExp
  ): CaptureAggregate!
  createdAt: timestamptz!

  """An object relationship"""
  customer: Customer!
  customerId: bigint!
  deliveryAddressId: bigint
  deliveryMethod: String!

  """An object relationship"""
  expiration: PurchaseExpiration
  id: bigint!

  """List of instalment statuses the purchase is currently on"""
  instalmentStatus(
    """distinct select on columns"""
    distinctOn: [CurrentInstalmentStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentInstalmentStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentInstalmentStatusBoolExp
  ): [CurrentInstalmentStatus!]

  """An array relationship"""
  instalments(
    """distinct select on columns"""
    distinctOn: [InstalmentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InstalmentOrderBy!]

    """filter the rows returned"""
    where: InstalmentBoolExp
  ): [Instalment!]!

  """An object relationship"""
  invoice: Invoice

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinctOn: [PurchaseItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseItemOrderBy!]

    """filter the rows returned"""
    where: PurchaseItemBoolExp
  ): [PurchaseItem!]!

  """An aggregate relationship"""
  itemsAggregate(
    """distinct select on columns"""
    distinctOn: [PurchaseItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseItemOrderBy!]

    """filter the rows returned"""
    where: PurchaseItemBoolExp
  ): PurchaseItemAggregate!

  """An object relationship"""
  merchant: Merchant!

  """
  This is a reference key that the merchant provides for their internal tracking.
  """
  merchantReference: String!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinctOn: [PurchasePaymentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchasePaymentOrderBy!]

    """filter the rows returned"""
    where: PurchasePaymentBoolExp
  ): [PurchasePayment!]!

  """An aggregate relationship"""
  paymentsAggregate(
    """distinct select on columns"""
    distinctOn: [PurchasePaymentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchasePaymentOrderBy!]

    """filter the rows returned"""
    where: PurchasePaymentBoolExp
  ): PurchasePaymentAggregate!

  """An array relationship"""
  returns(
    """distinct select on columns"""
    distinctOn: [ReturnSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReturnOrderBy!]

    """filter the rows returned"""
    where: ReturnBoolExp
  ): [Return!]!

  """An aggregate relationship"""
  returnsAggregate(
    """distinct select on columns"""
    distinctOn: [ReturnSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReturnOrderBy!]

    """filter the rows returned"""
    where: ReturnBoolExp
  ): ReturnAggregate!

  """An object relationship"""
  shippingAddress: CustomerAddress

  """List of statuses the purchase is currently on"""
  status(
    """distinct select on columns"""
    distinctOn: [CurrentPurchaseStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentPurchaseStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentPurchaseStatusBoolExp
  ): [CurrentPurchaseStatus!]

  """An array relationship"""
  surcharges(
    """distinct select on columns"""
    distinctOn: [SurchargeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SurchargeOrderBy!]

    """filter the rows returned"""
    where: SurchargeBoolExp
  ): [Surcharge!]!
  taxAmount: bigint!

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: bigint!
}

"""
aggregated selection of "marketplace.purchase"
"""
type PurchaseAggregate {
  aggregate: PurchaseAggregateFields
  nodes: [Purchase!]!
}

input PurchaseAggregateBoolExp {
  count: PurchaseAggregateBoolExpCount
}

input PurchaseAggregateBoolExpCount {
  arguments: [PurchaseSelectColumn!]
  distinct: Boolean
  filter: PurchaseBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "marketplace.purchase"
"""
type PurchaseAggregateFields {
  avg: PurchaseAvgFields
  count(columns: [PurchaseSelectColumn!], distinct: Boolean): Int!
  max: PurchaseMaxFields
  min: PurchaseMinFields
  stddev: PurchaseStddevFields
  stddevPop: PurchaseStddevPopFields
  stddevSamp: PurchaseStddevSampFields
  sum: PurchaseSumFields
  varPop: PurchaseVarPopFields
  varSamp: PurchaseVarSampFields
  variance: PurchaseVarianceFields
}

"""
order by aggregate values of table "marketplace.purchase"
"""
input PurchaseAggregateOrderBy {
  avg: PurchaseAvgOrderBy
  count: OrderBy
  max: PurchaseMaxOrderBy
  min: PurchaseMinOrderBy
  stddev: PurchaseStddevOrderBy
  stddevPop: PurchaseStddevPopOrderBy
  stddevSamp: PurchaseStddevSampOrderBy
  sum: PurchaseSumOrderBy
  varPop: PurchaseVarPopOrderBy
  varSamp: PurchaseVarSampOrderBy
  variance: PurchaseVarianceOrderBy
}

"""aggregate avg on columns"""
type PurchaseAvgFields {
  billingAddressId: Float
  customerId: Float
  deliveryAddressId: Float
  id: Float
  taxAmount: Float

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: Float
}

"""
order by avg() on columns of table "marketplace.purchase"
"""
input PurchaseAvgOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.purchase". All fields are combined with a logical 'AND'.
"""
input PurchaseBoolExp {
  _and: [PurchaseBoolExp!]
  _not: PurchaseBoolExp
  _or: [PurchaseBoolExp!]
  billingAddress: CustomerAddressBoolExp
  billingAddressId: BigintComparisonExp
  captureItemDiscounts: DiscountBoolExp
  captureItemDiscountsAggregate: DiscountAggregateBoolExp
  captures: CaptureBoolExp
  capturesAggregate: CaptureAggregateBoolExp
  createdAt: TimestamptzComparisonExp
  customer: CustomerBoolExp
  customerId: BigintComparisonExp
  deliveryAddressId: BigintComparisonExp
  deliveryMethod: StringComparisonExp
  expiration: PurchaseExpirationBoolExp
  id: BigintComparisonExp
  instalmentStatus: CurrentInstalmentStatusBoolExp
  instalments: InstalmentBoolExp
  invoice: InvoiceBoolExp
  items: PurchaseItemBoolExp
  itemsAggregate: PurchaseItemAggregateBoolExp
  merchant: MerchantBoolExp
  merchantReference: StringComparisonExp
  payments: PurchasePaymentBoolExp
  paymentsAggregate: PurchasePaymentAggregateBoolExp
  returns: ReturnBoolExp
  returnsAggregate: ReturnAggregateBoolExp
  shippingAddress: CustomerAddressBoolExp
  status: CurrentPurchaseStatusBoolExp
  surcharges: SurchargeBoolExp
  taxAmount: BigintComparisonExp
  totalAmount: BigintComparisonExp
}

"""The current status of the bulk capture request"""
type PurchaseBulkCaptureStatus {
  captureId: bigint
  createdAt: timestamptz!
  description: String
  errMessage: String
  purchaseId: bigint!
  status: CaptureStatusEnum!
  waitToken: String!
}

"""
Boolean expression to filter rows from the table "runtime.purchase_capture_job_status". All fields are combined with a logical 'AND'.
"""
input PurchaseBulkCaptureStatusBoolExp {
  _and: [PurchaseBulkCaptureStatusBoolExp!]
  _not: PurchaseBulkCaptureStatusBoolExp
  _or: [PurchaseBulkCaptureStatusBoolExp!]
  captureId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  errMessage: StringComparisonExp
  purchaseId: BigintComparisonExp
  status: CaptureStatusEnumComparisonExp
  waitToken: StringComparisonExp
}

"""
Ordering options when selecting data from "runtime.purchase_capture_job_status".
"""
input PurchaseBulkCaptureStatusOrderBy {
  captureId: OrderBy
  createdAt: OrderBy
  description: OrderBy
  errMessage: OrderBy
  purchaseId: OrderBy
  status: OrderBy
  waitToken: OrderBy
}

"""
select columns of table "runtime.purchase_capture_job_status"
"""
enum PurchaseBulkCaptureStatusSelectColumn {
  """column name"""
  captureId

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  errMessage

  """column name"""
  purchaseId

  """column name"""
  status

  """column name"""
  waitToken
}

"""URL containing a downloadable CSV with purchase data"""
type PurchaseCSV {
  createdAt: timestamptz!

  """

  End date till which the csv is generated.

  """
  endDate: date!

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String
  expiresAt: timestamptz

  """This is the key that we send to query for the links."""
  id: bigint!

  """
  The Amazon S3 presigned URL shared with merchant for them to download the csv.
  """
  link: String

  """

  Start date from which the csv is generated.

  """
  startDate: date!

  """The status of creating the presigned URL."""
  status: ReportLinkStatusEnum!
}

"""
Boolean expression to filter rows from the table "merchant_portal.generated_purchases_csv". All fields are combined with a logical 'AND'.
"""
input PurchaseCSVBoolExp {
  _and: [PurchaseCSVBoolExp!]
  _not: PurchaseCSVBoolExp
  _or: [PurchaseCSVBoolExp!]
  createdAt: TimestamptzComparisonExp
  endDate: DateComparisonExp
  errMessage: StringComparisonExp
  expiresAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  link: StringComparisonExp
  startDate: DateComparisonExp
  status: ReportLinkStatusEnumComparisonExp
}

"""
Ordering options when selecting data from "merchant_portal.generated_purchases_csv".
"""
input PurchaseCSVOrderBy {
  createdAt: OrderBy
  endDate: OrderBy
  errMessage: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  link: OrderBy
  startDate: OrderBy
  status: OrderBy
}

"""
select columns of table "merchant_portal.generated_purchases_csv"
"""
enum PurchaseCSVSelectColumn {
  """column name"""
  createdAt

  """column name"""
  endDate

  """column name"""
  errMessage

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  link

  """column name"""
  startDate

  """column name"""
  status
}

"""
A purchase cancellation made when we are waiting for captures or we already have a capture
"""
input PurchaseCancelInput {
  """This is the id of the purchase to cancel."""
  purchaseId: bigint!
}

"""The result of cancelling a purchase."""
type PurchaseCancelResult {
  """We return True for success and False for failure."""
  result: Boolean!
}

"""A complete shipment of multiple purchases."""
input PurchaseCaptureAllBatchInput {
  """
  Description of the purchase capture.
  Max length: 10000.
  """
  description: String

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """Id of the purchase"""
  purchaseIds: [bigint!]!
}

"""The result of initiating a full capture of multiple purchases."""
type PurchaseCaptureAllBatchResult {
  """
  Once a capture for multiple purchases is received, we will start processing the capture for each purchase.
  We can use the waitToken to query the status of capture for each of the purchases.
  """
  waitToken: String!
}

"""A complete shipment of a purchase."""
input PurchaseCaptureAllInput {
  """
  Description of the purchase capture.
  Max length: 10000.
  """
  description: String

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """Id of the purchase"""
  purchaseId: bigint!
}

"""A set of purchase filters to use for performing a full capture."""
input PurchaseCaptureAllRangeFilterByInput {
  """Purchase status to filter by for full capture"""
  status: [PurchaseCaptureStatus!]!
}

"""A complete shipment of multiple purchases."""
input PurchaseCaptureAllRangeInput {
  """
  Description of the purchase capture.
  Max length: 10000.
  """
  description: String

  """End date (inclusive) to filter for purchases."""
  endDate: String!

  """A set of filters to filter the purchase by."""
  filterBy: PurchaseCaptureAllRangeFilterByInput!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """Start date (inclusive) from when to filter for purchases."""
  startDate: String!
}

"""
The result of initiating a full capture for the date range and/or purchase status filter.
"""
type PurchaseCaptureAllRangeResult {
  """
  Once a capture for multiple purchases is received, we will start processing the capture for each purchase.
  We can use the waitToken to query the status of capture for purchases in the date range and the purchase status filter used.
  """
  waitToken: String!
}

"""The result of capturing a purchase."""
type PurchaseCaptureAllResult {
  """
  Once a purchase is captured. We will start processing the payout to the merchant.
  You can use this token to query the created capture.
  """
  captureId: bigint!
}

"""A partial or complete shipment of a purchase."""
input PurchaseCaptureInput {
  """List of items captured in this purchase."""
  captureItems: [PurchaseCaptureItemInput!]!

  """
  Description of the purchase capture.
  Max length: 10000.
  """
  description: String

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """Id of the purchase"""
  purchaseId: bigint!
}

"""An item from the purchase order"""
input PurchaseCaptureItemInput {
  """Unit price including tax in minor units."""
  pricePerItem: Int!

  """Number of items captured sharing the same reference."""
  quantity: Int!

  """
  Unique item identification reference.';
  Max length: 64.
  """
  reference: String!

  """
  The tax rate in percent with two implicit decimals. Non-negative. Example: 1500 = 15%
  """
  taxRate: Int!

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: Int!

  """
  Total tax amount on all the captured items of this type in minor units.
  Example: 1500,25 SEk should be 150025.

  Example 100 SEK should be 10000.
  """
  totalTaxAmount: Int!
}

"""The result of capturing a purchase."""
type PurchaseCaptureResult {
  """
  Once a purchase is captured. We will start processing the payout to the merchant.
  You can use this token to query the created capture.
  """
  captureId: bigint!
}

"""Purchase capture status to be used for filtering"""
enum PurchaseCaptureStatus {
  CAPTURE_DONE
  PARTIALLY_CAPTURED
  WAITING_FOR_CAPTURE
}

"""A partial or complete shipment of the items in a purchase."""
input PurchaseCaptureWithItemReferencesInput {
  """
  Description of the purchase capture.
  Max length: 10000.
  """
  description: String

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """List of items references in the purchase to be captured."""
  itemReferences: [String!]!

  """ID of the purchase"""
  purchaseId: bigint!
}

"""The result of capturing the items in the purchase."""
type PurchaseCaptureWithItemReferencesResult {
  """
  Once a purchase is captured, we will start processing the payout to the merchant.
  You can use this token to query the created capture.
  """
  captureId: bigint!
}

"""Edit a purchase address (billing or shipping)."""
input PurchaseEditAddressInput {
  """Id of the address that will be changed."""
  addressId: bigint!

  """City of the customer."""
  city: String!

  """Country of the customer."""
  country: String!

  """Email of the customer."""
  email: String!

  """Customer's first name."""
  firstName: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """Customer's last name."""
  lastName: String!

  """Line 1 of the customer address."""
  line1: String!

  """Line 2 of the customer address."""
  line2: String

  """Phone number of the customer."""
  phoneNumber: String!

  """Postal code of the customer."""
  postalCode: String!

  """Id of the purchase to edit."""
  purchaseId: bigint!
}

"""Result of editing an address of a purchase (billing or shipping)."""
type PurchaseEditAddressResult {
  """Customer who made the purchase."""
  customerId: bigint!
}

"""Edit a purchase that hasn't been captured yet."""
input PurchaseEditInput {
  """A list with new purchase items to add to this order."""
  addPurchaseItems: [PurchaseOrderLineInput!]

  """
  Edit the delivery method for the purchase.

  Max length: 100.
  """
  deliveryMethod: String

  """A list with all purchase items to edit."""
  editPurchaseItems: [PurchaseItemEditInput!]

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  Merchant's own internal order number or any other reference that may help the
  merchant in identifying this edit of the purchase.

  Max length: 64.
  """
  merchantReference: String

  """Id of the purchase to edit."""
  purchaseId: bigint!

  """
  Total tax amount of all the order in minor units.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.

  Must be within ±1 of: totalAmount - totalAmount * 10000 / (10000 + taxRate).
  """
  purchaseTaxAmount: Int

  """
  Total amount of all the order in minor units. Includes tax and discounts.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.

  Must fulfill equation: total_amount = (quantity x pricePerItem) - totalDiscountAmount
  """
  purchaseTotalAmount: Int
}

"""The result of editing a purchase."""
type PurchaseEditResult {
  """True if a purchase has been successfully edited, False otherwise"""
  success: Boolean!
}

"""
Tracks when a purchase that is still in `waiting_for_capture` would expire
"""
type PurchaseExpiration {
  """Date when the purchase expires"""
  expiresAt: date!
  purchaseId: bigint!
}

"""
Boolean expression to filter rows from the table "marketplace.purchase_expiry_tracker". All fields are combined with a logical 'AND'.
"""
input PurchaseExpirationBoolExp {
  _and: [PurchaseExpirationBoolExp!]
  _not: PurchaseExpirationBoolExp
  _or: [PurchaseExpirationBoolExp!]
  expiresAt: DateComparisonExp
  purchaseId: BigintComparisonExp
}

"""
Ordering options when selecting data from "marketplace.purchase_expiry_tracker".
"""
input PurchaseExpirationOrderBy {
  expiresAt: OrderBy
  purchaseId: OrderBy
}

"""Item(s) purchased by the customer."""
type PurchaseItem {
  extraDiscountedAmount: bigint!

  """

  URL to an image that can be used later in communications between kronor
  and the customer.

  """
  imageUrl: String

  """

  URL to item in the merchant catalog, that will be used in communications between
  kronor and the customer.

  """
  itemUrl: String

  """Name of the item provided by the merchant."""
  name: String!

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: bigint!
  purchaseId: bigint!

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Int!

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Int!

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Int!

  """
  Identification number of the item either provided by the merchant as bar code or generated by us.
  """
  reference: citext!

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: smallint!

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: bigint!

  """Amount that has been captured."""
  totalCapturedAmount: bigint!

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: bigint!
  totalReturnedAmount: bigint!

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: bigint!
}

"""
aggregated selection of "marketplace.purchase_item"
"""
type PurchaseItemAggregate {
  aggregate: PurchaseItemAggregateFields
  nodes: [PurchaseItem!]!
}

input PurchaseItemAggregateBoolExp {
  count: PurchaseItemAggregateBoolExpCount
}

input PurchaseItemAggregateBoolExpCount {
  arguments: [PurchaseItemSelectColumn!]
  distinct: Boolean
  filter: PurchaseItemBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "marketplace.purchase_item"
"""
type PurchaseItemAggregateFields {
  avg: PurchaseItemAvgFields
  count(columns: [PurchaseItemSelectColumn!], distinct: Boolean): Int!
  max: PurchaseItemMaxFields
  min: PurchaseItemMinFields
  stddev: PurchaseItemStddevFields
  stddevPop: PurchaseItemStddevPopFields
  stddevSamp: PurchaseItemStddevSampFields
  sum: PurchaseItemSumFields
  varPop: PurchaseItemVarPopFields
  varSamp: PurchaseItemVarSampFields
  variance: PurchaseItemVarianceFields
}

"""
order by aggregate values of table "marketplace.purchase_item"
"""
input PurchaseItemAggregateOrderBy {
  avg: PurchaseItemAvgOrderBy
  count: OrderBy
  max: PurchaseItemMaxOrderBy
  min: PurchaseItemMinOrderBy
  stddev: PurchaseItemStddevOrderBy
  stddevPop: PurchaseItemStddevPopOrderBy
  stddevSamp: PurchaseItemStddevSampOrderBy
  sum: PurchaseItemSumOrderBy
  varPop: PurchaseItemVarPopOrderBy
  varSamp: PurchaseItemVarSampOrderBy
  variance: PurchaseItemVarianceOrderBy
}

"""aggregate avg on columns"""
type PurchaseItemAvgFields {
  extraDiscountedAmount: Float

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: Float
  purchaseId: Float

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Float

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Float

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Float

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: Float

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: Float

  """Amount that has been captured."""
  totalCapturedAmount: Float

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: Float
  totalReturnedAmount: Float

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: Float
}

"""
order by avg() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemAvgOrderBy {
  extraDiscountedAmount: OrderBy

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: OrderBy

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.purchase_item". All fields are combined with a logical 'AND'.
"""
input PurchaseItemBoolExp {
  _and: [PurchaseItemBoolExp!]
  _not: PurchaseItemBoolExp
  _or: [PurchaseItemBoolExp!]
  extraDiscountedAmount: BigintComparisonExp
  imageUrl: StringComparisonExp
  itemUrl: StringComparisonExp
  name: StringComparisonExp
  pricePerItem: BigintComparisonExp
  purchaseId: BigintComparisonExp
  quantity: IntComparisonExp
  quantityDelivered: IntComparisonExp
  quantityReturned: IntComparisonExp
  reference: CitextComparisonExp
  taxRate: SmallintComparisonExp
  totalAmount: BigintComparisonExp
  totalCapturedAmount: BigintComparisonExp
  totalDiscountAmount: BigintComparisonExp
  totalReturnedAmount: BigintComparisonExp
  totalTaxAmount: BigintComparisonExp
}

"""
Purchase item to add to a purchase
or edit an existing item in the purchase."
"""
input PurchaseItemEditInput {
  """
  URL to an image that can be used later in communications between kronor
  and the customer.

  Max length: 10000.
  """
  imageUrl: String

  """
  URL to item in the merchant catalog, that will be used in communications between
  kronor and the customer.

  Max length: 10000.
  """
  itemUrl: String

  """
  The name of the purchased item

  Max length: 100.
  """
  name: String

  """
  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.
  """
  pricePerItem: Int

  """
  Number of items ordered by the customer. Needs to be a positive number.
  """
  quantity: Int

  """
  The reference of the item to edit the purchase item. Reference can be queried
  from the 'purchase' query.

  Max length: 64.
  """
  reference: String!

  """
  Tax rate on the items ordered in this line.
  Needs to be a non-negative number.
  Example: `15%` discount should be represented as `1500`.
  """
  taxRate: Int

  """
  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.
  """
  totalAmount: Int

  """
  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: `1500,25` SEk should be `150025`.
  Example `100` SEK should be `10000`.
  """
  totalDiscountAmount: Int

  """
  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.

  Example 100 SEK should be 10000.
  """
  totalTaxAmount: Int
}

"""aggregate max on columns"""
type PurchaseItemMaxFields {
  extraDiscountedAmount: bigint

  """

  URL to an image that can be used later in communications between kronor
  and the customer.

  """
  imageUrl: String

  """

  URL to item in the merchant catalog, that will be used in communications between
  kronor and the customer.

  """
  itemUrl: String

  """Name of the item provided by the merchant."""
  name: String

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: bigint
  purchaseId: bigint

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Int

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Int

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Int

  """
  Identification number of the item either provided by the merchant as bar code or generated by us.
  """
  reference: citext

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: smallint

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: bigint

  """Amount that has been captured."""
  totalCapturedAmount: bigint

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: bigint
  totalReturnedAmount: bigint

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: bigint
}

"""
order by max() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemMaxOrderBy {
  extraDiscountedAmount: OrderBy

  """

  URL to an image that can be used later in communications between kronor
  and the customer.

  """
  imageUrl: OrderBy

  """

  URL to item in the merchant catalog, that will be used in communications between
  kronor and the customer.

  """
  itemUrl: OrderBy

  """Name of the item provided by the merchant."""
  name: OrderBy

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """
  Identification number of the item either provided by the merchant as bar code or generated by us.
  """
  reference: OrderBy

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: OrderBy

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""aggregate min on columns"""
type PurchaseItemMinFields {
  extraDiscountedAmount: bigint

  """

  URL to an image that can be used later in communications between kronor
  and the customer.

  """
  imageUrl: String

  """

  URL to item in the merchant catalog, that will be used in communications between
  kronor and the customer.

  """
  itemUrl: String

  """Name of the item provided by the merchant."""
  name: String

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: bigint
  purchaseId: bigint

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Int

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Int

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Int

  """
  Identification number of the item either provided by the merchant as bar code or generated by us.
  """
  reference: citext

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: smallint

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: bigint

  """Amount that has been captured."""
  totalCapturedAmount: bigint

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: bigint
  totalReturnedAmount: bigint

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: bigint
}

"""
order by min() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemMinOrderBy {
  extraDiscountedAmount: OrderBy

  """

  URL to an image that can be used later in communications between kronor
  and the customer.

  """
  imageUrl: OrderBy

  """

  URL to item in the merchant catalog, that will be used in communications between
  kronor and the customer.

  """
  itemUrl: OrderBy

  """Name of the item provided by the merchant."""
  name: OrderBy

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """
  Identification number of the item either provided by the merchant as bar code or generated by us.
  """
  reference: OrderBy

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: OrderBy

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""Ordering options when selecting data from "marketplace.purchase_item"."""
input PurchaseItemOrderBy {
  extraDiscountedAmount: OrderBy
  imageUrl: OrderBy
  itemUrl: OrderBy
  name: OrderBy
  pricePerItem: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  quantityDelivered: OrderBy
  quantityReturned: OrderBy
  reference: OrderBy
  taxRate: OrderBy
  totalAmount: OrderBy
  totalCapturedAmount: OrderBy
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy
  totalTaxAmount: OrderBy
}

"""
select columns of table "marketplace.purchase_item"
"""
enum PurchaseItemSelectColumn {
  """column name"""
  extraDiscountedAmount

  """column name"""
  imageUrl

  """column name"""
  itemUrl

  """column name"""
  name

  """column name"""
  pricePerItem

  """column name"""
  purchaseId

  """column name"""
  quantity

  """column name"""
  quantityDelivered

  """column name"""
  quantityReturned

  """column name"""
  reference

  """column name"""
  taxRate

  """column name"""
  totalAmount

  """column name"""
  totalCapturedAmount

  """column name"""
  totalDiscountAmount

  """column name"""
  totalReturnedAmount

  """column name"""
  totalTaxAmount
}

"""aggregate stddev on columns"""
type PurchaseItemStddevFields {
  extraDiscountedAmount: Float

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: Float
  purchaseId: Float

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Float

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Float

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Float

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: Float

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: Float

  """Amount that has been captured."""
  totalCapturedAmount: Float

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: Float
  totalReturnedAmount: Float

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: Float
}

"""
order by stddev() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemStddevOrderBy {
  extraDiscountedAmount: OrderBy

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: OrderBy

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""aggregate stddevPop on columns"""
type PurchaseItemStddevPopFields {
  extraDiscountedAmount: Float

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: Float
  purchaseId: Float

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Float

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Float

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Float

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: Float

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: Float

  """Amount that has been captured."""
  totalCapturedAmount: Float

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: Float
  totalReturnedAmount: Float

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: Float
}

"""
order by stddevPop() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemStddevPopOrderBy {
  extraDiscountedAmount: OrderBy

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: OrderBy

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""aggregate stddevSamp on columns"""
type PurchaseItemStddevSampFields {
  extraDiscountedAmount: Float

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: Float
  purchaseId: Float

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Float

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Float

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Float

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: Float

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: Float

  """Amount that has been captured."""
  totalCapturedAmount: Float

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: Float
  totalReturnedAmount: Float

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: Float
}

"""
order by stddevSamp() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemStddevSampOrderBy {
  extraDiscountedAmount: OrderBy

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: OrderBy

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""aggregate sum on columns"""
type PurchaseItemSumFields {
  extraDiscountedAmount: bigint

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: bigint
  purchaseId: bigint

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Int

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Int

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Int

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: smallint

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: bigint

  """Amount that has been captured."""
  totalCapturedAmount: bigint

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: bigint
  totalReturnedAmount: bigint

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: bigint
}

"""
order by sum() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemSumOrderBy {
  extraDiscountedAmount: OrderBy

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: OrderBy

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""aggregate varPop on columns"""
type PurchaseItemVarPopFields {
  extraDiscountedAmount: Float

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: Float
  purchaseId: Float

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Float

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Float

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Float

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: Float

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: Float

  """Amount that has been captured."""
  totalCapturedAmount: Float

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: Float
  totalReturnedAmount: Float

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: Float
}

"""
order by varPop() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemVarPopOrderBy {
  extraDiscountedAmount: OrderBy

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: OrderBy

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""aggregate varSamp on columns"""
type PurchaseItemVarSampFields {
  extraDiscountedAmount: Float

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: Float
  purchaseId: Float

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Float

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Float

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Float

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: Float

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: Float

  """Amount that has been captured."""
  totalCapturedAmount: Float

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: Float
  totalReturnedAmount: Float

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: Float
}

"""
order by varSamp() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemVarSampOrderBy {
  extraDiscountedAmount: OrderBy

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: OrderBy

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""aggregate variance on columns"""
type PurchaseItemVarianceFields {
  extraDiscountedAmount: Float

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: Float
  purchaseId: Float

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Float

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Float

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Float

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: Float

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: Float

  """Amount that has been captured."""
  totalCapturedAmount: Float

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: Float
  totalReturnedAmount: Float

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: Float
}

"""
order by variance() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemVarianceOrderBy {
  extraDiscountedAmount: OrderBy

  """

  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: 1500,25 SEK should be 150025.
  Example 100 SEK should be 10000.

  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """

  Tax rate on the items purchased in this line.
  Needs to be a non-negative number.
  Example: 15% discount should be represented as 1500.

  """
  taxRate: OrderBy

  """

  Total amount of all the items in the line in minor units. Includes tax and discounts.
  It should be calculated with (price_per_item * quantity) - discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """

  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """

  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""aggregate max on columns"""
type PurchaseMaxFields {
  billingAddressId: bigint
  createdAt: timestamptz
  customerId: bigint
  deliveryAddressId: bigint
  deliveryMethod: String
  id: bigint

  """
  This is a reference key that the merchant provides for their internal tracking.
  """
  merchantReference: String
  taxAmount: bigint

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: bigint
}

"""
order by max() on columns of table "marketplace.purchase"
"""
input PurchaseMaxOrderBy {
  billingAddressId: OrderBy
  createdAt: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  deliveryMethod: OrderBy
  id: OrderBy

  """
  This is a reference key that the merchant provides for their internal tracking.
  """
  merchantReference: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""aggregate min on columns"""
type PurchaseMinFields {
  billingAddressId: bigint
  createdAt: timestamptz
  customerId: bigint
  deliveryAddressId: bigint
  deliveryMethod: String
  id: bigint

  """
  This is a reference key that the merchant provides for their internal tracking.
  """
  merchantReference: String
  taxAmount: bigint

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: bigint
}

"""
order by min() on columns of table "marketplace.purchase"
"""
input PurchaseMinOrderBy {
  billingAddressId: OrderBy
  createdAt: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  deliveryMethod: OrderBy
  id: OrderBy

  """
  This is a reference key that the merchant provides for their internal tracking.
  """
  merchantReference: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""An order placed by a yet to be authenticated customer"""
type PurchaseOrder {
  createdAt: timestamptz!

  """

  Idempotency key is required to prevent double processing an order.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.

  """
  id: String!
  merchantReference: String!

  """

  Country where the purchase is taking place.
  Only countries in two-letter ISO-3166 format are recognized.
  Example: SE, DA, NO, DE, EN

  """
  purchaseCountry: country!

  """

  Language in which the purchase is being handled
  Only languages in two-letter ISO-639-1 format are recognized.
  Example: SV, DA, NO, DE.

  """
  purchaseLanguage: spoken_lang!

  """

  Total tax amount for the entire order in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  purchaseTaxAmount: bigint!

  """

  Total amount of all the order in minor units. Includes tax and discounts.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  purchaseTotalAmount: bigint!
  resultingPurchaseId: bigint

  """List of statuses the order is currently on"""
  status(
    """distinct select on columns"""
    distinctOn: [CurrentPurchaseOrderStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentPurchaseOrderStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentPurchaseOrderStatusBoolExp
  ): [CurrentPurchaseOrderStatus!]
}

"""
Boolean expression to filter rows from the table "checkout.purchase_order". All fields are combined with a logical 'AND'.
"""
input PurchaseOrderBoolExp {
  _and: [PurchaseOrderBoolExp!]
  _not: PurchaseOrderBoolExp
  _or: [PurchaseOrderBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  merchantReference: StringComparisonExp
  purchaseCountry: CountryComparisonExp
  purchaseLanguage: SpokenLangComparisonExp
  purchaseTaxAmount: BigintComparisonExp
  purchaseTotalAmount: BigintComparisonExp
  resultingPurchaseId: BigintComparisonExp
  status: CurrentPurchaseOrderStatusBoolExp
}

"""Ordering options when selecting data from "marketplace.purchase"."""
input PurchaseOrderBy {
  billingAddress: CustomerAddressOrderBy
  billingAddressId: OrderBy
  captureItemDiscountsAggregate: DiscountAggregateOrderBy
  capturesAggregate: CaptureAggregateOrderBy
  createdAt: OrderBy
  customer: CustomerOrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  deliveryMethod: OrderBy
  expiration: PurchaseExpirationOrderBy
  id: OrderBy
  instalmentStatusAggregate: CurrentInstalmentStatusAggregateOrderBy
  instalmentsAggregate: InstalmentAggregateOrderBy
  invoice: InvoiceOrderBy
  itemsAggregate: PurchaseItemAggregateOrderBy
  merchant: MerchantOrderBy
  merchantReference: OrderBy
  paymentsAggregate: PurchasePaymentAggregateOrderBy
  returnsAggregate: ReturnAggregateOrderBy
  shippingAddress: CustomerAddressOrderBy
  statusAggregate: CurrentPurchaseStatusAggregateOrderBy
  surchargesAggregate: SurchargeAggregateOrderBy
  taxAmount: OrderBy
  totalAmount: OrderBy
}

"""
A purchase cancellation intent by a customer that is yet to be fully authenticated.
"""
input PurchaseOrderCancelInput {
  """
  This is the id of the order to cancel.

  Max length: 64.
  """
  purchaseOrderId: String!
}

"""The result of cancelling a purchase order."""
type PurchaseOrderCancelResult {
  """We return True for success and False for failure."""
  result: Boolean!
}

"""List of order items which are part of this checkout."""
input PurchaseOrderLineInput {
  """
  URL to an image that can be used later in communications between kronor
  and the customer.

  Max length: 10000.
  """
  imageUrl: String

  """
  URL to item in the merchant catalog, that will be used in communications between
  kronor and the customer.

  Max length: 10000.
  """
  itemUrl: String

  """
  The name of the purchased item

  Max length: 100.
  """
  name: String!

  """
  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.
  """
  pricePerItem: Int!

  """
  Number of items ordered by the customer. Needs to be a positive number.
  """
  quantity: Int!

  """
  Merchant's own internal item number or any other reference that may help the
  merchant in identifying this purchase.

  Max length: 64.
  """
  reference: String

  """
  Tax rate on the items ordered in this line.
  Needs to be a non-negative number.
  Example: `15%` discount should be represented as `1500`.
  """
  taxRate: Int!

  """
  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.
  """
  totalAmount: Int!

  """
  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.
  """
  totalDiscountAmount: Int

  """
  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.

  Example 100 SEK should be 10000.
  """
  totalTaxAmount: Int!
}

"""Ordering options when selecting data from "checkout.purchase_order"."""
input PurchaseOrderOrderBy {
  createdAt: OrderBy
  id: OrderBy
  merchantReference: OrderBy
  purchaseCountry: OrderBy
  purchaseLanguage: OrderBy
  purchaseTaxAmount: OrderBy
  purchaseTotalAmount: OrderBy
  resultingPurchaseId: OrderBy
  statusAggregate: CurrentPurchaseOrderStatusAggregateOrderBy
}

"""
select columns of table "checkout.purchase_order"
"""
enum PurchaseOrderSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  merchantReference

  """column name"""
  purchaseCountry

  """column name"""
  purchaseLanguage

  """column name"""
  purchaseTaxAmount

  """column name"""
  purchaseTotalAmount

  """column name"""
  resultingPurchaseId
}

"""
A purchase intent by a customer that is yet to be fully authenticated, uses instalments in contrast to PurchaseOrderWithInvoiceInput, and a fee will be added to each instalment.
"""
input PurchaseOrderWithInstalmentsInput {
  """The billing address for the customer making the purchase."""
  billingAddress: AddressInput!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  Merchant's own internal order number or any other reference that may help the
  merchant in identifying this purchase.

  Max length: 64.
  """
  merchantReference: String

  """
  National identification number for the customer.
  This will be use to perform strong customer authentication, that is,
  making sure of the customer's identity.
  """
  nationalIdentificationNumber: String!

  """
  Country where the purchase is taking place.
  Example: `Sweden`, `Denmark`, `Norway`, `Iceland`
  """
  purchaseCountry: Country!

  """
  Language in which the purchase is being handled
  Only languages in two-letter `ISO-639-1` format are recognized.
  Example: `SV`, `DA`, `NO`, `IS`, `EN`.
  """
  purchaseLanguage: Language!

  """A list with all purchase items in this order."""
  purchaseLines: [PurchaseOrderLineInput!]!

  """
  Total tax amount of all the order in minor units.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.

  Must be within ±1 of: totalAmount - totalAmount * 10000 / (10000 + taxRate).
  """
  purchaseTaxAmount: Int!

  """
  Total amount of all the order in minor units. Includes tax and discounts.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.

  Must fulfill equation: totalAmount = (quantity x pricePerItem) - totalDiscountAmount
  """
  purchaseTotalAmount: Int!

  """The address the customer wants to ship the purchased items to."""
  shippingAddress: AddressInput
}

"""The result of initiating a purchase order with instalments."""
type PurchaseOrderWithInstalmentsResult {
  """The resulting purchase order ID (same as the idempotency key)"""
  id: String!

  """
  Once a purchase order is received, we will start processing for
  fraud and final approval. You can use this token to query the current
  status.
  """
  waitToken: String!
}

"""A purchase intent by a customer that is yet to be fully authenticated."""
input PurchaseOrderWithInvoiceInput {
  """The billing address for the customer making the purchase."""
  billingAddress: AddressInput!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  Merchant's own internal order number or any other reference that may help the
  merchant in identifying this purchase.

  Max length: 64.
  """
  merchantReference: String

  """
  National identification number for the customer.
  This will be use to perform strong customer authentication, that is,
  making sure of the customer's identity.
  """
  nationalIdentificationNumber: String!

  """
  Country where the purchase is taking place.
  Example: `Sweden`, `Denmark`, `Norway`, `Iceland`
  """
  purchaseCountry: Country!

  """
  Language in which the purchase is being handled
  Only languages in two-letter `ISO-639-1` format are recognized.
  Example: `SV`, `DA`, `NO`, `IS`, `EN`.
  """
  purchaseLanguage: Language!

  """A list with all purchase items in this order."""
  purchaseLines: [PurchaseOrderLineInput!]!

  """
  Total tax amount of all the order in minor units.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.

  Must be within ±1 of: totalAmount - totalAmount * 10000 / (10000 + taxRate).
  """
  purchaseTaxAmount: Int!

  """
  Total amount of all the order in minor units. Includes tax and discounts.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.

  Must fulfill equation: totalAmount = (quantity x pricePerItem) - totalDiscountAmount
  """
  purchaseTotalAmount: Int!

  """The address the customer wants to ship the purchased items to."""
  shippingAddress: AddressInput
}

"""The result of initiating a purchase order with invoice."""
type PurchaseOrderWithInvoiceResult {
  """The resulting purchase order ID (same as the idempotency key)"""
  id: String!

  """
  Once a purchase order is received, we will start processing for
  fraud and final approval. You can use this token to query the current
  status.
  """
  waitToken: String!
}

"""Record of payments the customer has made to us."""
type PurchasePayment {
  """Amount paid by the customer to us."""
  amountPaid: bigint!
  createdAt: timestamptz!
  currency: SupportedCurrencyEnum!
  id: bigint!
  paymentMethod: PaymentMethodEnum!
}

"""
aggregated selection of "marketplace.payment"
"""
type PurchasePaymentAggregate {
  aggregate: PurchasePaymentAggregateFields
  nodes: [PurchasePayment!]!
}

input PurchasePaymentAggregateBoolExp {
  count: PurchasePaymentAggregateBoolExpCount
}

input PurchasePaymentAggregateBoolExpCount {
  arguments: [PurchasePaymentSelectColumn!]
  distinct: Boolean
  filter: PurchasePaymentBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "marketplace.payment"
"""
type PurchasePaymentAggregateFields {
  avg: PurchasePaymentAvgFields
  count(columns: [PurchasePaymentSelectColumn!], distinct: Boolean): Int!
  max: PurchasePaymentMaxFields
  min: PurchasePaymentMinFields
  stddev: PurchasePaymentStddevFields
  stddevPop: PurchasePaymentStddevPopFields
  stddevSamp: PurchasePaymentStddevSampFields
  sum: PurchasePaymentSumFields
  varPop: PurchasePaymentVarPopFields
  varSamp: PurchasePaymentVarSampFields
  variance: PurchasePaymentVarianceFields
}

"""
order by aggregate values of table "marketplace.payment"
"""
input PurchasePaymentAggregateOrderBy {
  avg: PurchasePaymentAvgOrderBy
  count: OrderBy
  max: PurchasePaymentMaxOrderBy
  min: PurchasePaymentMinOrderBy
  stddev: PurchasePaymentStddevOrderBy
  stddevPop: PurchasePaymentStddevPopOrderBy
  stddevSamp: PurchasePaymentStddevSampOrderBy
  sum: PurchasePaymentSumOrderBy
  varPop: PurchasePaymentVarPopOrderBy
  varSamp: PurchasePaymentVarSampOrderBy
  variance: PurchasePaymentVarianceOrderBy
}

"""aggregate avg on columns"""
type PurchasePaymentAvgFields {
  """Amount paid by the customer to us."""
  amountPaid: Float
  id: Float
}

"""
order by avg() on columns of table "marketplace.payment"
"""
input PurchasePaymentAvgOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.payment". All fields are combined with a logical 'AND'.
"""
input PurchasePaymentBoolExp {
  _and: [PurchasePaymentBoolExp!]
  _not: PurchasePaymentBoolExp
  _or: [PurchasePaymentBoolExp!]
  amountPaid: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  currency: SupportedCurrencyEnumComparisonExp
  id: BigintComparisonExp
  paymentMethod: PaymentMethodEnumComparisonExp
}

"""aggregate max on columns"""
type PurchasePaymentMaxFields {
  """Amount paid by the customer to us."""
  amountPaid: bigint
  createdAt: timestamptz
  id: bigint
}

"""
order by max() on columns of table "marketplace.payment"
"""
input PurchasePaymentMaxOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  createdAt: OrderBy
  id: OrderBy
}

"""aggregate min on columns"""
type PurchasePaymentMinFields {
  """Amount paid by the customer to us."""
  amountPaid: bigint
  createdAt: timestamptz
  id: bigint
}

"""
order by min() on columns of table "marketplace.payment"
"""
input PurchasePaymentMinOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  createdAt: OrderBy
  id: OrderBy
}

"""Ordering options when selecting data from "marketplace.payment"."""
input PurchasePaymentOrderBy {
  amountPaid: OrderBy
  createdAt: OrderBy
  currency: OrderBy
  id: OrderBy
  paymentMethod: OrderBy
}

"""
select columns of table "marketplace.payment"
"""
enum PurchasePaymentSelectColumn {
  """column name"""
  amountPaid

  """column name"""
  createdAt

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  paymentMethod
}

"""aggregate stddev on columns"""
type PurchasePaymentStddevFields {
  """Amount paid by the customer to us."""
  amountPaid: Float
  id: Float
}

"""
order by stddev() on columns of table "marketplace.payment"
"""
input PurchasePaymentStddevOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
}

"""aggregate stddevPop on columns"""
type PurchasePaymentStddevPopFields {
  """Amount paid by the customer to us."""
  amountPaid: Float
  id: Float
}

"""
order by stddevPop() on columns of table "marketplace.payment"
"""
input PurchasePaymentStddevPopOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
}

"""aggregate stddevSamp on columns"""
type PurchasePaymentStddevSampFields {
  """Amount paid by the customer to us."""
  amountPaid: Float
  id: Float
}

"""
order by stddevSamp() on columns of table "marketplace.payment"
"""
input PurchasePaymentStddevSampOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
}

"""aggregate sum on columns"""
type PurchasePaymentSumFields {
  """Amount paid by the customer to us."""
  amountPaid: bigint
  id: bigint
}

"""
order by sum() on columns of table "marketplace.payment"
"""
input PurchasePaymentSumOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
}

"""aggregate varPop on columns"""
type PurchasePaymentVarPopFields {
  """Amount paid by the customer to us."""
  amountPaid: Float
  id: Float
}

"""
order by varPop() on columns of table "marketplace.payment"
"""
input PurchasePaymentVarPopOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
}

"""aggregate varSamp on columns"""
type PurchasePaymentVarSampFields {
  """Amount paid by the customer to us."""
  amountPaid: Float
  id: Float
}

"""
order by varSamp() on columns of table "marketplace.payment"
"""
input PurchasePaymentVarSampOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
}

"""aggregate variance on columns"""
type PurchasePaymentVarianceFields {
  """Amount paid by the customer to us."""
  amountPaid: Float
  id: Float
}

"""
order by variance() on columns of table "marketplace.payment"
"""
input PurchasePaymentVarianceOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
}

"""A complete return of a purchase."""
input PurchaseReturnAllInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """Id of the purchase"""
  purchaseId: bigint!

  """
  Reason for the purchase return.
  Max length: 10000.
  """
  reason: String

  """Any return fee charged."""
  returnFee: Int
}

"""The result of returning a purchase."""
type PurchaseReturnAllResult {
  """
  Once a purchase is returned, you can use this token to query the status of return.
  """
  returnId: bigint!
}

"""Purchase return."""
input PurchaseReturnInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """Id of the purchase"""
  purchaseId: bigint!

  """Any return fee charged."""
  returnFee: Int

  """List of items returned."""
  returnItems: [PurchaseReturnItemInput!]!

  """
  Reason for returning the items.
  Max length: 1000.
  """
  returnReason: String
}

"""Item return."""
input PurchaseReturnItemInput {
  """
  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: `1500,25` SEK should be `150025`.
  Example: `100` SEK should be `10000`.
  """
  pricePerItem: Int!

  """Number of items captured sharing the same reference."""
  quantity: Int!

  """
  Unique item identification reference.
  Max length: 64.
  """
  reference: String!

  """
  Tax rate on the items ordered in this line.
  Needs to be a non-negative number.
  Example: `15%` discount should be represented as `1500`.
  """
  taxRate: Int!

  """
  Total amount including tax on all the items in this line in minor units.
  Example: 1500,25 SEK should be 150025.
  Example: 100 SEK should be 10000.
  """
  totalAmount: Int!

  """
  Total tax amount on all the returned items of this type in minor units.
  Example: 1500,25 SEk should be 150025.

  Example 100 SEK should be 10000.
  """
  totalTaxAmount: Int!
}

"""The result of processing an item return."""
type PurchaseReturnResult {
  """Query the status of an item return."""
  returnId: bigint!
}

"""
select columns of table "marketplace.purchase"
"""
enum PurchaseSelectColumn {
  """column name"""
  billingAddressId

  """column name"""
  createdAt

  """column name"""
  customerId

  """column name"""
  deliveryAddressId

  """column name"""
  deliveryMethod

  """column name"""
  id

  """column name"""
  merchantReference

  """column name"""
  taxAmount

  """column name"""
  totalAmount
}

enum PurchaseStatusEnum {
  """The order was cancelled by the merchant"""
  CANCELLED

  """The order has been fully captured by the merchant"""
  CAPTURE_DONE

  """The customer needs to setup recurring payments"""
  INSTALMENTS_AUTHORIZE

  """The customer needs to pay the first instalment"""
  INSTALMENT_PRE_PAYMENT

  """The order has been captured partially by the merchant"""
  PARTIALLY_CAPTURED

  """The order has been fully captured and returned."""
  RETURNED

  """The order has been processed as is waiting for capture"""
  WAITING_FOR_CAPTURE
}

"""
Boolean expression to compare columns of type "PurchaseStatusEnum". All fields are combined with logical 'AND'.
"""
input PurchaseStatusEnumComparisonExp {
  _eq: PurchaseStatusEnum
  _in: [PurchaseStatusEnum!]
  _isNull: Boolean
  _neq: PurchaseStatusEnum
  _nin: [PurchaseStatusEnum!]
}

"""aggregate stddev on columns"""
type PurchaseStddevFields {
  billingAddressId: Float
  customerId: Float
  deliveryAddressId: Float
  id: Float
  taxAmount: Float

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: Float
}

"""
order by stddev() on columns of table "marketplace.purchase"
"""
input PurchaseStddevOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""aggregate stddevPop on columns"""
type PurchaseStddevPopFields {
  billingAddressId: Float
  customerId: Float
  deliveryAddressId: Float
  id: Float
  taxAmount: Float

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: Float
}

"""
order by stddevPop() on columns of table "marketplace.purchase"
"""
input PurchaseStddevPopOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""aggregate stddevSamp on columns"""
type PurchaseStddevSampFields {
  billingAddressId: Float
  customerId: Float
  deliveryAddressId: Float
  id: Float
  taxAmount: Float

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: Float
}

"""
order by stddevSamp() on columns of table "marketplace.purchase"
"""
input PurchaseStddevSampOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""aggregate sum on columns"""
type PurchaseSumFields {
  billingAddressId: bigint
  customerId: bigint
  deliveryAddressId: bigint
  id: bigint
  taxAmount: bigint

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: bigint
}

"""
order by sum() on columns of table "marketplace.purchase"
"""
input PurchaseSumOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""aggregate varPop on columns"""
type PurchaseVarPopFields {
  billingAddressId: Float
  customerId: Float
  deliveryAddressId: Float
  id: Float
  taxAmount: Float

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: Float
}

"""
order by varPop() on columns of table "marketplace.purchase"
"""
input PurchaseVarPopOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""aggregate varSamp on columns"""
type PurchaseVarSampFields {
  billingAddressId: Float
  customerId: Float
  deliveryAddressId: Float
  id: Float
  taxAmount: Float

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: Float
}

"""
order by varSamp() on columns of table "marketplace.purchase"
"""
input PurchaseVarSampOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""aggregate variance on columns"""
type PurchaseVarianceFields {
  billingAddressId: Float
  customerId: Float
  deliveryAddressId: Float
  id: Float
  taxAmount: Float

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: Float
}

"""
order by variance() on columns of table "marketplace.purchase"
"""
input PurchaseVarianceOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""List of generated reports given a date range"""
type Reconciliation {
  createdAt: timestamptz!

  """

  End date till which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  endDate: date!
  isAuto: Boolean!

  """

  Start date from which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  startDate: date!
}

"""
aggregated selection of "reconciliation.generated_report"
"""
type ReconciliationAggregate {
  aggregate: ReconciliationAggregateFields
  nodes: [Reconciliation!]!
}

"""
aggregate fields of "reconciliation.generated_report"
"""
type ReconciliationAggregateFields {
  count(columns: [ReconciliationSelectColumn!], distinct: Boolean): Int!
  max: ReconciliationMaxFields
  min: ReconciliationMinFields
}

"""
Boolean expression to filter rows from the table "reconciliation.generated_report". All fields are combined with a logical 'AND'.
"""
input ReconciliationBoolExp {
  _and: [ReconciliationBoolExp!]
  _not: ReconciliationBoolExp
  _or: [ReconciliationBoolExp!]
  createdAt: TimestamptzComparisonExp
  endDate: DateComparisonExp
  isAuto: BooleanComparisonExp
  startDate: DateComparisonExp
}

"""aggregate max on columns"""
type ReconciliationMaxFields {
  createdAt: timestamptz

  """

  End date till which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  endDate: date

  """

  Start date from which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  startDate: date
}

"""aggregate min on columns"""
type ReconciliationMinFields {
  createdAt: timestamptz

  """

  End date till which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  endDate: date

  """

  Start date from which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  startDate: date
}

"""
Ordering options when selecting data from "reconciliation.generated_report".
"""
input ReconciliationOrderBy {
  createdAt: OrderBy
  endDate: OrderBy
  isAuto: OrderBy
  startDate: OrderBy
}

"""URL for downloadable CSV reconciliation reports"""
type ReconciliationReportLink {
  createdAt: timestamptz!

  """

  End date till which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  endDate: date!

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String

  """This is the key that we send to query for the links."""
  id: bigint!

  """
  The Amazon S3 presigned URL shared with merchant for them to download the report.
  """
  link: String

  """

  Start date from which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  startDate: date!

  """The status of creating the presigned URL."""
  status: ReportLinkStatusEnum!
}

"""
Boolean expression to filter rows from the table "runtime.reconciliation_link". All fields are combined with a logical 'AND'.
"""
input ReconciliationReportLinkBoolExp {
  _and: [ReconciliationReportLinkBoolExp!]
  _not: ReconciliationReportLinkBoolExp
  _or: [ReconciliationReportLinkBoolExp!]
  createdAt: TimestamptzComparisonExp
  endDate: DateComparisonExp
  errMessage: StringComparisonExp
  id: BigintComparisonExp
  link: StringComparisonExp
  startDate: DateComparisonExp
  status: ReportLinkStatusEnumComparisonExp
}

"""
Ordering options when selecting data from "runtime.reconciliation_link".
"""
input ReconciliationReportLinkOrderBy {
  createdAt: OrderBy
  endDate: OrderBy
  errMessage: OrderBy
  id: OrderBy
  link: OrderBy
  startDate: OrderBy
  status: OrderBy
}

"""
select columns of table "runtime.reconciliation_link"
"""
enum ReconciliationReportLinkSelectColumn {
  """column name"""
  createdAt

  """column name"""
  endDate

  """column name"""
  errMessage

  """column name"""
  id

  """column name"""
  link

  """column name"""
  startDate

  """column name"""
  status
}

"""
select columns of table "reconciliation.generated_report"
"""
enum ReconciliationSelectColumn {
  """column name"""
  createdAt

  """column name"""
  endDate

  """column name"""
  isAuto

  """column name"""
  startDate
}

"""A transaction appearing on a reconciliation report"""
type ReconciliationTransaction {
  amount: bigint
  amountMajorUnits: numeric
  createdAt: timestamp
  id: String
  merchantReference: String
  paginationCursor: String
  transactionAcquirer: String
  transactionCurrency: String
  transactionType: String
}

"""
Boolean expression to filter rows from the table "reconciliation.transaction". All fields are combined with a logical 'AND'.
"""
input ReconciliationTransactionBoolExp {
  _and: [ReconciliationTransactionBoolExp!]
  _not: ReconciliationTransactionBoolExp
  _or: [ReconciliationTransactionBoolExp!]
  amount: BigintComparisonExp
  amountMajorUnits: NumericComparisonExp
  createdAt: TimestampComparisonExp
  id: StringComparisonExp
  merchantReference: StringComparisonExp
  paginationCursor: StringComparisonExp
  transactionAcquirer: StringComparisonExp
  transactionCurrency: StringComparisonExp
  transactionType: StringComparisonExp
}

"""
Ordering options when selecting data from "reconciliation.transaction".
"""
input ReconciliationTransactionOrderBy {
  amount: OrderBy
  amountMajorUnits: OrderBy
  createdAt: OrderBy
  id: OrderBy
  merchantReference: OrderBy
  paginationCursor: OrderBy
  transactionAcquirer: OrderBy
  transactionCurrency: OrderBy
  transactionType: OrderBy
}

"""
select columns of table "reconciliation.transaction"
"""
enum ReconciliationTransactionSelectColumn {
  """column name"""
  amount

  """column name"""
  amountMajorUnits

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  merchantReference

  """column name"""
  paginationCursor

  """column name"""
  transactionAcquirer

  """column name"""
  transactionCurrency

  """column name"""
  transactionType
}

"""A refund requested"""
type Refund {
  createdAt: timestamptz!
  createdBy: String
  errorMessage: String
  generatedFrom: String
  message: String!
  paymentId: bigint!

  """List of statuses the refund is currently on"""
  status(
    """distinct select on columns"""
    distinctOn: [CurrentRefundStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentRefundStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentRefundStatusBoolExp
  ): [CurrentRefundStatus!]

  """List of statuses the payment has been on"""
  statusHistory(
    """distinct select on columns"""
    distinctOn: [CurrentRefundStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentRefundStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentRefundStatusBoolExp
  ): [CurrentRefundStatus!]
  totalAmount: bigint!
  transactionId: String!

  """The ID corresponding to the refund"""
  waitToken: uuid!
}

"""
aggregated selection of "payment_gateway.refund"
"""
type RefundAggregate {
  aggregate: RefundAggregateFields
  nodes: [Refund!]!
}

input RefundAggregateBoolExp {
  count: RefundAggregateBoolExpCount
}

input RefundAggregateBoolExpCount {
  arguments: [RefundSelectColumn!]
  distinct: Boolean
  filter: RefundBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "payment_gateway.refund"
"""
type RefundAggregateFields {
  avg: RefundAvgFields
  count(columns: [RefundSelectColumn!], distinct: Boolean): Int!
  max: RefundMaxFields
  min: RefundMinFields
  stddev: RefundStddevFields
  stddevPop: RefundStddevPopFields
  stddevSamp: RefundStddevSampFields
  sum: RefundSumFields
  varPop: RefundVarPopFields
  varSamp: RefundVarSampFields
  variance: RefundVarianceFields
}

"""
order by aggregate values of table "payment_gateway.refund"
"""
input RefundAggregateOrderBy {
  avg: RefundAvgOrderBy
  count: OrderBy
  max: RefundMaxOrderBy
  min: RefundMinOrderBy
  stddev: RefundStddevOrderBy
  stddevPop: RefundStddevPopOrderBy
  stddevSamp: RefundStddevSampOrderBy
  sum: RefundSumOrderBy
  varPop: RefundVarPopOrderBy
  varSamp: RefundVarSampOrderBy
  variance: RefundVarianceOrderBy
}

"""aggregate avg on columns"""
type RefundAvgFields {
  paymentId: Float
  totalAmount: Float
}

"""
order by avg() on columns of table "payment_gateway.refund"
"""
input RefundAvgOrderBy {
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "payment_gateway.refund". All fields are combined with a logical 'AND'.
"""
input RefundBoolExp {
  _and: [RefundBoolExp!]
  _not: RefundBoolExp
  _or: [RefundBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: StringComparisonExp
  errorMessage: StringComparisonExp
  generatedFrom: StringComparisonExp
  message: StringComparisonExp
  paymentId: BigintComparisonExp
  status: CurrentRefundStatusBoolExp
  statusHistory: CurrentRefundStatusBoolExp
  totalAmount: BigintComparisonExp
  transactionId: StringComparisonExp
  waitToken: UuidComparisonExp
}

"""aggregate max on columns"""
type RefundMaxFields {
  createdAt: timestamptz
  createdBy: String
  errorMessage: String
  generatedFrom: String
  message: String
  paymentId: bigint
  totalAmount: bigint
  transactionId: String

  """The ID corresponding to the refund"""
  waitToken: uuid
}

"""
order by max() on columns of table "payment_gateway.refund"
"""
input RefundMaxOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  errorMessage: OrderBy
  generatedFrom: OrderBy
  message: OrderBy
  paymentId: OrderBy
  totalAmount: OrderBy
  transactionId: OrderBy

  """The ID corresponding to the refund"""
  waitToken: OrderBy
}

"""aggregate min on columns"""
type RefundMinFields {
  createdAt: timestamptz
  createdBy: String
  errorMessage: String
  generatedFrom: String
  message: String
  paymentId: bigint
  totalAmount: bigint
  transactionId: String

  """The ID corresponding to the refund"""
  waitToken: uuid
}

"""
order by min() on columns of table "payment_gateway.refund"
"""
input RefundMinOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  errorMessage: OrderBy
  generatedFrom: OrderBy
  message: OrderBy
  paymentId: OrderBy
  totalAmount: OrderBy
  transactionId: OrderBy

  """The ID corresponding to the refund"""
  waitToken: OrderBy
}

"""Ordering options when selecting data from "payment_gateway.refund"."""
input RefundOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  errorMessage: OrderBy
  generatedFrom: OrderBy
  message: OrderBy
  paymentId: OrderBy
  statusAggregate: CurrentRefundStatusAggregateOrderBy
  statusHistoryAggregate: CurrentRefundStatusAggregateOrderBy
  totalAmount: OrderBy
  transactionId: OrderBy
  waitToken: OrderBy
}

"""Arguments for performing a refund of a paid payment."""
input RefundPaymentInput {
  """
  The amount to be refunded in minor units.
  So 100,56 kr would be 10056
  """
  amount: Int!

  """
  Who is creating the refund.

  Max length: 100.
  """
  createdBy: String

  """
  Optional, where is the refund being created, will default to "Portal" when creating a refund from the kronor portal.

  Max length: 100.
  """
  generatedFrom: String

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  Optional, merchantReference has to be unique across all (non failed) refunds. An error will be returned if there's a collision.

  Max length: 100.
  """
  merchantReference: String

  """
  A message to show to the customer for the refund.
  Only alphanumeric, Swedish characters, and the following are allowed:
  - ':'
  - ';'
  - '.'
  - ','
  - '?'
  - '!'
  - '('
  - ')'
  - '”'
  - '"'
  - ' '

  Max length: 50.
  """
  message: String!

  """Generated id for the payment after a successful payment."""
  paymentId: bigint!
}

"""The result of performing a refund of a payment."""
type RefundPaymentResult {
  """
  Once a refund is initiated, you can use this waitToken to check the status of the refund.
  """
  waitToken: String!
}

"""
select columns of table "payment_gateway.refund"
"""
enum RefundSelectColumn {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  errorMessage

  """column name"""
  generatedFrom

  """column name"""
  message

  """column name"""
  paymentId

  """column name"""
  totalAmount

  """column name"""
  transactionId

  """column name"""
  waitToken
}

enum RefundStatusEnum {
  ERROR
  INITIALIZING
  PAID
  WAITING_FOR_REFUND
}

"""
Boolean expression to compare columns of type "RefundStatusEnum". All fields are combined with logical 'AND'.
"""
input RefundStatusEnumComparisonExp {
  _eq: RefundStatusEnum
  _in: [RefundStatusEnum!]
  _isNull: Boolean
  _neq: RefundStatusEnum
  _nin: [RefundStatusEnum!]
}

"""aggregate stddev on columns"""
type RefundStddevFields {
  paymentId: Float
  totalAmount: Float
}

"""
order by stddev() on columns of table "payment_gateway.refund"
"""
input RefundStddevOrderBy {
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""aggregate stddevPop on columns"""
type RefundStddevPopFields {
  paymentId: Float
  totalAmount: Float
}

"""
order by stddevPop() on columns of table "payment_gateway.refund"
"""
input RefundStddevPopOrderBy {
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""aggregate stddevSamp on columns"""
type RefundStddevSampFields {
  paymentId: Float
  totalAmount: Float
}

"""
order by stddevSamp() on columns of table "payment_gateway.refund"
"""
input RefundStddevSampOrderBy {
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""aggregate sum on columns"""
type RefundSumFields {
  paymentId: bigint
  totalAmount: bigint
}

"""
order by sum() on columns of table "payment_gateway.refund"
"""
input RefundSumOrderBy {
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""aggregate varPop on columns"""
type RefundVarPopFields {
  paymentId: Float
  totalAmount: Float
}

"""
order by varPop() on columns of table "payment_gateway.refund"
"""
input RefundVarPopOrderBy {
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""aggregate varSamp on columns"""
type RefundVarSampFields {
  paymentId: Float
  totalAmount: Float
}

"""
order by varSamp() on columns of table "payment_gateway.refund"
"""
input RefundVarSampOrderBy {
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""aggregate variance on columns"""
type RefundVarianceFields {
  paymentId: Float
  totalAmount: Float
}

"""
order by variance() on columns of table "payment_gateway.refund"
"""
input RefundVarianceOrderBy {
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""Arguments for performing a release of an uncaptured payment."""
input ReleasePaymentInput {
  """
  The amount to be released in minor units.
  So 100,56 kr would be 10056
  """
  amount: Int!

  """
  Who is releasing the payment.

  Max length: 100.
  """
  createdBy: String

  """
  Optional, where is the release being created, will default to "Portal" when releasing from the kronor portal.

  Max length: 100.
  """
  generatedFrom: String

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  Optional, merchantReference has to be unique across all (non failed) releases. An error will be returned if there's a collision.

  Max length: 100.
  """
  merchantReference: String

  """Generated id for the payment after a successful payment."""
  paymentId: bigint!
}

"""The result of performing a release of a payment."""
type ReleasePaymentResult {
  """The id of the release attempt."""
  releaseId: String!
}

"""Remove an user from merchant's pool."""
input RemoveUserInput {
  """List of users that should be removed."""
  removeUsers: [RemoveUserSingleInput!]!
}

"""Result of the remotion"""
type RemoveUserResult {
  """The number of users deleted."""
  usersDeleted: Int!
}

"""Remove users from merchant pool."""
input RemoveUserSingleInput {
  """Email of the user, for reference."""
  email: String!

  """
  One of "google", "password" or "webauthn", indicates the type of user to be remove.
  Max length: 64.
  """
  userType: String!
}

enum ReportLinkStatusEnum {
  """Link creation is done."""
  DONE

  """Something went wrong."""
  ERROR

  """Link been generated."""
  INITIALIZED
}

"""
Boolean expression to compare columns of type "ReportLinkStatusEnum". All fields are combined with logical 'AND'.
"""
input ReportLinkStatusEnumComparisonExp {
  _eq: ReportLinkStatusEnum
  _in: [ReportLinkStatusEnum!]
  _isNull: Boolean
  _neq: ReportLinkStatusEnum
  _nin: [ReportLinkStatusEnum!]
}

"""Log of successful mutations done via the API"""
type RequestLog {
  createdAt: timestamptz!
  idempotencyKey: String!
  namespace: String!
  requestParams(
    """JSON select path"""
    path: String
  ): jsonb!
  responseBody(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
Boolean expression to filter rows from the table "runtime.idempotency". All fields are combined with a logical 'AND'.
"""
input RequestLogBoolExp {
  _and: [RequestLogBoolExp!]
  _not: RequestLogBoolExp
  _or: [RequestLogBoolExp!]
  createdAt: TimestamptzComparisonExp
  idempotencyKey: StringComparisonExp
  namespace: StringComparisonExp
  requestParams: JsonbComparisonExp
  responseBody: JsonbComparisonExp
}

"""Ordering options when selecting data from "runtime.idempotency"."""
input RequestLogOrderBy {
  createdAt: OrderBy
  idempotencyKey: OrderBy
  namespace: OrderBy
  requestParams: OrderBy
  responseBody: OrderBy
}

"""
select columns of table "runtime.idempotency"
"""
enum RequestLogSelectColumn {
  """column name"""
  createdAt

  """column name"""
  idempotencyKey

  """column name"""
  namespace

  """column name"""
  requestParams

  """column name"""
  responseBody
}

"""Used to resend the invoice email"""
input ResendInvoiceEmailInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  Id of the invoice
  Max length: 64.
  """
  invoiceId: bigint!

  """
  Id of the purchase
  Max length: 64.
  """
  purchaseId: bigint!
}

"""The result of the email resend request."""
type ResendInvoiceEmailResult {
  """What happened with the email resent request."""
  result: Boolean!
}

"""Arguments need to recheck the payment status."""
input RestartPaymentStatusCheckInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """The payment to have its status rechecked."""
  paymentId: String!
}

"""The result of restarting a payment status check/polling."""
type RestartPaymentStatusCheckResult {
  """Result of the recheck attempt."""
  status: Boolean!
}

"""A group of items in a purchase that were returned by the customer"""
type Return {
  createdAt: timestamptz!
  id: bigint!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinctOn: [ReturnItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReturnItemOrderBy!]

    """filter the rows returned"""
    where: ReturnItemBoolExp
  ): [ReturnItem!]!
  purchaseId: bigint!

  """Any return fee imposed by the merchant on the customer."""
  returnFee: bigint!

  """Reason for returning the items as returned by the customer, if any"""
  returnReason: String

  """Total amount of the items in the return."""
  totalAmount: bigint!
}

"""
aggregated selection of "marketplace.purchase_return"
"""
type ReturnAggregate {
  aggregate: ReturnAggregateFields
  nodes: [Return!]!
}

input ReturnAggregateBoolExp {
  count: ReturnAggregateBoolExpCount
}

input ReturnAggregateBoolExpCount {
  arguments: [ReturnSelectColumn!]
  distinct: Boolean
  filter: ReturnBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "marketplace.purchase_return"
"""
type ReturnAggregateFields {
  avg: ReturnAvgFields
  count(columns: [ReturnSelectColumn!], distinct: Boolean): Int!
  max: ReturnMaxFields
  min: ReturnMinFields
  stddev: ReturnStddevFields
  stddevPop: ReturnStddevPopFields
  stddevSamp: ReturnStddevSampFields
  sum: ReturnSumFields
  varPop: ReturnVarPopFields
  varSamp: ReturnVarSampFields
  variance: ReturnVarianceFields
}

"""
order by aggregate values of table "marketplace.purchase_return"
"""
input ReturnAggregateOrderBy {
  avg: ReturnAvgOrderBy
  count: OrderBy
  max: ReturnMaxOrderBy
  min: ReturnMinOrderBy
  stddev: ReturnStddevOrderBy
  stddevPop: ReturnStddevPopOrderBy
  stddevSamp: ReturnStddevSampOrderBy
  sum: ReturnSumOrderBy
  varPop: ReturnVarPopOrderBy
  varSamp: ReturnVarSampOrderBy
  variance: ReturnVarianceOrderBy
}

"""aggregate avg on columns"""
type ReturnAvgFields {
  id: Float
  purchaseId: Float

  """Any return fee imposed by the merchant on the customer."""
  returnFee: Float

  """Total amount of the items in the return."""
  totalAmount: Float
}

"""
order by avg() on columns of table "marketplace.purchase_return"
"""
input ReturnAvgOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.purchase_return". All fields are combined with a logical 'AND'.
"""
input ReturnBoolExp {
  _and: [ReturnBoolExp!]
  _not: ReturnBoolExp
  _or: [ReturnBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  items: ReturnItemBoolExp
  purchaseId: BigintComparisonExp
  returnFee: BigintComparisonExp
  returnReason: StringComparisonExp
  totalAmount: BigintComparisonExp
}

"""An item in a purchase returned by the customer"""
type ReturnItem {
  id: bigint!

  """An object relationship"""
  item: PurchaseItem!

  """Individual price of each item as returned by the customer"""
  pricePerItem: bigint!
  purchaseId: bigint!
  purchaseReturnId: bigint!

  """Number of items returned by the customer."""
  quantity: Int!

  """
  Item identification either provided by the merchant as bar code or generated by us.
  """
  reference: citext!

  """Tax rate for the item returned by the customer"""
  taxRate: smallint!

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: bigint!

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: bigint!
}

"""
order by aggregate values of table "marketplace.purchase_return_item"
"""
input ReturnItemAggregateOrderBy {
  avg: ReturnItemAvgOrderBy
  count: OrderBy
  max: ReturnItemMaxOrderBy
  min: ReturnItemMinOrderBy
  stddev: ReturnItemStddevOrderBy
  stddevPop: ReturnItemStddevPopOrderBy
  stddevSamp: ReturnItemStddevSampOrderBy
  sum: ReturnItemSumOrderBy
  varPop: ReturnItemVarPopOrderBy
  varSamp: ReturnItemVarSampOrderBy
  variance: ReturnItemVarianceOrderBy
}

"""
order by avg() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemAvgOrderBy {
  id: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.purchase_return_item". All fields are combined with a logical 'AND'.
"""
input ReturnItemBoolExp {
  _and: [ReturnItemBoolExp!]
  _not: ReturnItemBoolExp
  _or: [ReturnItemBoolExp!]
  id: BigintComparisonExp
  item: PurchaseItemBoolExp
  pricePerItem: BigintComparisonExp
  purchaseId: BigintComparisonExp
  purchaseReturnId: BigintComparisonExp
  quantity: IntComparisonExp
  reference: CitextComparisonExp
  taxRate: SmallintComparisonExp
  totalAmount: BigintComparisonExp
  totalTaxAmount: BigintComparisonExp
}

"""
order by max() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemMaxOrderBy {
  id: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """
  Item identification either provided by the merchant as bar code or generated by us.
  """
  reference: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
order by min() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemMinOrderBy {
  id: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """
  Item identification either provided by the merchant as bar code or generated by us.
  """
  reference: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
Ordering options when selecting data from "marketplace.purchase_return_item".
"""
input ReturnItemOrderBy {
  id: OrderBy
  item: PurchaseItemOrderBy
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy
  quantity: OrderBy
  reference: OrderBy
  taxRate: OrderBy
  totalAmount: OrderBy
  totalTaxAmount: OrderBy
}

"""
select columns of table "marketplace.purchase_return_item"
"""
enum ReturnItemSelectColumn {
  """column name"""
  id

  """column name"""
  pricePerItem

  """column name"""
  purchaseId

  """column name"""
  purchaseReturnId

  """column name"""
  quantity

  """column name"""
  reference

  """column name"""
  taxRate

  """column name"""
  totalAmount

  """column name"""
  totalTaxAmount
}

"""
order by stddev() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemStddevOrderBy {
  id: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
order by stddevPop() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemStddevPopOrderBy {
  id: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
order by stddevSamp() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemStddevSampOrderBy {
  id: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
order by sum() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemSumOrderBy {
  id: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
order by varPop() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemVarPopOrderBy {
  id: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
order by varSamp() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemVarSampOrderBy {
  id: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""
order by variance() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemVarianceOrderBy {
  id: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """

  Total tax amount on all the items of this type in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.

  """
  totalTaxAmount: OrderBy
}

"""aggregate max on columns"""
type ReturnMaxFields {
  createdAt: timestamptz
  id: bigint
  purchaseId: bigint

  """Any return fee imposed by the merchant on the customer."""
  returnFee: bigint

  """Reason for returning the items as returned by the customer, if any"""
  returnReason: String

  """Total amount of the items in the return."""
  totalAmount: bigint
}

"""
order by max() on columns of table "marketplace.purchase_return"
"""
input ReturnMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Reason for returning the items as returned by the customer, if any"""
  returnReason: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""aggregate min on columns"""
type ReturnMinFields {
  createdAt: timestamptz
  id: bigint
  purchaseId: bigint

  """Any return fee imposed by the merchant on the customer."""
  returnFee: bigint

  """Reason for returning the items as returned by the customer, if any"""
  returnReason: String

  """Total amount of the items in the return."""
  totalAmount: bigint
}

"""
order by min() on columns of table "marketplace.purchase_return"
"""
input ReturnMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Reason for returning the items as returned by the customer, if any"""
  returnReason: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""
Ordering options when selecting data from "marketplace.purchase_return".
"""
input ReturnOrderBy {
  createdAt: OrderBy
  id: OrderBy
  itemsAggregate: ReturnItemAggregateOrderBy
  purchaseId: OrderBy
  returnFee: OrderBy
  returnReason: OrderBy
  totalAmount: OrderBy
}

"""
select columns of table "marketplace.purchase_return"
"""
enum ReturnSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  purchaseId

  """column name"""
  returnFee

  """column name"""
  returnReason

  """column name"""
  totalAmount
}

"""aggregate stddev on columns"""
type ReturnStddevFields {
  id: Float
  purchaseId: Float

  """Any return fee imposed by the merchant on the customer."""
  returnFee: Float

  """Total amount of the items in the return."""
  totalAmount: Float
}

"""
order by stddev() on columns of table "marketplace.purchase_return"
"""
input ReturnStddevOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""aggregate stddevPop on columns"""
type ReturnStddevPopFields {
  id: Float
  purchaseId: Float

  """Any return fee imposed by the merchant on the customer."""
  returnFee: Float

  """Total amount of the items in the return."""
  totalAmount: Float
}

"""
order by stddevPop() on columns of table "marketplace.purchase_return"
"""
input ReturnStddevPopOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""aggregate stddevSamp on columns"""
type ReturnStddevSampFields {
  id: Float
  purchaseId: Float

  """Any return fee imposed by the merchant on the customer."""
  returnFee: Float

  """Total amount of the items in the return."""
  totalAmount: Float
}

"""
order by stddevSamp() on columns of table "marketplace.purchase_return"
"""
input ReturnStddevSampOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""aggregate sum on columns"""
type ReturnSumFields {
  id: bigint
  purchaseId: bigint

  """Any return fee imposed by the merchant on the customer."""
  returnFee: bigint

  """Total amount of the items in the return."""
  totalAmount: bigint
}

"""
order by sum() on columns of table "marketplace.purchase_return"
"""
input ReturnSumOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""aggregate varPop on columns"""
type ReturnVarPopFields {
  id: Float
  purchaseId: Float

  """Any return fee imposed by the merchant on the customer."""
  returnFee: Float

  """Total amount of the items in the return."""
  totalAmount: Float
}

"""
order by varPop() on columns of table "marketplace.purchase_return"
"""
input ReturnVarPopOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""aggregate varSamp on columns"""
type ReturnVarSampFields {
  id: Float
  purchaseId: Float

  """Any return fee imposed by the merchant on the customer."""
  returnFee: Float

  """Total amount of the items in the return."""
  totalAmount: Float
}

"""
order by varSamp() on columns of table "marketplace.purchase_return"
"""
input ReturnVarSampOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""aggregate variance on columns"""
type ReturnVarianceFields {
  id: Float
  purchaseId: Float

  """Any return fee imposed by the merchant on the customer."""
  returnFee: Float

  """Total amount of the items in the return."""
  totalAmount: Float
}

"""
order by variance() on columns of table "marketplace.purchase_return"
"""
input ReturnVarianceOrderBy {
  id: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""
Once a notification is sent to this URL, the server must respond with
the string `[accepted]` within 10 seconds to acknowledge the webhook.

Otherwise, the notification will be retried at a later time and all
future notifications will be queued until they can get properly
acknowledged.
"""
input SetWebhookUrlInput {
  """
  URL to which the webhook notifications will be sent

  Max length: 1000.
  """
  webhookUrl: String!
}

"""The result of setting a webhook URL."""
type SetWebhookUrlResult {
  """The secret used to sign webhook requests with HMAC"""
  hmacSecret: String!

  """URL to which the webhook notifications will be sent"""
  webhookUrl: String!
}

"""List of generated reports given a date range"""
type Settlement {
  createdAt: timestamptz!

  """

  End date till which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  endDate: date!
  isAuto: Boolean!

  """

  Start date from which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  startDate: date!
}

"""
aggregated selection of "settlement.generated_report"
"""
type SettlementAggregate {
  aggregate: SettlementAggregateFields
  nodes: [Settlement!]!
}

"""
aggregate fields of "settlement.generated_report"
"""
type SettlementAggregateFields {
  count(columns: [SettlementSelectColumn!], distinct: Boolean): Int!
  max: SettlementMaxFields
  min: SettlementMinFields
}

"""
Boolean expression to filter rows from the table "settlement.generated_report". All fields are combined with a logical 'AND'.
"""
input SettlementBoolExp {
  _and: [SettlementBoolExp!]
  _not: SettlementBoolExp
  _or: [SettlementBoolExp!]
  createdAt: TimestamptzComparisonExp
  endDate: DateComparisonExp
  isAuto: BooleanComparisonExp
  startDate: DateComparisonExp
}

"""aggregate max on columns"""
type SettlementMaxFields {
  createdAt: timestamptz

  """

  End date till which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  endDate: date

  """

  Start date from which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  startDate: date
}

"""aggregate min on columns"""
type SettlementMinFields {
  createdAt: timestamptz

  """

  End date till which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  endDate: date

  """

  Start date from which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  startDate: date
}

"""
Ordering options when selecting data from "settlement.generated_report".
"""
input SettlementOrderBy {
  createdAt: OrderBy
  endDate: OrderBy
  isAuto: OrderBy
  startDate: OrderBy
}

"""URL for downloadable CSV settlement reports"""
type SettlementReportLink {
  createdAt: timestamptz!

  """

  End date till which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  endDate: date!

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String

  """This is the key that we send to query for the links."""
  id: bigint!

  """
  The Amazon S3 presigned URL shared with merchant for them to download the report.
  """
  link: String

  """

  Start date from which the reports are generated.
  For daily reports the 'start_date' and 'end_date' are the same.

  """
  startDate: date!

  """The status of creating the presigned URL."""
  status: ReportLinkStatusEnum!
}

"""
Boolean expression to filter rows from the table "runtime.report_link". All fields are combined with a logical 'AND'.
"""
input SettlementReportLinkBoolExp {
  _and: [SettlementReportLinkBoolExp!]
  _not: SettlementReportLinkBoolExp
  _or: [SettlementReportLinkBoolExp!]
  createdAt: TimestamptzComparisonExp
  endDate: DateComparisonExp
  errMessage: StringComparisonExp
  id: BigintComparisonExp
  link: StringComparisonExp
  startDate: DateComparisonExp
  status: ReportLinkStatusEnumComparisonExp
}

"""Ordering options when selecting data from "runtime.report_link"."""
input SettlementReportLinkOrderBy {
  createdAt: OrderBy
  endDate: OrderBy
  errMessage: OrderBy
  id: OrderBy
  link: OrderBy
  startDate: OrderBy
  status: OrderBy
}

"""
select columns of table "runtime.report_link"
"""
enum SettlementReportLinkSelectColumn {
  """column name"""
  createdAt

  """column name"""
  endDate

  """column name"""
  errMessage

  """column name"""
  id

  """column name"""
  link

  """column name"""
  startDate

  """column name"""
  status
}

"""
select columns of table "settlement.generated_report"
"""
enum SettlementSelectColumn {
  """column name"""
  createdAt

  """column name"""
  endDate

  """column name"""
  isAuto

  """column name"""
  startDate
}

"""An aggregated summary of transactions appearing on a settlement report"""
type SettlementSummary {
  currency: currency!

  """The sum of all transactions for the given type"""
  total: bigint!

  """The type of recorded transaction"""
  type: citext!
}

"""
Boolean expression to filter rows from the table "settlement.summary". All fields are combined with a logical 'AND'.
"""
input SettlementSummaryBoolExp {
  _and: [SettlementSummaryBoolExp!]
  _not: SettlementSummaryBoolExp
  _or: [SettlementSummaryBoolExp!]
  currency: CurrencyComparisonExp
  total: BigintComparisonExp
  type: CitextComparisonExp
}

"""Ordering options when selecting data from "settlement.summary"."""
input SettlementSummaryOrderBy {
  currency: OrderBy
  total: OrderBy
  type: OrderBy
}

"""
select columns of table "settlement.summary"
"""
enum SettlementSummarySelectColumn {
  """column name"""
  currency

  """column name"""
  total

  """column name"""
  type
}

"""A transaction appearing on a settlement report"""
type SettlementTransaction {
  currency: currency!

  """Date of the recorded transaction"""
  date: date!

  """The purchase reference as provided by the merchant"""
  merchantReference: String

  """An opaque string representing the next page of transactions to fetch"""
  paginationCursor: String!

  """Sum of all transactions of the same type per order"""
  total: bigint!

  """Transaction type"""
  type: citext!
}

"""
Boolean expression to filter rows from the table "settlement.transaction". All fields are combined with a logical 'AND'.
"""
input SettlementTransactionBoolExp {
  _and: [SettlementTransactionBoolExp!]
  _not: SettlementTransactionBoolExp
  _or: [SettlementTransactionBoolExp!]
  currency: CurrencyComparisonExp
  date: DateComparisonExp
  merchantReference: StringComparisonExp
  paginationCursor: StringComparisonExp
  total: BigintComparisonExp
  type: CitextComparisonExp
}

"""Ordering options when selecting data from "settlement.transaction"."""
input SettlementTransactionOrderBy {
  currency: OrderBy
  date: OrderBy
  merchantReference: OrderBy
  paginationCursor: OrderBy
  total: OrderBy
  type: OrderBy
}

"""
select columns of table "settlement.transaction"
"""
enum SettlementTransactionSelectColumn {
  """column name"""
  currency

  """column name"""
  date

  """column name"""
  merchantReference

  """column name"""
  paginationCursor

  """column name"""
  total

  """column name"""
  type
}

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input SmallintComparisonExp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _isNull: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"""
Boolean expression to compare columns of type "spoken_lang". All fields are combined with logical 'AND'.
"""
input SpokenLangComparisonExp {
  _eq: spoken_lang
  _gt: spoken_lang
  _gte: spoken_lang
  _in: [spoken_lang!]
  _isNull: Boolean
  _lt: spoken_lang
  _lte: spoken_lang
  _neq: spoken_lang
  _nin: [spoken_lang!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""Webhooks that have been successfully received by merchants"""
type SuccessfulWebhookNotification {
  event: String

  """Same id as in the job_queue.pending_webhook_notification table"""
  id: bigint!
  payload(
    """JSON select path"""
    path: String
  ): jsonb!
  paymentId: bigint
  paymentRequestId: uuid
  purchaseId: bigint

  """When the job_queue.pending_webhook_notification was created_at"""
  queuedAt: timestamptz!
  refundId: uuid
  sentAt: timestamptz!
  webhookUrl: String!
}

"""
aggregated selection of "runtime.successful_webhook_notification"
"""
type SuccessfulWebhookNotificationAggregate {
  aggregate: SuccessfulWebhookNotificationAggregateFields
  nodes: [SuccessfulWebhookNotification!]!
}

"""
aggregate fields of "runtime.successful_webhook_notification"
"""
type SuccessfulWebhookNotificationAggregateFields {
  avg: SuccessfulWebhookNotificationAvgFields
  count(columns: [SuccessfulWebhookNotificationSelectColumn!], distinct: Boolean): Int!
  max: SuccessfulWebhookNotificationMaxFields
  min: SuccessfulWebhookNotificationMinFields
  stddev: SuccessfulWebhookNotificationStddevFields
  stddevPop: SuccessfulWebhookNotificationStddevPopFields
  stddevSamp: SuccessfulWebhookNotificationStddevSampFields
  sum: SuccessfulWebhookNotificationSumFields
  varPop: SuccessfulWebhookNotificationVarPopFields
  varSamp: SuccessfulWebhookNotificationVarSampFields
  variance: SuccessfulWebhookNotificationVarianceFields
}

"""aggregate avg on columns"""
type SuccessfulWebhookNotificationAvgFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: Float
  paymentId: Float
  purchaseId: Float
}

"""
Boolean expression to filter rows from the table "runtime.successful_webhook_notification". All fields are combined with a logical 'AND'.
"""
input SuccessfulWebhookNotificationBoolExp {
  _and: [SuccessfulWebhookNotificationBoolExp!]
  _not: SuccessfulWebhookNotificationBoolExp
  _or: [SuccessfulWebhookNotificationBoolExp!]
  event: StringComparisonExp
  id: BigintComparisonExp
  payload: JsonbComparisonExp
  paymentId: BigintComparisonExp
  paymentRequestId: UuidComparisonExp
  purchaseId: BigintComparisonExp
  queuedAt: TimestamptzComparisonExp
  refundId: UuidComparisonExp
  sentAt: TimestamptzComparisonExp
  webhookUrl: StringComparisonExp
}

"""aggregate max on columns"""
type SuccessfulWebhookNotificationMaxFields {
  event: String

  """Same id as in the job_queue.pending_webhook_notification table"""
  id: bigint
  paymentId: bigint
  paymentRequestId: uuid
  purchaseId: bigint

  """When the job_queue.pending_webhook_notification was created_at"""
  queuedAt: timestamptz
  refundId: uuid
  sentAt: timestamptz
  webhookUrl: String
}

"""aggregate min on columns"""
type SuccessfulWebhookNotificationMinFields {
  event: String

  """Same id as in the job_queue.pending_webhook_notification table"""
  id: bigint
  paymentId: bigint
  paymentRequestId: uuid
  purchaseId: bigint

  """When the job_queue.pending_webhook_notification was created_at"""
  queuedAt: timestamptz
  refundId: uuid
  sentAt: timestamptz
  webhookUrl: String
}

"""
Ordering options when selecting data from "runtime.successful_webhook_notification".
"""
input SuccessfulWebhookNotificationOrderBy {
  event: OrderBy
  id: OrderBy
  payload: OrderBy
  paymentId: OrderBy
  paymentRequestId: OrderBy
  purchaseId: OrderBy
  queuedAt: OrderBy
  refundId: OrderBy
  sentAt: OrderBy
  webhookUrl: OrderBy
}

"""
select columns of table "runtime.successful_webhook_notification"
"""
enum SuccessfulWebhookNotificationSelectColumn {
  """column name"""
  event

  """column name"""
  id

  """column name"""
  payload

  """column name"""
  paymentId

  """column name"""
  paymentRequestId

  """column name"""
  purchaseId

  """column name"""
  queuedAt

  """column name"""
  refundId

  """column name"""
  sentAt

  """column name"""
  webhookUrl
}

"""aggregate stddev on columns"""
type SuccessfulWebhookNotificationStddevFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: Float
  paymentId: Float
  purchaseId: Float
}

"""aggregate stddevPop on columns"""
type SuccessfulWebhookNotificationStddevPopFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: Float
  paymentId: Float
  purchaseId: Float
}

"""aggregate stddevSamp on columns"""
type SuccessfulWebhookNotificationStddevSampFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: Float
  paymentId: Float
  purchaseId: Float
}

"""aggregate sum on columns"""
type SuccessfulWebhookNotificationSumFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: bigint
  paymentId: bigint
  purchaseId: bigint
}

"""aggregate varPop on columns"""
type SuccessfulWebhookNotificationVarPopFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: Float
  paymentId: Float
  purchaseId: Float
}

"""aggregate varSamp on columns"""
type SuccessfulWebhookNotificationVarSampFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: Float
  paymentId: Float
  purchaseId: Float
}

"""aggregate variance on columns"""
type SuccessfulWebhookNotificationVarianceFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: Float
  paymentId: Float
  purchaseId: Float
}

"""Arguments for creating a new PayPal payment"""
input SupplyPayPalPaymentMethodIdInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  The payment id of a PayPal payment, this is obtained when a
  payment request is made. As opposed to a payment_reference which
  is the same across multiple payment attempts, this is unique
  only for each specific payment.

  Max length: 64.
  """
  paymentId: String!

  """
  This is obtained from Braintree when you use their client SDK to
  create a payment.

  Max length: 64.
  """
  paymentMethodId: String!
}

"""
The result of supplying a PayPal paymentMethodId to a PayPal
payment.
"""
type SupplyPayPalPaymentMethodIdResult {
  """
  Once a payment is initialized, we will start the PayPal payment
  workflow. You can use this id to query the current status of the
  payment.
  """
  paymentId: String!
}

enum SupportedCurrencyEnum {
  """Swiss Franc, the currency of Switzerland"""
  CHF

  """Czech Koruna, the currency of the Czech Republic"""
  CZK

  """Danish Krone, currency of Denmark"""
  DKK

  """Euro, Currency for the states in Eurozone"""
  EUR

  """Hungarian Forint, the currency of Hungary"""
  HUF

  """Icelandic Krona, currency of Iceland"""
  ISK

  """Norwegian Krone, currency of Norway"""
  NOK

  """Polish Zloty, currency of Poland"""
  PLN

  """Romanian Leu, the currency of Romania"""
  RON

  """Swedish Krona, currency of Sweden"""
  SEK
}

"""
Boolean expression to compare columns of type "SupportedCurrencyEnum". All fields are combined with logical 'AND'.
"""
input SupportedCurrencyEnumComparisonExp {
  _eq: SupportedCurrencyEnum
  _in: [SupportedCurrencyEnum!]
  _isNull: Boolean
  _neq: SupportedCurrencyEnum
  _nin: [SupportedCurrencyEnum!]
}

"""Additional fee on a purchase after it was captured"""
type Surcharge {
  """Amount of surcharge."""
  amount: bigint!
  createdAt: timestamptz!
  id: bigint!

  """

  Type of surcharge charged which is one of return_fee, reminder_fee, interest.

  """
  surchargeType: SurchargeTypeEnum!
}

"""
order by aggregate values of table "marketplace.surcharge"
"""
input SurchargeAggregateOrderBy {
  avg: SurchargeAvgOrderBy
  count: OrderBy
  max: SurchargeMaxOrderBy
  min: SurchargeMinOrderBy
  stddev: SurchargeStddevOrderBy
  stddevPop: SurchargeStddevPopOrderBy
  stddevSamp: SurchargeStddevSampOrderBy
  sum: SurchargeSumOrderBy
  varPop: SurchargeVarPopOrderBy
  varSamp: SurchargeVarSampOrderBy
  variance: SurchargeVarianceOrderBy
}

"""
order by avg() on columns of table "marketplace.surcharge"
"""
input SurchargeAvgOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  id: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.surcharge". All fields are combined with a logical 'AND'.
"""
input SurchargeBoolExp {
  _and: [SurchargeBoolExp!]
  _not: SurchargeBoolExp
  _or: [SurchargeBoolExp!]
  amount: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  surchargeType: SurchargeTypeEnumComparisonExp
}

"""
order by max() on columns of table "marketplace.surcharge"
"""
input SurchargeMaxOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  createdAt: OrderBy
  id: OrderBy
}

"""
order by min() on columns of table "marketplace.surcharge"
"""
input SurchargeMinOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  createdAt: OrderBy
  id: OrderBy
}

"""Ordering options when selecting data from "marketplace.surcharge"."""
input SurchargeOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  id: OrderBy
  surchargeType: OrderBy
}

"""
select columns of table "marketplace.surcharge"
"""
enum SurchargeSelectColumn {
  """column name"""
  amount

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  surchargeType
}

"""
order by stddev() on columns of table "marketplace.surcharge"
"""
input SurchargeStddevOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  id: OrderBy
}

"""
order by stddevPop() on columns of table "marketplace.surcharge"
"""
input SurchargeStddevPopOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  id: OrderBy
}

"""
order by stddevSamp() on columns of table "marketplace.surcharge"
"""
input SurchargeStddevSampOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  id: OrderBy
}

"""
order by sum() on columns of table "marketplace.surcharge"
"""
input SurchargeSumOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  id: OrderBy
}

enum SurchargeTypeEnum {
  """Interest added as per contract."""
  INTEREST

  """Fee for missed payments."""
  REMINDER_FEE

  """Fee for returning items."""
  RETURN_FEE

  """Our fee for providing the service."""
  SERVICE_FEE
}

"""
Boolean expression to compare columns of type "SurchargeTypeEnum". All fields are combined with logical 'AND'.
"""
input SurchargeTypeEnumComparisonExp {
  _eq: SurchargeTypeEnum
  _in: [SurchargeTypeEnum!]
  _isNull: Boolean
  _neq: SurchargeTypeEnum
  _nin: [SurchargeTypeEnum!]
}

"""
order by varPop() on columns of table "marketplace.surcharge"
"""
input SurchargeVarPopOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  id: OrderBy
}

"""
order by varSamp() on columns of table "marketplace.surcharge"
"""
input SurchargeVarSampOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  id: OrderBy
}

"""
order by variance() on columns of table "marketplace.surcharge"
"""
input SurchargeVarianceOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  id: OrderBy
}

"""
Describes the schema for the swish payment transaction details to be used by hasura
"""
type SwishDetails {
  """A reference sent from the bank once the payment has been made"""
  bankPaymentReference: String

  """The swish number of the customer"""
  customerSwishNumber: packed_phone_number

  """Date when the payment is created in SWISH"""
  dateCreated: timestamptz

  """Date when SWISH received the payment"""
  datePaid: timestamptz

  """Error code from swish"""
  errorCode: String

  """Error message from swish"""
  errorMessage: String
}

"""
order by aggregate values of table "runtime.transaction_swish_details"
"""
input SwishDetailsAggregateOrderBy {
  count: OrderBy
  max: SwishDetailsMaxOrderBy
  min: SwishDetailsMinOrderBy
}

"""
Boolean expression to filter rows from the table "runtime.transaction_swish_details". All fields are combined with a logical 'AND'.
"""
input SwishDetailsBoolExp {
  _and: [SwishDetailsBoolExp!]
  _not: SwishDetailsBoolExp
  _or: [SwishDetailsBoolExp!]
  bankPaymentReference: StringComparisonExp
  customerSwishNumber: PackedPhoneNumberComparisonExp
  dateCreated: TimestamptzComparisonExp
  datePaid: TimestamptzComparisonExp
  errorCode: StringComparisonExp
  errorMessage: StringComparisonExp
}

"""
order by max() on columns of table "runtime.transaction_swish_details"
"""
input SwishDetailsMaxOrderBy {
  """A reference sent from the bank once the payment has been made"""
  bankPaymentReference: OrderBy

  """Date when the payment is created in SWISH"""
  dateCreated: OrderBy

  """Date when SWISH received the payment"""
  datePaid: OrderBy

  """Error code from swish"""
  errorCode: OrderBy

  """Error message from swish"""
  errorMessage: OrderBy
}

"""
order by min() on columns of table "runtime.transaction_swish_details"
"""
input SwishDetailsMinOrderBy {
  """A reference sent from the bank once the payment has been made"""
  bankPaymentReference: OrderBy

  """Date when the payment is created in SWISH"""
  dateCreated: OrderBy

  """Date when SWISH received the payment"""
  datePaid: OrderBy

  """Error code from swish"""
  errorCode: OrderBy

  """Error message from swish"""
  errorMessage: OrderBy
}

"""
Ordering options when selecting data from "runtime.transaction_swish_details".
"""
input SwishDetailsOrderBy {
  bankPaymentReference: OrderBy
  customerSwishNumber: OrderBy
  dateCreated: OrderBy
  datePaid: OrderBy
  errorCode: OrderBy
  errorMessage: OrderBy
}

"""
select columns of table "runtime.transaction_swish_details"
"""
enum SwishDetailsSelectColumn {
  """column name"""
  bankPaymentReference

  """column name"""
  customerSwishNumber

  """column name"""
  dateCreated

  """column name"""
  datePaid

  """column name"""
  errorCode

  """column name"""
  errorMessage
}

"""Arguments for cancelling a swish payment"""
input SwishPaymentCancelInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  The payment id to cancel, this is obtained when a payment
  request is made. As opposed to a payment_reference which is
  the same across multiple payment attempts, this is unique only
  for each specific payment.

  Max length: 64.
  """
  paymentId: String!

  """
  The payment reference to cancel, this is obtained before we decide
  to make a payment, i.e. when we create a payment session.
  """
  paymentReference: String!
}

"""The result of cancelling a swish payment request."""
type SwishPaymentCancelResult {
  """
  The returned token can be used to query whether the payment has
  been cancelled or not.
  """
  waitToken: String!
}

"""Arguments for creating a new swish payment"""
input SwishPaymentInput {
  """
  The amount the customer pays in minor units.
  So 100,56 kr would be 10056.
  Amount should be between 1 and 999,99,99
  """
  amount: Int!

  """The Swish number of the customer, required for the 'ecom' flow"""
  customerSwishNumber: String

  """
  Payment flow, either 'ecom' or 'mcom'

  Max length: 64.
  """
  flow: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"

  Max length: 64.
  """
  idempotencyKey: String!

  """
  Merchant's own internal reference that may help the
  merchant in identifying this payment. These have to
  be globally unique but they should be reused for retrying
  a payment.

  Max length: 64.
  """
  merchantReference: String!

  """
  A message to show to the customer on their swish payment screen.
  It could be an order id or a reference.

  Max length: 50.
  """
  message: String!

  """
  Our system's own internal reference that can be used uniquely
  in identifying this payment.
  """
  paymentReference: String!

  """The url to return to after the payment is done."""
  returnUrl: String!
}

"""The result of initiating a swish payment."""
type SwishPaymentResult {
  """
  Once a payment is initialized, we will start the swish payment
  workflow. You can use this token to query the current status
  of the payment.
  """
  waitToken: String!
}

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input TimestampComparisonExp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _isNull: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""Toggle if a payment method should be available to use"""
input TogglePaymentMethodAvailabilityInput {
  """
  Payment method in the country where it should be enabled/disabled.
  Example: `Sweden`, `Denmark`, `Norway`, `Iceland`, `Finland`
  """
  country: Country!

  """The payment method to enable/disable"""
  paymentMethod: PaymentRequestMethod!

  """Whether or not the payment method should be enabled"""
  shouldBeEnabled: Boolean!
}

"""The result of a togglePaymentMethodAvailability mutation."""
type TogglePaymentMethodAvailabilityResult {
  """Whether or not the payment method is enabled after the mutation"""
  enabled: Boolean!
}

"""
In tenant.tokens we have roles of type text[], but hasura does not likes arrays, so we turn it into a json array here
"""
type Tokens {
  blocked: Boolean
  expirationDate: timestamptz
  merchantId: bigint
  roles(
    """JSON select path"""
    path: String
  ): jsonb
  tokenId: uuid
  tokenName: String
}

"""
Boolean expression to filter rows from the table "tenant.tokens_view". All fields are combined with a logical 'AND'.
"""
input TokensBoolExp {
  _and: [TokensBoolExp!]
  _not: TokensBoolExp
  _or: [TokensBoolExp!]
  blocked: BooleanComparisonExp
  expirationDate: TimestamptzComparisonExp
  merchantId: BigintComparisonExp
  roles: JsonbComparisonExp
  tokenId: UuidComparisonExp
  tokenName: StringComparisonExp
}

"""Ordering options when selecting data from "tenant.tokens_view"."""
input TokensOrderBy {
  blocked: OrderBy
  expirationDate: OrderBy
  merchantId: OrderBy
  roles: OrderBy
  tokenId: OrderBy
  tokenName: OrderBy
}

"""
select columns of table "tenant.tokens_view"
"""
enum TokensSelectColumn {
  """column name"""
  blocked

  """column name"""
  expirationDate

  """column name"""
  merchantId

  """column name"""
  roles

  """column name"""
  tokenId

  """column name"""
  tokenName
}

"""A transaction release requested"""
type TransactionRelease {
  amount: bigint!
  createdAt: timestamptz!
  createdBy: String
  currentStatus: TransactionReleaseStatusEnum!
  id: bigint!
  paymentId: bigint!

  """List of statuses the transaction release has been in"""
  statusHistory(
    """distinct select on columns"""
    distinctOn: [CurrentTransactionReleaseStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentTransactionReleaseStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentTransactionReleaseStatusBoolExp
  ): [CurrentTransactionReleaseStatus!]
}

"""
aggregated selection of "payment_gateway.transaction_release"
"""
type TransactionReleaseAggregate {
  aggregate: TransactionReleaseAggregateFields
  nodes: [TransactionRelease!]!
}

input TransactionReleaseAggregateBoolExp {
  count: TransactionReleaseAggregateBoolExpCount
}

input TransactionReleaseAggregateBoolExpCount {
  arguments: [TransactionReleaseSelectColumn!]
  distinct: Boolean
  filter: TransactionReleaseBoolExp
  predicate: IntComparisonExp!
}

"""
aggregate fields of "payment_gateway.transaction_release"
"""
type TransactionReleaseAggregateFields {
  avg: TransactionReleaseAvgFields
  count(columns: [TransactionReleaseSelectColumn!], distinct: Boolean): Int!
  max: TransactionReleaseMaxFields
  min: TransactionReleaseMinFields
  stddev: TransactionReleaseStddevFields
  stddevPop: TransactionReleaseStddevPopFields
  stddevSamp: TransactionReleaseStddevSampFields
  sum: TransactionReleaseSumFields
  varPop: TransactionReleaseVarPopFields
  varSamp: TransactionReleaseVarSampFields
  variance: TransactionReleaseVarianceFields
}

"""
order by aggregate values of table "payment_gateway.transaction_release"
"""
input TransactionReleaseAggregateOrderBy {
  avg: TransactionReleaseAvgOrderBy
  count: OrderBy
  max: TransactionReleaseMaxOrderBy
  min: TransactionReleaseMinOrderBy
  stddev: TransactionReleaseStddevOrderBy
  stddevPop: TransactionReleaseStddevPopOrderBy
  stddevSamp: TransactionReleaseStddevSampOrderBy
  sum: TransactionReleaseSumOrderBy
  varPop: TransactionReleaseVarPopOrderBy
  varSamp: TransactionReleaseVarSampOrderBy
  variance: TransactionReleaseVarianceOrderBy
}

"""aggregate avg on columns"""
type TransactionReleaseAvgFields {
  amount: Float
  id: Float
  paymentId: Float
}

"""
order by avg() on columns of table "payment_gateway.transaction_release"
"""
input TransactionReleaseAvgOrderBy {
  amount: OrderBy
  id: OrderBy
  paymentId: OrderBy
}

"""
Boolean expression to filter rows from the table "payment_gateway.transaction_release". All fields are combined with a logical 'AND'.
"""
input TransactionReleaseBoolExp {
  _and: [TransactionReleaseBoolExp!]
  _not: TransactionReleaseBoolExp
  _or: [TransactionReleaseBoolExp!]
  amount: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  createdBy: StringComparisonExp
  currentStatus: TransactionReleaseStatusEnumComparisonExp
  id: BigintComparisonExp
  paymentId: BigintComparisonExp
  statusHistory: CurrentTransactionReleaseStatusBoolExp
}

"""aggregate max on columns"""
type TransactionReleaseMaxFields {
  amount: bigint
  createdAt: timestamptz
  createdBy: String
  id: bigint
  paymentId: bigint
}

"""
order by max() on columns of table "payment_gateway.transaction_release"
"""
input TransactionReleaseMaxOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  id: OrderBy
  paymentId: OrderBy
}

"""aggregate min on columns"""
type TransactionReleaseMinFields {
  amount: bigint
  createdAt: timestamptz
  createdBy: String
  id: bigint
  paymentId: bigint
}

"""
order by min() on columns of table "payment_gateway.transaction_release"
"""
input TransactionReleaseMinOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  id: OrderBy
  paymentId: OrderBy
}

"""
Ordering options when selecting data from "payment_gateway.transaction_release".
"""
input TransactionReleaseOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  createdBy: OrderBy
  currentStatus: OrderBy
  id: OrderBy
  paymentId: OrderBy
  statusHistoryAggregate: CurrentTransactionReleaseStatusAggregateOrderBy
}

"""
select columns of table "payment_gateway.transaction_release"
"""
enum TransactionReleaseSelectColumn {
  """column name"""
  amount

  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  currentStatus

  """column name"""
  id

  """column name"""
  paymentId
}

enum TransactionReleaseStatusEnum {
  """The release is done"""
  DONE

  """The release failed"""
  ERROR

  """The release is in progress"""
  IN_PROGRESS
}

"""
Boolean expression to compare columns of type "TransactionReleaseStatusEnum". All fields are combined with logical 'AND'.
"""
input TransactionReleaseStatusEnumComparisonExp {
  _eq: TransactionReleaseStatusEnum
  _in: [TransactionReleaseStatusEnum!]
  _isNull: Boolean
  _neq: TransactionReleaseStatusEnum
  _nin: [TransactionReleaseStatusEnum!]
}

"""aggregate stddev on columns"""
type TransactionReleaseStddevFields {
  amount: Float
  id: Float
  paymentId: Float
}

"""
order by stddev() on columns of table "payment_gateway.transaction_release"
"""
input TransactionReleaseStddevOrderBy {
  amount: OrderBy
  id: OrderBy
  paymentId: OrderBy
}

"""aggregate stddevPop on columns"""
type TransactionReleaseStddevPopFields {
  amount: Float
  id: Float
  paymentId: Float
}

"""
order by stddevPop() on columns of table "payment_gateway.transaction_release"
"""
input TransactionReleaseStddevPopOrderBy {
  amount: OrderBy
  id: OrderBy
  paymentId: OrderBy
}

"""aggregate stddevSamp on columns"""
type TransactionReleaseStddevSampFields {
  amount: Float
  id: Float
  paymentId: Float
}

"""
order by stddevSamp() on columns of table "payment_gateway.transaction_release"
"""
input TransactionReleaseStddevSampOrderBy {
  amount: OrderBy
  id: OrderBy
  paymentId: OrderBy
}

"""aggregate sum on columns"""
type TransactionReleaseSumFields {
  amount: bigint
  id: bigint
  paymentId: bigint
}

"""
order by sum() on columns of table "payment_gateway.transaction_release"
"""
input TransactionReleaseSumOrderBy {
  amount: OrderBy
  id: OrderBy
  paymentId: OrderBy
}

"""aggregate varPop on columns"""
type TransactionReleaseVarPopFields {
  amount: Float
  id: Float
  paymentId: Float
}

"""
order by varPop() on columns of table "payment_gateway.transaction_release"
"""
input TransactionReleaseVarPopOrderBy {
  amount: OrderBy
  id: OrderBy
  paymentId: OrderBy
}

"""aggregate varSamp on columns"""
type TransactionReleaseVarSampFields {
  amount: Float
  id: Float
  paymentId: Float
}

"""
order by varSamp() on columns of table "payment_gateway.transaction_release"
"""
input TransactionReleaseVarSampOrderBy {
  amount: OrderBy
  id: OrderBy
  paymentId: OrderBy
}

"""aggregate variance on columns"""
type TransactionReleaseVarianceFields {
  amount: Float
  id: Float
  paymentId: Float
}

"""
order by variance() on columns of table "payment_gateway.transaction_release"
"""
input TransactionReleaseVarianceOrderBy {
  amount: OrderBy
  id: OrderBy
  paymentId: OrderBy
}

"""Unblock customer"""
input UnblockCustomerInput {
  """Email of the customer"""
  customerEmail: String

  """SSN of the customer"""
  customerSsn: String
}

"""Unblocked customers"""
type UnblockCustomerResult {
  """IDs of customers that are no longer blocked"""
  affectedCustomerIds: [Int!]!
}

"""Aggregate metrics per merchant per day"""
type UsageMeterDaily {
  currency: currency!
  date: date!
  metric: MerchantMetricEnum!
  occurrences: Int!

  """The sum value in minor units"""
  sumValue: bigint!
}

"""
Boolean expression to filter rows from the table "tenant.merchant_daily_metric". All fields are combined with a logical 'AND'.
"""
input UsageMeterDailyBoolExp {
  _and: [UsageMeterDailyBoolExp!]
  _not: UsageMeterDailyBoolExp
  _or: [UsageMeterDailyBoolExp!]
  currency: CurrencyComparisonExp
  date: DateComparisonExp
  metric: MerchantMetricEnumComparisonExp
  occurrences: IntComparisonExp
  sumValue: BigintComparisonExp
}

"""
Ordering options when selecting data from "tenant.merchant_daily_metric".
"""
input UsageMeterDailyOrderBy {
  currency: OrderBy
  date: OrderBy
  metric: OrderBy
  occurrences: OrderBy
  sumValue: OrderBy
}

"""
select columns of table "tenant.merchant_daily_metric"
"""
enum UsageMeterDailySelectColumn {
  """column name"""
  currency

  """column name"""
  date

  """column name"""
  metric

  """column name"""
  occurrences

  """column name"""
  sumValue
}

"""Monthly aggregates of metrics, including the current month"""
type UsageMeterMonthly {
  currency: currency
  firstDayOfMonthPeriod: date
  metric: citext
  month: smallint
  occurrences: Int

  """The sum value in minor units"""
  sumValue: bigint
  year: smallint
}

"""
Boolean expression to filter rows from the table "tenant.merchant_monthly_metric". All fields are combined with a logical 'AND'.
"""
input UsageMeterMonthlyBoolExp {
  _and: [UsageMeterMonthlyBoolExp!]
  _not: UsageMeterMonthlyBoolExp
  _or: [UsageMeterMonthlyBoolExp!]
  currency: CurrencyComparisonExp
  firstDayOfMonthPeriod: DateComparisonExp
  metric: CitextComparisonExp
  month: SmallintComparisonExp
  occurrences: IntComparisonExp
  sumValue: BigintComparisonExp
  year: SmallintComparisonExp
}

"""
Ordering options when selecting data from "tenant.merchant_monthly_metric".
"""
input UsageMeterMonthlyOrderBy {
  currency: OrderBy
  firstDayOfMonthPeriod: OrderBy
  metric: OrderBy
  month: OrderBy
  occurrences: OrderBy
  sumValue: OrderBy
  year: OrderBy
}

"""
select columns of table "tenant.merchant_monthly_metric"
"""
enum UsageMeterMonthlySelectColumn {
  """column name"""
  currency

  """column name"""
  firstDayOfMonthPeriod

  """column name"""
  metric

  """column name"""
  month

  """column name"""
  occurrences

  """column name"""
  sumValue

  """column name"""
  year
}

"""
Holds the emails that are allowed to login as the given merchant through google signin.
"""
type UserFromGoogle {
  email: citext!
  imageUrl: String
  role: UserRoleEnum!
}

"""
Boolean expression to filter rows from the table "merchant_portal.user_google". All fields are combined with a logical 'AND'.
"""
input UserFromGoogleBoolExp {
  _and: [UserFromGoogleBoolExp!]
  _not: UserFromGoogleBoolExp
  _or: [UserFromGoogleBoolExp!]
  email: CitextComparisonExp
  imageUrl: StringComparisonExp
  role: UserRoleEnumComparisonExp
}

"""
Ordering options when selecting data from "merchant_portal.user_google".
"""
input UserFromGoogleOrderBy {
  email: OrderBy
  imageUrl: OrderBy
  role: OrderBy
}

"""
select columns of table "merchant_portal.user_google"
"""
enum UserFromGoogleSelectColumn {
  """column name"""
  email

  """column name"""
  imageUrl

  """column name"""
  role
}

enum UserRoleEnum {
  """Admin users with full access to all features"""
  ADMIN

  """Users with read-only acess to all features"""
  STAFF

  """Admin users with full access to all features"""
  SUPERADMIN
}

"""
Boolean expression to compare columns of type "UserRoleEnum". All fields are combined with logical 'AND'.
"""
input UserRoleEnumComparisonExp {
  _eq: UserRoleEnum
  _in: [UserRoleEnum!]
  _isNull: Boolean
  _neq: UserRoleEnum
  _nin: [UserRoleEnum!]
}

"""Join table for tenant.merchant and merchant_portal.user_email"""
type UserWithPassword {
  email: citext!
  role: UserRoleEnum!
}

"""
Boolean expression to filter rows from the table "merchant_portal.merchant_user_email". All fields are combined with a logical 'AND'.
"""
input UserWithPasswordBoolExp {
  _and: [UserWithPasswordBoolExp!]
  _not: UserWithPasswordBoolExp
  _or: [UserWithPasswordBoolExp!]
  email: CitextComparisonExp
  role: UserRoleEnumComparisonExp
}

"""
Ordering options when selecting data from "merchant_portal.merchant_user_email".
"""
input UserWithPasswordOrderBy {
  email: OrderBy
  role: OrderBy
}

"""
select columns of table "merchant_portal.merchant_user_email"
"""
enum UserWithPasswordSelectColumn {
  """column name"""
  email

  """column name"""
  role
}

"""
Streaming cursor of the table "UserWithPassword"
"""
input UserWithPasswordStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserWithPasswordStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserWithPasswordStreamCursorValueInput {
  email: citext
  role: UserRoleEnum
}

"""Join table for tenant.merchant and merchant_portal.user_webauthn"""
type UserWithWebauthn {
  email: citext!
  role: UserRoleEnum!
}

"""
Boolean expression to filter rows from the table "merchant_portal.merchant_user_webauthn". All fields are combined with a logical 'AND'.
"""
input UserWithWebauthnBoolExp {
  _and: [UserWithWebauthnBoolExp!]
  _not: UserWithWebauthnBoolExp
  _or: [UserWithWebauthnBoolExp!]
  email: CitextComparisonExp
  role: UserRoleEnumComparisonExp
}

"""
Ordering options when selecting data from "merchant_portal.merchant_user_webauthn".
"""
input UserWithWebauthnOrderBy {
  email: OrderBy
  role: OrderBy
}

"""
select columns of table "merchant_portal.merchant_user_webauthn"
"""
enum UserWithWebauthnSelectColumn {
  """column name"""
  email

  """column name"""
  role
}

"""
Streaming cursor of the table "UserWithWebauthn"
"""
input UserWithWebauthnStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: UserWithWebauthnStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input UserWithWebauthnStreamCursorValueInput {
  email: citext
  role: UserRoleEnum
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""List of generated Valitor transaction CSVs"""
type ValitorTransactionsCSV {
  createdAt: timestamptz!
  date: date!
  id: bigint!
}

"""
aggregated selection of "merchant_portal.generated_valitor_transactions_csv"
"""
type ValitorTransactionsCSVAggregate {
  aggregate: ValitorTransactionsCSVAggregateFields
  nodes: [ValitorTransactionsCSV!]!
}

"""
aggregate fields of "merchant_portal.generated_valitor_transactions_csv"
"""
type ValitorTransactionsCSVAggregateFields {
  avg: ValitorTransactionsCSVAvgFields
  count(columns: [ValitorTransactionsCSVSelectColumn!], distinct: Boolean): Int!
  max: ValitorTransactionsCSVMaxFields
  min: ValitorTransactionsCSVMinFields
  stddev: ValitorTransactionsCSVStddevFields
  stddevPop: ValitorTransactionsCSVStddevPopFields
  stddevSamp: ValitorTransactionsCSVStddevSampFields
  sum: ValitorTransactionsCSVSumFields
  varPop: ValitorTransactionsCSVVarPopFields
  varSamp: ValitorTransactionsCSVVarSampFields
  variance: ValitorTransactionsCSVVarianceFields
}

"""aggregate avg on columns"""
type ValitorTransactionsCSVAvgFields {
  id: Float
}

"""
Boolean expression to filter rows from the table "merchant_portal.generated_valitor_transactions_csv". All fields are combined with a logical 'AND'.
"""
input ValitorTransactionsCSVBoolExp {
  _and: [ValitorTransactionsCSVBoolExp!]
  _not: ValitorTransactionsCSVBoolExp
  _or: [ValitorTransactionsCSVBoolExp!]
  createdAt: TimestamptzComparisonExp
  date: DateComparisonExp
  id: BigintComparisonExp
}

"""URL for downloadable Valitor transactions CSVs"""
type ValitorTransactionsCSVLink {
  createdAt: timestamptz!
  csvId: bigint!
  errMessage: String
  expiresAt: timestamptz
  id: bigint!
  link: String
  merchantId: bigint!
  status: ReportLinkStatusEnum!
}

"""
Boolean expression to filter rows from the table "merchant_portal.generated_valitor_transactions_csv_link". All fields are combined with a logical 'AND'.
"""
input ValitorTransactionsCSVLinkBoolExp {
  _and: [ValitorTransactionsCSVLinkBoolExp!]
  _not: ValitorTransactionsCSVLinkBoolExp
  _or: [ValitorTransactionsCSVLinkBoolExp!]
  createdAt: TimestamptzComparisonExp
  csvId: BigintComparisonExp
  errMessage: StringComparisonExp
  expiresAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  link: StringComparisonExp
  merchantId: BigintComparisonExp
  status: ReportLinkStatusEnumComparisonExp
}

"""
Ordering options when selecting data from "merchant_portal.generated_valitor_transactions_csv_link".
"""
input ValitorTransactionsCSVLinkOrderBy {
  createdAt: OrderBy
  csvId: OrderBy
  errMessage: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  link: OrderBy
  merchantId: OrderBy
  status: OrderBy
}

"""
select columns of table "merchant_portal.generated_valitor_transactions_csv_link"
"""
enum ValitorTransactionsCSVLinkSelectColumn {
  """column name"""
  createdAt

  """column name"""
  csvId

  """column name"""
  errMessage

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  link

  """column name"""
  merchantId

  """column name"""
  status
}

"""aggregate max on columns"""
type ValitorTransactionsCSVMaxFields {
  createdAt: timestamptz
  date: date
  id: bigint
}

"""aggregate min on columns"""
type ValitorTransactionsCSVMinFields {
  createdAt: timestamptz
  date: date
  id: bigint
}

"""
Ordering options when selecting data from "merchant_portal.generated_valitor_transactions_csv".
"""
input ValitorTransactionsCSVOrderBy {
  createdAt: OrderBy
  date: OrderBy
  id: OrderBy
}

"""
select columns of table "merchant_portal.generated_valitor_transactions_csv"
"""
enum ValitorTransactionsCSVSelectColumn {
  """column name"""
  createdAt

  """column name"""
  date

  """column name"""
  id
}

"""aggregate stddev on columns"""
type ValitorTransactionsCSVStddevFields {
  id: Float
}

"""aggregate stddevPop on columns"""
type ValitorTransactionsCSVStddevPopFields {
  id: Float
}

"""aggregate stddevSamp on columns"""
type ValitorTransactionsCSVStddevSampFields {
  id: Float
}

"""aggregate sum on columns"""
type ValitorTransactionsCSVSumFields {
  id: bigint
}

"""aggregate varPop on columns"""
type ValitorTransactionsCSVVarPopFields {
  id: Float
}

"""aggregate varSamp on columns"""
type ValitorTransactionsCSVVarSampFields {
  id: Float
}

"""aggregate variance on columns"""
type ValitorTransactionsCSVVarianceFields {
  id: Float
}

"""Describe the schema for Vipps details."""
type VippsDetails {
  """Acquirer Name"""
  acquirer: String
  cardCountry: String
  cardExpiryDate: date

  """
  Reepay credit card fingerprint that uniquely identifies this particular card number
  """
  cardFingerprint: String
  cardNumber: String
  cardType: String
  threeDSecureStatus: Boolean
}

"""
order by aggregate values of table "runtime.transaction_vipps_details"
"""
input VippsDetailsAggregateOrderBy {
  count: OrderBy
  max: VippsDetailsMaxOrderBy
  min: VippsDetailsMinOrderBy
}

"""
Boolean expression to filter rows from the table "runtime.transaction_vipps_details". All fields are combined with a logical 'AND'.
"""
input VippsDetailsBoolExp {
  _and: [VippsDetailsBoolExp!]
  _not: VippsDetailsBoolExp
  _or: [VippsDetailsBoolExp!]
  acquirer: StringComparisonExp
  cardCountry: StringComparisonExp
  cardExpiryDate: DateComparisonExp
  cardFingerprint: StringComparisonExp
  cardNumber: StringComparisonExp
  cardType: StringComparisonExp
  threeDSecureStatus: BooleanComparisonExp
}

"""
order by max() on columns of table "runtime.transaction_vipps_details"
"""
input VippsDetailsMaxOrderBy {
  """Acquirer Name"""
  acquirer: OrderBy
  cardCountry: OrderBy
  cardExpiryDate: OrderBy

  """
  Reepay credit card fingerprint that uniquely identifies this particular card number
  """
  cardFingerprint: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
}

"""
order by min() on columns of table "runtime.transaction_vipps_details"
"""
input VippsDetailsMinOrderBy {
  """Acquirer Name"""
  acquirer: OrderBy
  cardCountry: OrderBy
  cardExpiryDate: OrderBy

  """
  Reepay credit card fingerprint that uniquely identifies this particular card number
  """
  cardFingerprint: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
}

"""
Ordering options when selecting data from "runtime.transaction_vipps_details".
"""
input VippsDetailsOrderBy {
  acquirer: OrderBy
  cardCountry: OrderBy
  cardExpiryDate: OrderBy
  cardFingerprint: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
  threeDSecureStatus: OrderBy
}

"""
select columns of table "runtime.transaction_vipps_details"
"""
enum VippsDetailsSelectColumn {
  """column name"""
  acquirer

  """column name"""
  cardCountry

  """column name"""
  cardExpiryDate

  """column name"""
  cardFingerprint

  """column name"""
  cardNumber

  """column name"""
  cardType

  """column name"""
  threeDSecureStatus
}

scalar bigint

"""Settings for using Braintree"""
type braintreeSetting {
  currency: SupportedCurrencyEnum!
  paypalClientId: String!
  tokenizationKey: String!
}

"""
Boolean expression to filter rows from the table "tenant.braintree_setting". All fields are combined with a logical 'AND'.
"""
input braintreeSettingBoolExp {
  _and: [braintreeSettingBoolExp!]
  _not: braintreeSettingBoolExp
  _or: [braintreeSettingBoolExp!]
  currency: SupportedCurrencyEnumComparisonExp
  paypalClientId: StringComparisonExp
  tokenizationKey: StringComparisonExp
}

"""Ordering options when selecting data from "tenant.braintree_setting"."""
input braintreeSettingOrderBy {
  currency: OrderBy
  paypalClientId: OrderBy
  tokenizationKey: OrderBy
}

"""
select columns of table "tenant.braintree_setting"
"""
enum braintreeSettingSelectColumn {
  """column name"""
  currency

  """column name"""
  paypalClientId

  """column name"""
  tokenizationKey
}

"""
Streaming cursor of the table "braintreeSetting"
"""
input braintreeSettingStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: braintreeSettingStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input braintreeSettingStreamCursorValueInput {
  currency: SupportedCurrencyEnum
  paypalClientId: String
  tokenizationKey: String
}

scalar citext

scalar country

scalar currency

scalar date

scalar geography

scalar geometry

scalar inet

scalar interval

scalar invoice_transaction_type

scalar jsonb

"""mutation root"""
type mutation_root {
  """Add new users."""
  addNewUser(add: AddUserInput!): AddNewUserResult!

  """Adjust the due date of an invoice."""
  adjustInvoiceDueDate(adjustment: InvoiceDueDateAdjustInput!): InvoiceDueDateAdjustResult!

  """Authorize payment for future instalments"""
  authorizeInstalments(instalment: AuthorizeInstalmentsInput!): AuthorizeInstalmentsResult!

  """Block a customer from making new purchases"""
  blockCustomer(block: BlockCustomerInput!): [BlockCustomerResult!]!

  """Block a customer from making new purchases by customer id"""
  blockCustomerById(block: BlockCustomerByIdInput!): BlockCustomerResult!

  """
  Blocks the specified token, after a successful operation, the given token will no longer work.
  """
  blockToken(token: BlockTokenInput!): BlockTokenResult!

  """Cancel payment request."""
  cancelPayment(cancel: PaymentCancelInput!): PaymentCancelResult!

  """Cancel payment request made using newSwishPayment."""
  cancelSwishPayment(pay: SwishPaymentCancelInput!): SwishPaymentCancelResult!

  """Capture PayPal payment"""
  capturePayPalPayment(pay: CapturePayPalPaymentInput!): CapturePayPalPaymentResult!

  """
  Fully capture a payment and consider it paid, refund the user any remaining pre-authorized amount.
  """
  capturePaymentAll(capture: PaymentCaptureAllInput!): PaymentCaptureResult!

  """Delete a webhook URL"""
  deleteWebhookUrl(deleteWebhookUrl: DeleteWebhookUrlInput!): DeleteWebhookUrlResult!

  """Edit a purchase that hasn't been captured yet."""
  editPurchase(edit: PurchaseEditInput!): PurchaseEditResult!

  """Edit the purchase billing or shipping address."""
  editPurchaseAddress(edit: PurchaseEditAddressInput!): PurchaseEditAddressResult!

  """Edit the role of users."""
  editUserRole(edit: EditUserInput!): EditUserResult!

  """Generates a new CSV file containing payment requests."""
  generatePaymentRequestsCSV(generate: GeneratePaymentRequestCSVInput!): GeneratePaymentRequestCSVResult!

  """Generates a new CSV file containing payments."""
  generatePaymentsCSV(generate: GeneratePaymentCSVInput!): GeneratePaymentCSVResult!

  """Generates a new CSV file containing purchases."""
  generatePurchasesCSV(generate: GeneratePurchaseCSVInput!): GeneratePurchaseCSVResult!

  """Generates a new CSV file containing payments reconciliation."""
  generateReconciliationCSV(generate: GenerateReconciliationCSVInput!): GenerateReconciliationCSVResult!

  """Generate settlement and transaction report."""
  generateReport(report: GenerateReportInput!): GenerateReportResult!

  """
  Generates a new link to an existing CSV file containing Valitor transactions.
  """
  generateValitorTransactionsCSVLink(generate: GenerateValitorTransactionsCSVLinkInput!): GenerateValitorTransactionsCSVLinkResult!

  """Create a new payment request to receive money via Finshark"""
  newDirectDebitPayment(pay: DirectDebitPaymentInput!): DirectDebitPaymentResult!

  """Add a note to an invoice."""
  newInvoiceNote(note: InvoiceNoteInput!): InvoiceNoteResult!

  """Add discount for a captured item in an invoice."""
  newItemDiscount(discount: ItemDiscountInput!): ItemDiscountResult!

  """Create a new payment request to receive money via PayPal"""
  newPayPalPayment(pay: PayPalPaymentInput!): PayPalPaymentResult!

  """Capture a payment."""
  newPaymentCapture(capture: PaymentCaptureInput!): PaymentCaptureResult!

  """
  Create a new payment session to start a new stand alone payment. The token from the session can be used in subsequent calls for the payment flow.
  """
  newPaymentSession(payment: PaymentSessionInput!): PaymentSessionResult!

  """
  Create a new payment session to start a new payment.
  The token from the session can be used in subsequent calls for the payment flow.

  This mutation will also check if any other payment session with the same
  `merchantReference` exists and if so, it will return the token from that session,
  provided that the session is not expired, and the same amount is requested.
  """
  newPaymentSessionWithReferenceCheck(payment: PaymentSessionWithReferenceCheckInput!): PaymentSessionWithReferenceCheckResult!

  """Capture a partial or complete purchase."""
  newPurchaseCapture(capture: PurchaseCaptureInput!): PurchaseCaptureResult!

  """Capture a complete purchase."""
  newPurchaseCaptureAll(capture: PurchaseCaptureAllInput!): PurchaseCaptureAllResult!

  """Capture multiple complete purchases."""
  newPurchaseCaptureAllBatch(capture: PurchaseCaptureAllBatchInput!): PurchaseCaptureAllBatchResult!

  """Capture multiple purchases with a date range."""
  newPurchaseCaptureAllRange(capture: PurchaseCaptureAllRangeInput!): PurchaseCaptureAllRangeResult!

  """Capture items in a purchase with their reference."""
  newPurchaseCaptureWithItemReferences(capture: PurchaseCaptureWithItemReferencesInput!): PurchaseCaptureWithItemReferencesResult!

  """
  create a purchase intent that will be paid by the customer in instalments.
  """
  newPurchaseOrderWithInstalments(purchase: PurchaseOrderWithInstalmentsInput!): PurchaseOrderWithInstalmentsResult!

  """create a purchase intent."""
  newPurchaseOrderWithInvoice(purchase: PurchaseOrderWithInvoiceInput!): PurchaseOrderWithInvoiceResult!

  """Return items."""
  newPurchaseReturn(return: PurchaseReturnInput!): PurchaseReturnResult!

  """Return a complete purchase."""
  newPurchaseReturnAll(return: PurchaseReturnAllInput!): PurchaseReturnAllResult!

  """Create a new payment request to receive money via swish"""
  newSwishPayment(pay: SwishPaymentInput!): SwishPaymentResult!

  """Onboard a merchant on PayPal"""
  onboardPayPalMerchant(merchant: PayPalMerchantOnboardingInput!): PayPalMerchantOnboardingResult!

  """Pay the next instalment"""
  payInstalment(instalment: PayInstalmentInput!): PayInstalmentResult!

  """Cancel a purchase that might already have partial captures."""
  purchaseCancel(cancel: PurchaseCancelInput!): PurchaseCancelResult!

  """Cancel a purchase order."""
  purchaseOrderCancel(cancel: PurchaseOrderCancelInput!): PurchaseOrderCancelResult!

  """Refund a payment"""
  refundPayment(refund: RefundPaymentInput!): RefundPaymentResult!

  """Release a payment that hasn't been captured yet"""
  releasePayment(release: ReleasePaymentInput!): ReleasePaymentResult!

  """Remove users."""
  removeUser(remove: RemoveUserInput!): RemoveUserResult!

  """Sends the invoice email to the customer."""
  resendInvoiceEmail(generate: ResendInvoiceEmailInput!): ResendInvoiceEmailResult!

  """Recheck payment status with payment provider."""
  restartPaymentStatusCheck(info: RestartPaymentStatusCheckInput!): RestartPaymentStatusCheckResult!

  """Set the url that will receive webhook notifications"""
  setWebhookUrl(setWebhookUrl: SetWebhookUrlInput!): SetWebhookUrlResult!

  """Supply PaymentMethodId (nonce) to progress PayPal paymeent"""
  supplyPayPalPaymentMethodId(pay: SupplyPayPalPaymentMethodIdInput!): SupplyPayPalPaymentMethodIdResult!

  """Turn payment methods on or off"""
  togglePaymentMethodAvailability(payload: TogglePaymentMethodAvailabilityInput!): TogglePaymentMethodAvailabilityResult!

  """Remove a customer from the blocked list"""
  unblockCustomer(unblock: UnblockCustomerInput!): UnblockCustomerResult!
}

scalar numeric

scalar packed_phone_number

"""Table to hold PayPal credentials"""
type paypalSetting {
  """
  '
  BN code is a character string that uniquely identifies us with PayPal to
  properly attribute payments. We pass this in all PayPal API calls in the
  `PayPal-Partner-Attribution-Id` header
  '
  """
  bnCode: String!

  """The client_id of the PayPal app"""
  clientId: String!

  """The intent of a PayPal order: `AUTHORIZE` or `CAPTURE`"""
  intent: PaypalIntentEnum!
}

"""
Boolean expression to filter rows from the table "tenant.paypal_setting". All fields are combined with a logical 'AND'.
"""
input paypalSettingBoolExp {
  _and: [paypalSettingBoolExp!]
  _not: paypalSettingBoolExp
  _or: [paypalSettingBoolExp!]
  bnCode: StringComparisonExp
  clientId: StringComparisonExp
  intent: PaypalIntentEnumComparisonExp
}

"""Ordering options when selecting data from "tenant.paypal_setting"."""
input paypalSettingOrderBy {
  bnCode: OrderBy
  clientId: OrderBy
  intent: OrderBy
}

"""
select columns of table "tenant.paypal_setting"
"""
enum paypalSettingSelectColumn {
  """column name"""
  bnCode

  """column name"""
  clientId

  """column name"""
  intent
}

"""
Streaming cursor of the table "paypalSetting"
"""
input paypalSettingStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: paypalSettingStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input paypalSettingStreamCursorValueInput {
  """
  '
  BN code is a character string that uniquely identifies us with PayPal to
  properly attribute payments. We pass this in all PayPal API calls in the
  `PayPal-Partner-Attribution-Id` header
  '
  """
  bnCode: String

  """The client_id of the PayPal app"""
  clientId: String

  """The intent of a PayPal order: `AUTHORIZE` or `CAPTURE`"""
  intent: PaypalIntentEnum
}

type query_root {
  """
  Get the list of Strong Customer Authentication processes and their status
  """
  bankIdAuth(
    """distinct select on columns"""
    distinctOn: [BankIdAuthSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BankIdAuthOrderBy!]

    """filter the rows returned"""
    where: BankIdAuthBoolExp
  ): [BankIdAuth!]!

  """
  fetch data from the table: "tenant.braintree_setting"
  """
  braintreeSetting(
    """distinct select on columns"""
    distinctOn: [braintreeSettingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [braintreeSettingOrderBy!]

    """filter the rows returned"""
    where: braintreeSettingBoolExp
  ): [braintreeSetting!]!

  """Get the list of CustomerBan directives"""
  customerBans(
    """distinct select on columns"""
    distinctOn: [CustomerBanSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerBanOrderBy!]

    """filter the rows returned"""
    where: CustomerBanBoolExp
  ): [CustomerBan!]!

  """Get additional data associated with payments"""
  customerPaymentData(
    """distinct select on columns"""
    distinctOn: [CustomerPaymentDataSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerPaymentDataOrderBy!]

    """filter the rows returned"""
    where: CustomerPaymentDataBoolExp
  ): [CustomerPaymentData!]!

  """Get the list of customers"""
  customers(
    """distinct select on columns"""
    distinctOn: [CustomerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerOrderBy!]

    """filter the rows returned"""
    where: CustomerBoolExp
  ): [Customer!]!

  """Run aggregation functions on the list of customers"""
  customersAggregate(
    """distinct select on columns"""
    distinctOn: [CustomerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerOrderBy!]

    """filter the rows returned"""
    where: CustomerBoolExp
  ): CustomerAggregate!

  """
  fetch data from the table: "dna.device"
  """
  device(
    """distinct select on columns"""
    distinctOn: [DeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DeviceOrderBy!]

    """filter the rows returned"""
    where: DeviceBoolExp
  ): [Device!]!

  """An array relationship"""
  instalments(
    """distinct select on columns"""
    distinctOn: [InstalmentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InstalmentOrderBy!]

    """filter the rows returned"""
    where: InstalmentBoolExp
  ): [Instalment!]!

  """Get the list of notes added by merchant admins on invoices"""
  invoiceNotes(
    """distinct select on columns"""
    distinctOn: [InvoiceNoteSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceNoteOrderBy!]

    """filter the rows returned"""
    where: InvoiceNoteBoolExp
  ): [InvoiceNote!]!

  """Run aggregation functions on the list of invoice notes"""
  invoiceNotesAggregate(
    """distinct select on columns"""
    distinctOn: [InvoiceNoteSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceNoteOrderBy!]

    """filter the rows returned"""
    where: InvoiceNoteBoolExp
  ): InvoiceNoteAggregate!

  """Get all the informatioin needed to render invoices"""
  invoicePage(
    """distinct select on columns"""
    distinctOn: [InvoicePageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoicePageOrderBy!]

    """filter the rows returned"""
    where: InvoicePageBoolExp
  ): [InvoicePage!]!

  """The list of invoices"""
  invoices(
    """distinct select on columns"""
    distinctOn: [InvoiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceOrderBy!]

    """filter the rows returned"""
    where: InvoiceBoolExp
  ): [Invoice!]!

  """Run aggregation functions on the list of invoices"""
  invoicesAggregate(
    """distinct select on columns"""
    distinctOn: [InvoiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceOrderBy!]

    """filter the rows returned"""
    where: InvoiceBoolExp
  ): InvoiceAggregate!

  """Select a single merchant by Id"""
  merchant(id: bigint!): Merchant

  """Get the list of onboarded merchants"""
  payPalOnboardingStatus(
    """distinct select on columns"""
    distinctOn: [PayPalOnboardingStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PayPalOnboardingStatusOrderBy!]

    """filter the rows returned"""
    where: PayPalOnboardingStatusBoolExp
  ): [PayPalOnboardingStatus!]!

  """
  Run aggregation functions on the list of emails associated to customers
  """
  paymentCaptureAggregate(
    """distinct select on columns"""
    distinctOn: [PaymentCaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCaptureOrderBy!]

    """filter the rows returned"""
    where: PaymentCaptureBoolExp
  ): PaymentCaptureAggregate!

  """
  fetch data from the table: "payment_gateway.payment_capture"
  """
  paymentCaptures(
    """distinct select on columns"""
    distinctOn: [PaymentCaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCaptureOrderBy!]

    """filter the rows returned"""
    where: PaymentCaptureBoolExp
  ): [PaymentCapture!]!

  """
  fetch data from the table: "tenant.payment_method_available"
  """
  paymentMethodStatus(
    """distinct select on columns"""
    distinctOn: [PaymentMethodStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentMethodStatusOrderBy!]

    """filter the rows returned"""
    where: PaymentMethodStatusBoolExp
  ): [PaymentMethodStatus!]!

  """Get the list of payment requests"""
  paymentRequests(
    """distinct select on columns"""
    distinctOn: [PaymentRequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentRequestOrderBy!]

    """filter the rows returned"""
    where: PaymentRequestBoolExp
  ): [PaymentRequest!]!

  """
  Get the list of URLs containing downloadable CSV files with payment request data
  """
  paymentRequestsCSV(
    """distinct select on columns"""
    distinctOn: [PaymentRequestCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentRequestCSVOrderBy!]

    """filter the rows returned"""
    where: PaymentRequestCSVBoolExp
  ): [PaymentRequestCSV!]!

  """Get the list of payments"""
  payments(
    """distinct select on columns"""
    distinctOn: [PaymentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentOrderBy!]

    """filter the rows returned"""
    where: PaymentBoolExp
  ): [Payment!]!

  """Run aggregations on the list of payments"""
  paymentsAggregate(
    """distinct select on columns"""
    distinctOn: [PaymentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentOrderBy!]

    """filter the rows returned"""
    where: PaymentBoolExp
  ): PaymentAggregate!

  """
  Get the list of URLs containing downloadable CSV files with payment data
  """
  paymentsCSV(
    """distinct select on columns"""
    distinctOn: [PaymentCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCSVOrderBy!]

    """filter the rows returned"""
    where: PaymentCSVBoolExp
  ): [PaymentCSV!]!

  """
  Run aggregation functions on list of URLs containing downloadable CSV files with payment data
  """
  paymentsCSVAggregate(
    """distinct select on columns"""
    distinctOn: [PaymentCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCSVOrderBy!]

    """filter the rows returned"""
    where: PaymentCSVBoolExp
  ): PaymentCSVAggregate!

  """
  fetch data from the table: "tenant.paypal_setting"
  """
  paypalSetting(
    """distinct select on columns"""
    distinctOn: [paypalSettingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [paypalSettingOrderBy!]

    """filter the rows returned"""
    where: paypalSettingBoolExp
  ): [paypalSetting!]!

  """Get the list of Bulk Capture requests with their status"""
  purchaseBulkCaptureStatuses(
    """distinct select on columns"""
    distinctOn: [PurchaseBulkCaptureStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseBulkCaptureStatusOrderBy!]

    """filter the rows returned"""
    where: PurchaseBulkCaptureStatusBoolExp
  ): [PurchaseBulkCaptureStatus!]!

  """Get the list of unauthenticated orders"""
  purchaseOrders(
    """distinct select on columns"""
    distinctOn: [PurchaseOrderSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseOrderOrderBy!]

    """filter the rows returned"""
    where: PurchaseOrderBoolExp
  ): [PurchaseOrder!]!

  """An array relationship"""
  purchases(
    """distinct select on columns"""
    distinctOn: [PurchaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseOrderBy!]

    """filter the rows returned"""
    where: PurchaseBoolExp
  ): [Purchase!]!

  """An aggregate relationship"""
  purchasesAggregate(
    """distinct select on columns"""
    distinctOn: [PurchaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseOrderBy!]

    """filter the rows returned"""
    where: PurchaseBoolExp
  ): PurchaseAggregate!

  """
  Get the list of URLs containing downloadable CSV files with purchase data
  """
  purchasesCSV(
    """distinct select on columns"""
    distinctOn: [PurchaseCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseCSVOrderBy!]

    """filter the rows returned"""
    where: PurchaseCSVBoolExp
  ): [PurchaseCSV!]!

  """Get the list of downloadable CSV reconciliation reports"""
  reconciliationReports(
    """distinct select on columns"""
    distinctOn: [ReconciliationReportLinkSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReconciliationReportLinkOrderBy!]

    """filter the rows returned"""
    where: ReconciliationReportLinkBoolExp
  ): [ReconciliationReportLink!]!

  """
  Get the total for all transactions that happened in the selected time range for a reconciliation report
  """
  reconciliationTransactionSummary(
    """
    input parameters for function "reconciliationTransactionSummary"
    """
    args: reconciliationTransactionSummaryArgs!

    """distinct select on columns"""
    distinctOn: [ReconciliationTransactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReconciliationTransactionOrderBy!]

    """filter the rows returned"""
    where: ReconciliationTransactionBoolExp
  ): [ReconciliationTransaction!]!

  """Get the list of generated reconciliation reports"""
  reconciliations(
    """distinct select on columns"""
    distinctOn: [ReconciliationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReconciliationOrderBy!]

    """filter the rows returned"""
    where: ReconciliationBoolExp
  ): [Reconciliation!]!

  """
  Run aggregation function on the list of generated reconciliation reports
  """
  reconciliationsAggregate(
    """distinct select on columns"""
    distinctOn: [ReconciliationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReconciliationOrderBy!]

    """filter the rows returned"""
    where: ReconciliationBoolExp
  ): ReconciliationAggregate!

  """An array relationship"""
  refunds(
    """distinct select on columns"""
    distinctOn: [RefundSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RefundOrderBy!]

    """filter the rows returned"""
    where: RefundBoolExp
  ): [Refund!]!

  """An aggregate relationship"""
  refundsAggregate(
    """distinct select on columns"""
    distinctOn: [RefundSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RefundOrderBy!]

    """filter the rows returned"""
    where: RefundBoolExp
  ): RefundAggregate!

  """Get the list of successful mutations done via the API"""
  requestsLog(
    """distinct select on columns"""
    distinctOn: [RequestLogSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestLogOrderBy!]

    """filter the rows returned"""
    where: RequestLogBoolExp
  ): [RequestLog!]!

  """Get the list of downloadable CSV settlement reports"""
  settlementReports(
    """distinct select on columns"""
    distinctOn: [SettlementReportLinkSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SettlementReportLinkOrderBy!]

    """filter the rows returned"""
    where: SettlementReportLinkBoolExp
  ): [SettlementReportLink!]!

  """
  Get the total for all transactions that happened in the selected time range
  """
  settlementSummary(
    """
    input parameters for function "settlementSummary"
    """
    args: settlementSummaryArgs!

    """distinct select on columns"""
    distinctOn: [SettlementSummarySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SettlementSummaryOrderBy!]

    """filter the rows returned"""
    where: SettlementSummaryBoolExp
  ): [SettlementSummary!]!

  """Get the total of all transactions for the given time range per order"""
  settlementTransactionSummary(
    """
    input parameters for function "settlementTransactionSummary"
    """
    args: settlementTransactionSummaryArgs!

    """distinct select on columns"""
    distinctOn: [SettlementTransactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SettlementTransactionOrderBy!]

    """filter the rows returned"""
    where: SettlementTransactionBoolExp
  ): [SettlementTransaction!]!

  """Get the list of generated settlement reports"""
  settlements(
    """distinct select on columns"""
    distinctOn: [SettlementSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SettlementOrderBy!]

    """filter the rows returned"""
    where: SettlementBoolExp
  ): [Settlement!]!

  """Run aggregation function on the list of generated settlement reports"""
  settlementsAggregate(
    """distinct select on columns"""
    distinctOn: [SettlementSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SettlementOrderBy!]

    """filter the rows returned"""
    where: SettlementBoolExp
  ): SettlementAggregate!

  """Get the list of successful webhook notifications"""
  successfulWebhookNotifications(
    """distinct select on columns"""
    distinctOn: [SuccessfulWebhookNotificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SuccessfulWebhookNotificationOrderBy!]

    """filter the rows returned"""
    where: SuccessfulWebhookNotificationBoolExp
  ): [SuccessfulWebhookNotification!]!

  """
  Run aggregation functions on the list of successful webhook notifications
  """
  successfulWebhookNotificationsAggregate(
    """distinct select on columns"""
    distinctOn: [SuccessfulWebhookNotificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SuccessfulWebhookNotificationOrderBy!]

    """filter the rows returned"""
    where: SuccessfulWebhookNotificationBoolExp
  ): SuccessfulWebhookNotificationAggregate!

  """Get the list of active tokens"""
  tokens(
    """distinct select on columns"""
    distinctOn: [TokensSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TokensOrderBy!]

    """filter the rows returned"""
    where: TokensBoolExp
  ): [Tokens!]!

  """Get the list of transaction releases"""
  transactionReleases(
    """distinct select on columns"""
    distinctOn: [TransactionReleaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TransactionReleaseOrderBy!]

    """filter the rows returned"""
    where: TransactionReleaseBoolExp
  ): [TransactionRelease!]!

  """Run aggregations on the list of transaction releases"""
  transactionReleasesAggregate(
    """distinct select on columns"""
    distinctOn: [TransactionReleaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TransactionReleaseOrderBy!]

    """filter the rows returned"""
    where: TransactionReleaseBoolExp
  ): TransactionReleaseAggregate!

  """
  fetch data from the table: "tenant.merchant_daily_metric"
  """
  usageMetersDaily(
    """distinct select on columns"""
    distinctOn: [UsageMeterDailySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UsageMeterDailyOrderBy!]

    """filter the rows returned"""
    where: UsageMeterDailyBoolExp
  ): [UsageMeterDaily!]!

  """
  fetch data from the table: "tenant.merchant_monthly_metric"
  """
  usageMetersMonthly(
    """distinct select on columns"""
    distinctOn: [UsageMeterMonthlySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UsageMeterMonthlyOrderBy!]

    """filter the rows returned"""
    where: UsageMeterMonthlyBoolExp
  ): [UsageMeterMonthly!]!

  """Get the list of users who authenticate using their Google account"""
  usersFromGoogle(
    """distinct select on columns"""
    distinctOn: [UserFromGoogleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserFromGoogleOrderBy!]

    """filter the rows returned"""
    where: UserFromGoogleBoolExp
  ): [UserFromGoogle!]!

  """
  fetch data from the table: "merchant_portal.merchant_user_email"
  """
  usersWithPassword(
    """distinct select on columns"""
    distinctOn: [UserWithPasswordSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserWithPasswordOrderBy!]

    """filter the rows returned"""
    where: UserWithPasswordBoolExp
  ): [UserWithPassword!]!

  """
  fetch data from the table: "merchant_portal.merchant_user_webauthn"
  """
  usersWithWebauthn(
    """distinct select on columns"""
    distinctOn: [UserWithWebauthnSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserWithWebauthnOrderBy!]

    """filter the rows returned"""
    where: UserWithWebauthnBoolExp
  ): [UserWithWebauthn!]!

  """Get a downloadable CSV reconciliation report by Id"""
  valitorTransactionsCSVLink(id: bigint!, merchantId: bigint!): ValitorTransactionsCSVLink

  """Get the list of downloadable Valitor transactions CSVs"""
  valitorTransactionsCSVLinks(
    """distinct select on columns"""
    distinctOn: [ValitorTransactionsCSVLinkSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ValitorTransactionsCSVLinkOrderBy!]

    """filter the rows returned"""
    where: ValitorTransactionsCSVLinkBoolExp
  ): [ValitorTransactionsCSVLink!]!

  """Get the list of generated Valitor transaction CSVs"""
  valitorTransactionsCSVs(
    """distinct select on columns"""
    distinctOn: [ValitorTransactionsCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ValitorTransactionsCSVOrderBy!]

    """filter the rows returned"""
    where: ValitorTransactionsCSVBoolExp
  ): [ValitorTransactionsCSV!]!

  """
  Run aggregation function on the list of generated Valitor transaction CSVs
  """
  valitorTransactionsCSVsAggregate(
    """distinct select on columns"""
    distinctOn: [ValitorTransactionsCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ValitorTransactionsCSVOrderBy!]

    """filter the rows returned"""
    where: ValitorTransactionsCSVBoolExp
  ): ValitorTransactionsCSVAggregate!
  version: String!

  """
  fetch data from the table: "tenant.webhook_settings"
  """
  webhookURLs(
    """distinct select on columns"""
    distinctOn: [webhookURLsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [webhookURLsOrderBy!]

    """filter the rows returned"""
    where: webhookURLsBoolExp
  ): [webhookURLs!]!
}

input reconciliationTransactionSummaryArgs {
  batchSize: Int
  cursorKey: String
  endDate: date
  startDate: date
}

input settlementSummaryArgs {
  endDate: date
  startDate: date
}

input settlementTransactionSummaryArgs {
  batchSize: Int
  cursorKey: String
  endDate: date
  startDate: date
}

scalar smallint

scalar spoken_lang

input st_d_within_geography_input {
  distance: Float!
  from: geography!
  use_spheroid: Boolean = true
}

input st_d_within_input {
  distance: Float!
  from: geometry!
}

type subscription_root {
  """
  fetch data from the table in a streaming manner: "runtime.bankid_auth"
  """
  BankIdAuthStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [BankIdAuthStreamCursorInput]!

    """filter the rows returned"""
    where: BankIdAuthBoolExp
  ): [BankIdAuth!]!

  """
  fetch data from the table in a streaming manner: "dna.customer_payment_data"
  """
  CustomerPaymentDataStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [CustomerPaymentDataStreamCursorInput]!

    """filter the rows returned"""
    where: CustomerPaymentDataBoolExp
  ): [CustomerPaymentData!]!

  """
  fetch data from the table in a streaming manner: "dna.device"
  """
  DeviceStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [DeviceStreamCursorInput]!

    """filter the rows returned"""
    where: DeviceBoolExp
  ): [Device!]!

  """
  fetch data from the table in a streaming manner: "tenant.paypal_onboarding"
  """
  PayPalOnboardingStatusStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PayPalOnboardingStatusStreamCursorInput]!

    """filter the rows returned"""
    where: PayPalOnboardingStatusBoolExp
  ): [PayPalOnboardingStatus!]!

  """
  fetch data from the table in a streaming manner: "merchant_portal.generated_payments_csv"
  """
  PaymentCSVStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PaymentCSVStreamCursorInput]!

    """filter the rows returned"""
    where: PaymentCSVBoolExp
  ): [PaymentCSV!]!

  """
  fetch data from the table in a streaming manner: "payment_gateway.payment_capture"
  """
  PaymentCaptureStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PaymentCaptureStreamCursorInput]!

    """filter the rows returned"""
    where: PaymentCaptureBoolExp
  ): [PaymentCapture!]!

  """
  fetch data from the table in a streaming manner: "tenant.payment_method_available"
  """
  PaymentMethodStatusStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PaymentMethodStatusStreamCursorInput]!

    """filter the rows returned"""
    where: PaymentMethodStatusBoolExp
  ): [PaymentMethodStatus!]!

  """
  fetch data from the table in a streaming manner: "merchant_portal.generated_payment_requests_csv"
  """
  PaymentRequestCSVStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [PaymentRequestCSVStreamCursorInput]!

    """filter the rows returned"""
    where: PaymentRequestCSVBoolExp
  ): [PaymentRequestCSV!]!

  """
  fetch data from the table in a streaming manner: "merchant_portal.merchant_user_email"
  """
  UserWithPasswordStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [UserWithPasswordStreamCursorInput]!

    """filter the rows returned"""
    where: UserWithPasswordBoolExp
  ): [UserWithPassword!]!

  """
  fetch data from the table in a streaming manner: "merchant_portal.merchant_user_webauthn"
  """
  UserWithWebauthnStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [UserWithWebauthnStreamCursorInput]!

    """filter the rows returned"""
    where: UserWithWebauthnBoolExp
  ): [UserWithWebauthn!]!

  """
  Get the list of Strong Customer Authentication processes and their status
  """
  bankIdAuth(
    """distinct select on columns"""
    distinctOn: [BankIdAuthSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BankIdAuthOrderBy!]

    """filter the rows returned"""
    where: BankIdAuthBoolExp
  ): [BankIdAuth!]!

  """
  fetch data from the table: "tenant.braintree_setting"
  """
  braintreeSetting(
    """distinct select on columns"""
    distinctOn: [braintreeSettingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [braintreeSettingOrderBy!]

    """filter the rows returned"""
    where: braintreeSettingBoolExp
  ): [braintreeSetting!]!

  """
  fetch data from the table in a streaming manner: "tenant.braintree_setting"
  """
  braintreeSettingStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [braintreeSettingStreamCursorInput]!

    """filter the rows returned"""
    where: braintreeSettingBoolExp
  ): [braintreeSetting!]!

  """Get the list of CustomerBan directives"""
  customerBans(
    """distinct select on columns"""
    distinctOn: [CustomerBanSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerBanOrderBy!]

    """filter the rows returned"""
    where: CustomerBanBoolExp
  ): [CustomerBan!]!

  """Get additional data associated with payments"""
  customerPaymentData(
    """distinct select on columns"""
    distinctOn: [CustomerPaymentDataSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerPaymentDataOrderBy!]

    """filter the rows returned"""
    where: CustomerPaymentDataBoolExp
  ): [CustomerPaymentData!]!

  """Get the list of customers"""
  customers(
    """distinct select on columns"""
    distinctOn: [CustomerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerOrderBy!]

    """filter the rows returned"""
    where: CustomerBoolExp
  ): [Customer!]!

  """
  fetch data from the table: "dna.device"
  """
  device(
    """distinct select on columns"""
    distinctOn: [DeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DeviceOrderBy!]

    """filter the rows returned"""
    where: DeviceBoolExp
  ): [Device!]!

  """An array relationship"""
  instalments(
    """distinct select on columns"""
    distinctOn: [InstalmentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InstalmentOrderBy!]

    """filter the rows returned"""
    where: InstalmentBoolExp
  ): [Instalment!]!

  """Get the list of notes added by merchant admins on invoices"""
  invoiceNotes(
    """distinct select on columns"""
    distinctOn: [InvoiceNoteSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceNoteOrderBy!]

    """filter the rows returned"""
    where: InvoiceNoteBoolExp
  ): [InvoiceNote!]!

  """Get all the informatioin needed to render invoices"""
  invoicePage(
    """distinct select on columns"""
    distinctOn: [InvoicePageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoicePageOrderBy!]

    """filter the rows returned"""
    where: InvoicePageBoolExp
  ): [InvoicePage!]!

  """The list of invoices"""
  invoices(
    """distinct select on columns"""
    distinctOn: [InvoiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceOrderBy!]

    """filter the rows returned"""
    where: InvoiceBoolExp
  ): [Invoice!]!

  """Get the list of onboarded merchants"""
  payPalOnboardingStatus(
    """distinct select on columns"""
    distinctOn: [PayPalOnboardingStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PayPalOnboardingStatusOrderBy!]

    """filter the rows returned"""
    where: PayPalOnboardingStatusBoolExp
  ): [PayPalOnboardingStatus!]!

  """
  Run aggregation functions on the list of emails associated to customers
  """
  paymentCaptureAggregate(
    """distinct select on columns"""
    distinctOn: [PaymentCaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCaptureOrderBy!]

    """filter the rows returned"""
    where: PaymentCaptureBoolExp
  ): PaymentCaptureAggregate!

  """
  fetch data from the table: "payment_gateway.payment_capture"
  """
  paymentCaptures(
    """distinct select on columns"""
    distinctOn: [PaymentCaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCaptureOrderBy!]

    """filter the rows returned"""
    where: PaymentCaptureBoolExp
  ): [PaymentCapture!]!

  """
  fetch data from the table: "tenant.payment_method_available"
  """
  paymentMethodStatus(
    """distinct select on columns"""
    distinctOn: [PaymentMethodStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentMethodStatusOrderBy!]

    """filter the rows returned"""
    where: PaymentMethodStatusBoolExp
  ): [PaymentMethodStatus!]!

  """Get the list of payment requests"""
  paymentRequests(
    """distinct select on columns"""
    distinctOn: [PaymentRequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentRequestOrderBy!]

    """filter the rows returned"""
    where: PaymentRequestBoolExp
  ): [PaymentRequest!]!

  """
  Get the list of URLs containing downloadable CSV files with payment request data
  """
  paymentRequestsCSV(
    """distinct select on columns"""
    distinctOn: [PaymentRequestCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentRequestCSVOrderBy!]

    """filter the rows returned"""
    where: PaymentRequestCSVBoolExp
  ): [PaymentRequestCSV!]!

  """Get the list of payments"""
  payments(
    """distinct select on columns"""
    distinctOn: [PaymentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentOrderBy!]

    """filter the rows returned"""
    where: PaymentBoolExp
  ): [Payment!]!

  """
  Get the list of URLs containing downloadable CSV files with payment data
  """
  paymentsCSV(
    """distinct select on columns"""
    distinctOn: [PaymentCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCSVOrderBy!]

    """filter the rows returned"""
    where: PaymentCSVBoolExp
  ): [PaymentCSV!]!

  """
  Run aggregation functions on list of URLs containing downloadable CSV files with payment data
  """
  paymentsCSVAggregate(
    """distinct select on columns"""
    distinctOn: [PaymentCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCSVOrderBy!]

    """filter the rows returned"""
    where: PaymentCSVBoolExp
  ): PaymentCSVAggregate!

  """
  fetch data from the table: "tenant.paypal_setting"
  """
  paypalSetting(
    """distinct select on columns"""
    distinctOn: [paypalSettingSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [paypalSettingOrderBy!]

    """filter the rows returned"""
    where: paypalSettingBoolExp
  ): [paypalSetting!]!

  """
  fetch data from the table in a streaming manner: "tenant.paypal_setting"
  """
  paypalSettingStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [paypalSettingStreamCursorInput]!

    """filter the rows returned"""
    where: paypalSettingBoolExp
  ): [paypalSetting!]!

  """Get the list of Bulk Capture requests with their status"""
  purchaseBulkCaptureStatuses(
    """distinct select on columns"""
    distinctOn: [PurchaseBulkCaptureStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseBulkCaptureStatusOrderBy!]

    """filter the rows returned"""
    where: PurchaseBulkCaptureStatusBoolExp
  ): [PurchaseBulkCaptureStatus!]!

  """Get the list of unauthenticated orders"""
  purchaseOrders(
    """distinct select on columns"""
    distinctOn: [PurchaseOrderSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseOrderOrderBy!]

    """filter the rows returned"""
    where: PurchaseOrderBoolExp
  ): [PurchaseOrder!]!

  """An array relationship"""
  purchases(
    """distinct select on columns"""
    distinctOn: [PurchaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseOrderBy!]

    """filter the rows returned"""
    where: PurchaseBoolExp
  ): [Purchase!]!

  """
  Get the list of URLs containing downloadable CSV files with purchase data
  """
  purchasesCSV(
    """distinct select on columns"""
    distinctOn: [PurchaseCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseCSVOrderBy!]

    """filter the rows returned"""
    where: PurchaseCSVBoolExp
  ): [PurchaseCSV!]!

  """Get the list of downloadable CSV reconciliation reports"""
  reconciliationReports(
    """distinct select on columns"""
    distinctOn: [ReconciliationReportLinkSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReconciliationReportLinkOrderBy!]

    """filter the rows returned"""
    where: ReconciliationReportLinkBoolExp
  ): [ReconciliationReportLink!]!

  """
  Get the total for all transactions that happened in the selected time range for a reconciliation report
  """
  reconciliationTransactionSummary(
    """
    input parameters for function "reconciliationTransactionSummary"
    """
    args: reconciliationTransactionSummaryArgs!

    """distinct select on columns"""
    distinctOn: [ReconciliationTransactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReconciliationTransactionOrderBy!]

    """filter the rows returned"""
    where: ReconciliationTransactionBoolExp
  ): [ReconciliationTransaction!]!

  """Get the list of generated reconciliation reports"""
  reconciliations(
    """distinct select on columns"""
    distinctOn: [ReconciliationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReconciliationOrderBy!]

    """filter the rows returned"""
    where: ReconciliationBoolExp
  ): [Reconciliation!]!

  """An array relationship"""
  refunds(
    """distinct select on columns"""
    distinctOn: [RefundSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RefundOrderBy!]

    """filter the rows returned"""
    where: RefundBoolExp
  ): [Refund!]!

  """Get the list of downloadable CSV settlement reports"""
  settlementReports(
    """distinct select on columns"""
    distinctOn: [SettlementReportLinkSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SettlementReportLinkOrderBy!]

    """filter the rows returned"""
    where: SettlementReportLinkBoolExp
  ): [SettlementReportLink!]!

  """
  Get the total for all transactions that happened in the selected time range
  """
  settlementSummary(
    """
    input parameters for function "settlementSummary"
    """
    args: settlementSummaryArgs!

    """distinct select on columns"""
    distinctOn: [SettlementSummarySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SettlementSummaryOrderBy!]

    """filter the rows returned"""
    where: SettlementSummaryBoolExp
  ): [SettlementSummary!]!

  """Get the total of all transactions for the given time range per order"""
  settlementTransactionSummary(
    """
    input parameters for function "settlementTransactionSummary"
    """
    args: settlementTransactionSummaryArgs!

    """distinct select on columns"""
    distinctOn: [SettlementTransactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SettlementTransactionOrderBy!]

    """filter the rows returned"""
    where: SettlementTransactionBoolExp
  ): [SettlementTransaction!]!

  """Get the list of generated settlement reports"""
  settlements(
    """distinct select on columns"""
    distinctOn: [SettlementSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SettlementOrderBy!]

    """filter the rows returned"""
    where: SettlementBoolExp
  ): [Settlement!]!

  """Get the list of successful webhook notifications"""
  successfulWebhookNotifications(
    """distinct select on columns"""
    distinctOn: [SuccessfulWebhookNotificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SuccessfulWebhookNotificationOrderBy!]

    """filter the rows returned"""
    where: SuccessfulWebhookNotificationBoolExp
  ): [SuccessfulWebhookNotification!]!

  """Get the list of transaction releases"""
  transactionReleases(
    """distinct select on columns"""
    distinctOn: [TransactionReleaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TransactionReleaseOrderBy!]

    """filter the rows returned"""
    where: TransactionReleaseBoolExp
  ): [TransactionRelease!]!

  """
  fetch data from the table: "merchant_portal.merchant_user_email"
  """
  usersWithPassword(
    """distinct select on columns"""
    distinctOn: [UserWithPasswordSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserWithPasswordOrderBy!]

    """filter the rows returned"""
    where: UserWithPasswordBoolExp
  ): [UserWithPassword!]!

  """
  fetch data from the table: "merchant_portal.merchant_user_webauthn"
  """
  usersWithWebauthn(
    """distinct select on columns"""
    distinctOn: [UserWithWebauthnSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserWithWebauthnOrderBy!]

    """filter the rows returned"""
    where: UserWithWebauthnBoolExp
  ): [UserWithWebauthn!]!

  """Get a downloadable CSV reconciliation report by Id"""
  valitorTransactionsCSVLink(id: bigint!, merchantId: bigint!): ValitorTransactionsCSVLink

  """Get the list of downloadable Valitor transactions CSVs"""
  valitorTransactionsCSVLinks(
    """distinct select on columns"""
    distinctOn: [ValitorTransactionsCSVLinkSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ValitorTransactionsCSVLinkOrderBy!]

    """filter the rows returned"""
    where: ValitorTransactionsCSVLinkBoolExp
  ): [ValitorTransactionsCSVLink!]!

  """Get the list of generated Valitor transaction CSVs"""
  valitorTransactionsCSVs(
    """distinct select on columns"""
    distinctOn: [ValitorTransactionsCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ValitorTransactionsCSVOrderBy!]

    """filter the rows returned"""
    where: ValitorTransactionsCSVBoolExp
  ): [ValitorTransactionsCSV!]!

  """
  fetch data from the table: "tenant.webhook_settings"
  """
  webhookURLs(
    """distinct select on columns"""
    distinctOn: [webhookURLsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [webhookURLsOrderBy!]

    """filter the rows returned"""
    where: webhookURLsBoolExp
  ): [webhookURLs!]!

  """
  fetch data from the table in a streaming manner: "tenant.webhook_settings"
  """
  webhookURLsStream(
    """maximum number of rows returned in a single batch"""
    batchSize: Int!

    """cursor to stream the results returned by the query"""
    cursor: [webhookURLsStreamCursorInput]!

    """filter the rows returned"""
    where: webhookURLsBoolExp
  ): [webhookURLs!]!
}

scalar timestamp

scalar timestamptz

scalar uuid

"""Settings for merchant webhook notifications"""
type webhookURLs {
  faulty: Boolean!
  webhookUrl: String!
}

"""
Boolean expression to filter rows from the table "tenant.webhook_settings". All fields are combined with a logical 'AND'.
"""
input webhookURLsBoolExp {
  _and: [webhookURLsBoolExp!]
  _not: webhookURLsBoolExp
  _or: [webhookURLsBoolExp!]
  faulty: BooleanComparisonExp
  webhookUrl: StringComparisonExp
}

"""Ordering options when selecting data from "tenant.webhook_settings"."""
input webhookURLsOrderBy {
  faulty: OrderBy
  webhookUrl: OrderBy
}

"""
select columns of table "tenant.webhook_settings"
"""
enum webhookURLsSelectColumn {
  """column name"""
  faulty

  """column name"""
  webhookUrl
}

"""
Streaming cursor of the table "webhookURLs"
"""
input webhookURLsStreamCursorInput {
  """Stream column input with initial value"""
  initialValue: webhookURLsStreamCursorValueInput!

  """cursor ordering"""
  ordering: CursorOrdering
}

"""Initial value of the column from where the streaming should start"""
input webhookURLsStreamCursorValueInput {
  faulty: Boolean
  webhookUrl: String
}

