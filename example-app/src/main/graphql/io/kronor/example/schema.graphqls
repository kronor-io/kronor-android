schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""Result of the addition"""
type AddNewUserResult {
  """Result of the operation."""
  success: Boolean!
}

"""Add new user to merchant pool."""
input AddUserInput {
  """List of users that should be added."""
  addUsers: [AddUserSingleInput!]!

  """Email of the user that is making the request."""
  currentUser: String!
}

"""Add new user to merchant pool."""
input AddUserSingleInput {
  """Email of the user, for reference."""
  email: String!

  """Role that this user should have."""
  role: String!
}

"""A physical address for a customer."""
input AddressInput {
  """
  Named intermediary.
  Max length: 100.
  """
  careOf: String

  """
  City.
  Max length: 100.
  """
  city: String!

  """E-mail address."""
  email: String!

  """
  First name or Given Name.
  Max length: 100.
  """
  firstName: String!

  """
  Last name or Family Name.
  Max length: 100.
  """
  lastName: String!

  """
  Phone number
  Max length: 100.
  """
  phoneNumber: String!

  """Postal Code."""
  postalCode: String!

  """
  State or Region.
  Max length: 100.
  """
  region: String

  """
  Street address, first line.
  This should contain any free text as given by the customer
  
  Max length: 10000.
  """
  streetAddress: String!

  """
  Street address, second line.
  This should contain any free text as given by the customer
  
  Max length: 10000.
  """
  streetAddress2: String

  """
  Street name. Do not combine with streetAddress.
  Should only be used if this field has been validated by the merchant
  and known to be correct.
  
  Max length: 10000.
  """
  streetName: String

  """
  Street number. Do not combine with streetAddress.
  Should only be used if this field has been validated by the merchant
  and known to be correct.
  
  Max length: 10000.
  """
  streetNumber: String

  """
  Title used for addressing the customer.
  Max length: 100.
  """
  title: CustomerTitle
}

"""Arguments for authorizing future instalments for a purchase"""
input AuthorizeInstalmentsInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """Currently 'recurring_debit'"""
  paymentMethod: String!

  """
  The purchaseId is the purchase for which the customer
  is authorizing the instalments for.
  
  Max length: 64.
  """
  purchaseId: bigint!

  """The url to return to after the authorization is done."""
  returnUrl: String!
}

"""The result of initiating an authorization for instalments."""
type AuthorizeInstalmentsResult {
  """
  Once an authorization is initialized, we will start the payment workflow.
  You can use this token to query the current status of the authorization
  and where to redirect the user next for them to authorize the payments for the instalments.
  """
  waitToken: String!
}

"""BankID SCA status"""
type BankIdAuth {
  createdAt: timestamptz!
  hintCode: String
  id: uuid!
  merchantId: bigint!
  orderRef: String
  polledAt: timestamptz!
  purchaseOrderId: String!
  status: BankidAuthStatusEnum!
}

"""
Boolean expression to filter rows from the table "runtime.bankid_auth". All fields are combined with a logical 'AND'.
"""
input BankIdAuthBoolExp {
  _and: [BankIdAuthBoolExp!]
  _not: BankIdAuthBoolExp
  _or: [BankIdAuthBoolExp!]
  createdAt: TimestamptzComparisonExp
  hintCode: StringComparisonExp
  id: UuidComparisonExp
  merchantId: BigintComparisonExp
  orderRef: StringComparisonExp
  polledAt: TimestamptzComparisonExp
  purchaseOrderId: StringComparisonExp
  status: BankidAuthStatusEnumComparisonExp
}

"""Ordering options when selecting data from "runtime.bankid_auth"."""
input BankIdAuthOrderBy {
  createdAt: OrderBy
  hintCode: OrderBy
  id: OrderBy
  merchantId: OrderBy
  orderRef: OrderBy
  polledAt: OrderBy
  purchaseOrderId: OrderBy
  status: OrderBy
}

"""
select columns of table "runtime.bankid_auth"
"""
enum BankIdAuthSelectColumn {
  """column name"""
  createdAt

  """column name"""
  hintCode

  """column name"""
  id

  """column name"""
  merchantId

  """column name"""
  orderRef

  """column name"""
  polledAt

  """column name"""
  purchaseOrderId

  """column name"""
  status
}

enum BankidAuthStatusEnum {
  CANCELLED
  CANCELLING
  COMPLETE
  FAILED
  INITIALIZING
  PENDING
}

"""
Boolean expression to compare columns of type "BankidAuthStatusEnum". All fields are combined with logical 'AND'.
"""
input BankidAuthStatusEnumComparisonExp {
  _eq: BankidAuthStatusEnum
  _in: [BankidAuthStatusEnum!]
  _isNull: Boolean
  _neq: BankidAuthStatusEnum
  _nin: [BankidAuthStatusEnum!]
}

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input BigintComparisonExp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _isNull: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""Block customer from buying from merchant by customer id"""
input BlockCustomerByIdInput {
  """Id of the customer"""
  customerId: bigint!
}

"""Block customer from buying from merchant"""
input BlockCustomerInput {
  """Email of the customer"""
  customerEmail: String

  """SSN of the customer"""
  customerSsn: String
}

"""Blocked customers"""
type BlockCustomerResult {
  """Email of the customer"""
  customerEmail: String

  """ID of the customer"""
  customerId: Int

  """SSN of the customer"""
  customerSsn: String

  """ID of the merchant blocking the customer"""
  merchantId: Int!
}

"""Arguments to for a blockToken mutation"""
input BlockTokenInput {
  """The merchant requesting for the reports."""
  merchantId: bigint!

  """
  The id of the token to block, can be found inside the token as "tid".
  Must be a valid UUID string.
  """
  tokenId: String!
}

"""The result of a blockToken mutation."""
type BlockTokenResult {
  """
  The number of tokens blocked in this request, if no tokens are blocked, verify that the provided uuid is correct and that the token you are trying to block is not already expired.
  """
  tokensBlocked: Int!
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input BooleanComparisonExp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _isNull: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Captures made by the merchant. A capture is a partial or total shipment of a purchase. Capturing means that a customer has to pay for the item(s) that were captured (recorded) in this operation.

"""
type Capture {
  createdAt: timestamptz!
  description: String
  id: bigint!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinctOn: [CaptureItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CaptureItemOrderBy!]

    """filter the rows returned"""
    where: CaptureItemBoolExp
  ): [CaptureItem!]!
  merchantId: bigint!
  purchaseId: bigint!

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: bigint!
}

"""
aggregated selection of "marketplace.purchase_capture"
"""
type CaptureAggregate {
  aggregate: CaptureAggregateFields
  nodes: [Capture!]!
}

"""
aggregate fields of "marketplace.purchase_capture"
"""
type CaptureAggregateFields {
  avg: CaptureAvgFields
  count(columns: [CaptureSelectColumn!], distinct: Boolean): Int!
  max: CaptureMaxFields
  min: CaptureMinFields
  stddev: CaptureStddevFields
  stddevPop: CaptureStddevPopFields
  stddevSamp: CaptureStddevSampFields
  sum: CaptureSumFields
  varPop: CaptureVarPopFields
  varSamp: CaptureVarSampFields
  variance: CaptureVarianceFields
}

"""
order by aggregate values of table "marketplace.purchase_capture"
"""
input CaptureAggregateOrderBy {
  avg: CaptureAvgOrderBy
  count: OrderBy
  max: CaptureMaxOrderBy
  min: CaptureMinOrderBy
  stddev: CaptureStddevOrderBy
  stddev_pop: CaptureStddevPopOrderBy
  stddev_samp: CaptureStddevSampOrderBy
  sum: CaptureSumOrderBy
  var_pop: CaptureVarPopOrderBy
  var_samp: CaptureVarSampOrderBy
  variance: CaptureVarianceOrderBy
}

"""aggregate avg on columns"""
type CaptureAvgFields {
  id: Float
  merchantId: Float
  purchaseId: Float

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: Float
}

"""
order by avg() on columns of table "marketplace.purchase_capture"
"""
input CaptureAvgOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.purchase_capture". All fields are combined with a logical 'AND'.
"""
input CaptureBoolExp {
  _and: [CaptureBoolExp!]
  _not: CaptureBoolExp
  _or: [CaptureBoolExp!]
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  id: BigintComparisonExp
  items: CaptureItemBoolExp
  merchantId: BigintComparisonExp
  purchaseId: BigintComparisonExp
  totalAmount: BigintComparisonExp
}

"""
Record of items purchased, for which the merchant has sent a capture request.
"""
type CaptureItem {
  """An object relationship"""
  item: PurchaseItem!
  merchantId: bigint!

  """Unit price including tax in minor units."""
  pricePerItem: bigint!
  purchaseCaptureId: bigint!
  purchaseId: bigint!

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: smallint!

  """
  Item identification either provided by the merchant as bar code or generated by us.
  """
  reference: citext!

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: smallint!

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: bigint!

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: bigint!
}

"""
order by aggregate values of table "marketplace.purchase_capture_item"
"""
input CaptureItemAggregateOrderBy {
  avg: CaptureItemAvgOrderBy
  count: OrderBy
  max: CaptureItemMaxOrderBy
  min: CaptureItemMinOrderBy
  stddev: CaptureItemStddevOrderBy
  stddev_pop: CaptureItemStddevPopOrderBy
  stddev_samp: CaptureItemStddevSampOrderBy
  sum: CaptureItemSumOrderBy
  var_pop: CaptureItemVarPopOrderBy
  var_samp: CaptureItemVarSampOrderBy
  variance: CaptureItemVarianceOrderBy
}

"""
order by avg() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemAvgOrderBy {
  merchantId: OrderBy

  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.purchase_capture_item". All fields are combined with a logical 'AND'.
"""
input CaptureItemBoolExp {
  _and: [CaptureItemBoolExp!]
  _not: CaptureItemBoolExp
  _or: [CaptureItemBoolExp!]
  item: PurchaseItemBoolExp
  merchantId: BigintComparisonExp
  pricePerItem: BigintComparisonExp
  purchaseCaptureId: BigintComparisonExp
  purchaseId: BigintComparisonExp
  quantity: SmallintComparisonExp
  reference: CitextComparisonExp
  taxRate: SmallintComparisonExp
  totalAmount: BigintComparisonExp
  totalTaxAmount: BigintComparisonExp
}

"""
order by max() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemMaxOrderBy {
  merchantId: OrderBy

  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """
  Item identification either provided by the merchant as bar code or generated by us.
  """
  reference: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
order by min() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemMinOrderBy {
  merchantId: OrderBy

  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """
  Item identification either provided by the merchant as bar code or generated by us.
  """
  reference: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
Ordering options when selecting data from "marketplace.purchase_capture_item".
"""
input CaptureItemOrderBy {
  item: PurchaseItemOrderBy
  merchantId: OrderBy
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  reference: OrderBy
  taxRate: OrderBy
  totalAmount: OrderBy
  totalTaxAmount: OrderBy
}

"""
select columns of table "marketplace.purchase_capture_item"
"""
enum CaptureItemSelectColumn {
  """column name"""
  merchantId

  """column name"""
  pricePerItem

  """column name"""
  purchaseCaptureId

  """column name"""
  purchaseId

  """column name"""
  quantity

  """column name"""
  reference

  """column name"""
  taxRate

  """column name"""
  totalAmount

  """column name"""
  totalTaxAmount
}

"""
order by stddev() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemStddevOrderBy {
  merchantId: OrderBy

  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
order by stddev_pop() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemStddevPopOrderBy {
  merchantId: OrderBy

  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
order by stddev_samp() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemStddevSampOrderBy {
  merchantId: OrderBy

  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
order by sum() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemSumOrderBy {
  merchantId: OrderBy

  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
order by var_pop() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemVarPopOrderBy {
  merchantId: OrderBy

  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
order by var_samp() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemVarSampOrderBy {
  merchantId: OrderBy

  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
order by variance() on columns of table "marketplace.purchase_capture_item"
"""
input CaptureItemVarianceOrderBy {
  merchantId: OrderBy

  """Unit price including tax in minor units."""
  pricePerItem: OrderBy
  purchaseCaptureId: OrderBy
  purchaseId: OrderBy

  """
  Number of items captured by the merchant that share the same reference.
  """
  quantity: OrderBy

  """The tax rate in percent with two implicit decimals. Non-negative."""
  taxRate: OrderBy

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""aggregate max on columns"""
type CaptureMaxFields {
  createdAt: timestamptz
  description: String
  id: bigint
  merchantId: bigint
  purchaseId: bigint

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: bigint
}

"""
order by max() on columns of table "marketplace.purchase_capture"
"""
input CaptureMaxOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""aggregate min on columns"""
type CaptureMinFields {
  createdAt: timestamptz
  description: String
  id: bigint
  merchantId: bigint
  purchaseId: bigint

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: bigint
}

"""
order by min() on columns of table "marketplace.purchase_capture"
"""
input CaptureMinOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""
Ordering options when selecting data from "marketplace.purchase_capture".
"""
input CaptureOrderBy {
  createdAt: OrderBy
  description: OrderBy
  id: OrderBy
  itemsAggregate: CaptureItemAggregateOrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
  totalAmount: OrderBy
}

"""
select columns of table "marketplace.purchase_capture"
"""
enum CaptureSelectColumn {
  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  id

  """column name"""
  merchantId

  """column name"""
  purchaseId

  """column name"""
  totalAmount
}

enum CaptureStatusEnum {
  """Purchase already captured."""
  CAPTURED

  """Something went wrong."""
  ERROR
}

"""
Boolean expression to compare columns of type "CaptureStatusEnum". All fields are combined with logical 'AND'.
"""
input CaptureStatusEnumComparisonExp {
  _eq: CaptureStatusEnum
  _in: [CaptureStatusEnum!]
  _isNull: Boolean
  _neq: CaptureStatusEnum
  _nin: [CaptureStatusEnum!]
}

"""aggregate stddev on columns"""
type CaptureStddevFields {
  id: Float
  merchantId: Float
  purchaseId: Float

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: Float
}

"""
order by stddev() on columns of table "marketplace.purchase_capture"
"""
input CaptureStddevOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""aggregate stddev_pop on columns"""
type CaptureStddevPopFields {
  id: Float
  merchantId: Float
  purchaseId: Float

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: Float
}

"""
order by stddev_pop() on columns of table "marketplace.purchase_capture"
"""
input CaptureStddevPopOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""aggregate stddev_samp on columns"""
type CaptureStddevSampFields {
  id: Float
  merchantId: Float
  purchaseId: Float

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: Float
}

"""
order by stddev_samp() on columns of table "marketplace.purchase_capture"
"""
input CaptureStddevSampOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""aggregate sum on columns"""
type CaptureSumFields {
  id: bigint
  merchantId: bigint
  purchaseId: bigint

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: bigint
}

"""
order by sum() on columns of table "marketplace.purchase_capture"
"""
input CaptureSumOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""aggregate var_pop on columns"""
type CaptureVarPopFields {
  id: Float
  merchantId: Float
  purchaseId: Float

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: Float
}

"""
order by var_pop() on columns of table "marketplace.purchase_capture"
"""
input CaptureVarPopOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""aggregate var_samp on columns"""
type CaptureVarSampFields {
  id: Float
  merchantId: Float
  purchaseId: Float

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: Float
}

"""
order by var_samp() on columns of table "marketplace.purchase_capture"
"""
input CaptureVarSampOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""aggregate variance on columns"""
type CaptureVarianceFields {
  id: Float
  merchantId: Float
  purchaseId: Float

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: Float
}

"""
order by variance() on columns of table "marketplace.purchase_capture"
"""
input CaptureVarianceOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """
  Total amount (including tax and discounts) in minor units for all the items being captured.
  """
  totalAmount: OrderBy
}

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input CitextComparisonExp {
  _eq: citext
  _gt: citext
  _gte: citext

  """does the column match the given case-insensitive pattern"""
  _ilike: citext
  _in: [citext!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: citext
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: citext
  _lt: citext
  _lte: citext
  _neq: citext

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: citext
  _nin: [citext!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: citext

  """does the column NOT match the given pattern"""
  _nlike: citext

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: citext

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: citext

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: citext

  """does the column match the given SQL regular expression"""
  _similar: citext
}

"""Supported countries"""
enum Country {
  DK
  FI
  IS
  NO
  SE
}

"""
Boolean expression to compare columns of type "country". All fields are combined with logical 'AND'.
"""
input CountryComparisonExp {
  _eq: country
  _gt: country
  _gte: country
  _in: [country!]
  _isNull: Boolean
  _lt: country
  _lte: country
  _neq: country
  _nin: [country!]
}

"""Describes the schema for credit card details"""
type CreditCardDetails {
  cardCountry: String
  cardExpiryDate: date
  cardNumber: String
  cardType: String
  threeDSecureStatus: Boolean
}

"""
order by aggregate values of table "runtime.transaction_credit_card_details"
"""
input CreditCardDetailsAggregateOrderBy {
  count: OrderBy
  max: CreditCardDetailsMaxOrderBy
  min: CreditCardDetailsMinOrderBy
}

"""
Boolean expression to filter rows from the table "runtime.transaction_credit_card_details". All fields are combined with a logical 'AND'.
"""
input CreditCardDetailsBoolExp {
  _and: [CreditCardDetailsBoolExp!]
  _not: CreditCardDetailsBoolExp
  _or: [CreditCardDetailsBoolExp!]
  cardCountry: StringComparisonExp
  cardExpiryDate: DateComparisonExp
  cardNumber: StringComparisonExp
  cardType: StringComparisonExp
  threeDSecureStatus: BooleanComparisonExp
}

"""
order by max() on columns of table "runtime.transaction_credit_card_details"
"""
input CreditCardDetailsMaxOrderBy {
  cardCountry: OrderBy
  cardExpiryDate: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
}

"""
order by min() on columns of table "runtime.transaction_credit_card_details"
"""
input CreditCardDetailsMinOrderBy {
  cardCountry: OrderBy
  cardExpiryDate: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
}

"""
Ordering options when selecting data from "runtime.transaction_credit_card_details".
"""
input CreditCardDetailsOrderBy {
  cardCountry: OrderBy
  cardExpiryDate: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
  threeDSecureStatus: OrderBy
}

"""
select columns of table "runtime.transaction_credit_card_details"
"""
enum CreditCardDetailsSelectColumn {
  """column name"""
  cardCountry

  """column name"""
  cardExpiryDate

  """column name"""
  cardNumber

  """column name"""
  cardType

  """column name"""
  threeDSecureStatus
}

"""
Boolean expression to compare columns of type "currency". All fields are combined with logical 'AND'.
"""
input CurrencyComparisonExp {
  _eq: currency
  _gt: currency
  _gte: currency
  _in: [currency!]
  _isNull: Boolean
  _lt: currency
  _lte: currency
  _neq: currency
  _nin: [currency!]
}

"""
columns and relationships of "payment_gateway.current_capture_status"
"""
type CurrentCaptureStatus {
  enteredAt: timestamptz!
  status: PaymentCaptureStatusEnum!
}

"""
order by aggregate values of table "payment_gateway.current_capture_status"
"""
input CurrentCaptureStatusAggregateOrderBy {
  count: OrderBy
  max: CurrentCaptureStatusMaxOrderBy
  min: CurrentCaptureStatusMinOrderBy
}

"""
Boolean expression to filter rows from the table "payment_gateway.current_capture_status". All fields are combined with a logical 'AND'.
"""
input CurrentCaptureStatusBoolExp {
  _and: [CurrentCaptureStatusBoolExp!]
  _not: CurrentCaptureStatusBoolExp
  _or: [CurrentCaptureStatusBoolExp!]
  enteredAt: TimestamptzComparisonExp
  status: PaymentCaptureStatusEnumComparisonExp
}

"""
order by max() on columns of table "payment_gateway.current_capture_status"
"""
input CurrentCaptureStatusMaxOrderBy {
  enteredAt: OrderBy
}

"""
order by min() on columns of table "payment_gateway.current_capture_status"
"""
input CurrentCaptureStatusMinOrderBy {
  enteredAt: OrderBy
}

"""
Ordering options when selecting data from "payment_gateway.current_capture_status".
"""
input CurrentCaptureStatusOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
select columns of table "payment_gateway.current_capture_status"
"""
enum CurrentCaptureStatusSelectColumn {
  """column name"""
  enteredAt

  """column name"""
  status
}

"""
columns and relationships of "marketplace.current_instalment_status"
"""
type CurrentInstalmentStatus {
  enteredAt: timestamptz!
  status: citext!
}

"""
order by aggregate values of table "marketplace.current_instalment_status"
"""
input CurrentInstalmentStatusAggregateOrderBy {
  count: OrderBy
  max: CurrentInstalmentStatusMaxOrderBy
  min: CurrentInstalmentStatusMinOrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.current_instalment_status". All fields are combined with a logical 'AND'.
"""
input CurrentInstalmentStatusBoolExp {
  _and: [CurrentInstalmentStatusBoolExp!]
  _not: CurrentInstalmentStatusBoolExp
  _or: [CurrentInstalmentStatusBoolExp!]
  enteredAt: TimestamptzComparisonExp
  status: CitextComparisonExp
}

"""
order by max() on columns of table "marketplace.current_instalment_status"
"""
input CurrentInstalmentStatusMaxOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
order by min() on columns of table "marketplace.current_instalment_status"
"""
input CurrentInstalmentStatusMinOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
Ordering options when selecting data from "marketplace.current_instalment_status".
"""
input CurrentInstalmentStatusOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
select columns of table "marketplace.current_instalment_status"
"""
enum CurrentInstalmentStatusSelectColumn {
  """column name"""
  enteredAt

  """column name"""
  status
}

"""
columns and relationships of "runtime.current_payment_status"
"""
type CurrentPaymentStatus {
  enteredAt: timestamptz!
  status: PaymentStatusEnum!
}

"""
order by aggregate values of table "runtime.current_payment_status"
"""
input CurrentPaymentStatusAggregateOrderBy {
  count: OrderBy
  max: CurrentPaymentStatusMaxOrderBy
  min: CurrentPaymentStatusMinOrderBy
}

"""
Boolean expression to filter rows from the table "runtime.current_payment_status". All fields are combined with a logical 'AND'.
"""
input CurrentPaymentStatusBoolExp {
  _and: [CurrentPaymentStatusBoolExp!]
  _not: CurrentPaymentStatusBoolExp
  _or: [CurrentPaymentStatusBoolExp!]
  enteredAt: TimestamptzComparisonExp
  status: PaymentStatusEnumComparisonExp
}

"""
order by max() on columns of table "runtime.current_payment_status"
"""
input CurrentPaymentStatusMaxOrderBy {
  enteredAt: OrderBy
}

"""
order by min() on columns of table "runtime.current_payment_status"
"""
input CurrentPaymentStatusMinOrderBy {
  enteredAt: OrderBy
}

"""
Ordering options when selecting data from "runtime.current_payment_status".
"""
input CurrentPaymentStatusOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
select columns of table "runtime.current_payment_status"
"""
enum CurrentPaymentStatusSelectColumn {
  """column name"""
  enteredAt

  """column name"""
  status
}

"""Statuses for the purchase order"""
type CurrentPurchaseOrderStatus {
  enteredAt: timestamptz!
  status: OrderStatusEnum!
}

"""
order by aggregate values of table "checkout.current_status"
"""
input CurrentPurchaseOrderStatusAggregateOrderBy {
  count: OrderBy
  max: CurrentPurchaseOrderStatusMaxOrderBy
  min: CurrentPurchaseOrderStatusMinOrderBy
}

"""
Boolean expression to filter rows from the table "checkout.current_status". All fields are combined with a logical 'AND'.
"""
input CurrentPurchaseOrderStatusBoolExp {
  _and: [CurrentPurchaseOrderStatusBoolExp!]
  _not: CurrentPurchaseOrderStatusBoolExp
  _or: [CurrentPurchaseOrderStatusBoolExp!]
  enteredAt: TimestamptzComparisonExp
  status: OrderStatusEnumComparisonExp
}

"""
order by max() on columns of table "checkout.current_status"
"""
input CurrentPurchaseOrderStatusMaxOrderBy {
  enteredAt: OrderBy
}

"""
order by min() on columns of table "checkout.current_status"
"""
input CurrentPurchaseOrderStatusMinOrderBy {
  enteredAt: OrderBy
}

"""Ordering options when selecting data from "checkout.current_status"."""
input CurrentPurchaseOrderStatusOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
select columns of table "checkout.current_status"
"""
enum CurrentPurchaseOrderStatusSelectColumn {
  """column name"""
  enteredAt

  """column name"""
  status
}

"""
columns and relationships of "marketplace.current_purchase_status"
"""
type CurrentPurchaseStatus {
  enteredAt: timestamptz!
  status: PurchaseStatusEnum!
}

"""
order by aggregate values of table "marketplace.current_purchase_status"
"""
input CurrentPurchaseStatusAggregateOrderBy {
  count: OrderBy
  max: CurrentPurchaseStatusMaxOrderBy
  min: CurrentPurchaseStatusMinOrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.current_purchase_status". All fields are combined with a logical 'AND'.
"""
input CurrentPurchaseStatusBoolExp {
  _and: [CurrentPurchaseStatusBoolExp!]
  _not: CurrentPurchaseStatusBoolExp
  _or: [CurrentPurchaseStatusBoolExp!]
  enteredAt: TimestamptzComparisonExp
  status: PurchaseStatusEnumComparisonExp
}

"""
order by max() on columns of table "marketplace.current_purchase_status"
"""
input CurrentPurchaseStatusMaxOrderBy {
  enteredAt: OrderBy
}

"""
order by min() on columns of table "marketplace.current_purchase_status"
"""
input CurrentPurchaseStatusMinOrderBy {
  enteredAt: OrderBy
}

"""
Ordering options when selecting data from "marketplace.current_purchase_status".
"""
input CurrentPurchaseStatusOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
select columns of table "marketplace.current_purchase_status"
"""
enum CurrentPurchaseStatusSelectColumn {
  """column name"""
  enteredAt

  """column name"""
  status
}

"""
columns and relationships of "payment_gateway.current_refund_status"
"""
type CurrentRefundStatus {
  enteredAt: timestamptz!
  status: RefundStatusEnum!
}

"""
order by aggregate values of table "payment_gateway.current_refund_status"
"""
input CurrentRefundStatusAggregateOrderBy {
  count: OrderBy
  max: CurrentRefundStatusMaxOrderBy
  min: CurrentRefundStatusMinOrderBy
}

"""
Boolean expression to filter rows from the table "payment_gateway.current_refund_status". All fields are combined with a logical 'AND'.
"""
input CurrentRefundStatusBoolExp {
  _and: [CurrentRefundStatusBoolExp!]
  _not: CurrentRefundStatusBoolExp
  _or: [CurrentRefundStatusBoolExp!]
  enteredAt: TimestamptzComparisonExp
  status: RefundStatusEnumComparisonExp
}

"""
order by max() on columns of table "payment_gateway.current_refund_status"
"""
input CurrentRefundStatusMaxOrderBy {
  enteredAt: OrderBy
}

"""
order by min() on columns of table "payment_gateway.current_refund_status"
"""
input CurrentRefundStatusMinOrderBy {
  enteredAt: OrderBy
}

"""
Ordering options when selecting data from "payment_gateway.current_refund_status".
"""
input CurrentRefundStatusOrderBy {
  enteredAt: OrderBy
  status: OrderBy
}

"""
select columns of table "payment_gateway.current_refund_status"
"""
enum CurrentRefundStatusSelectColumn {
  """column name"""
  enteredAt

  """column name"""
  status
}

"""A customer is a real person who can make purchases."""
type Customer {
  """An array relationship"""
  addresses(
    """distinct select on columns"""
    distinctOn: [CustomerAddressSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerAddressOrderBy!]

    """filter the rows returned"""
    where: CustomerAddressBoolExp
  ): [CustomerAddress!]!

  """An array relationship"""
  blocked(
    """distinct select on columns"""
    distinctOn: [CustomerBanSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerBanOrderBy!]

    """filter the rows returned"""
    where: CustomerBanBoolExp
  ): [CustomerBan!]!
  createdAt: timestamptz!

  """An array relationship"""
  emails(
    """distinct select on columns"""
    distinctOn: [CustomerEmailSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerEmailOrderBy!]

    """filter the rows returned"""
    where: CustomerEmailBoolExp
  ): [CustomerEmail!]!
  firstName: String!

  """Serial id for each customer"""
  id: bigint!
  lastName: String!
  locale: spoken_lang!

  """An object relationship"""
  merchant: Merchant!

  """Which merchant does this customer belong to."""
  merchantId: bigint!

  """An array relationship"""
  phoneNumbers(
    """distinct select on columns"""
    distinctOn: [CustomerPhoneNumberSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerPhoneNumberOrderBy!]

    """filter the rows returned"""
    where: CustomerPhoneNumberBoolExp
  ): [CustomerPhoneNumber!]!

  """An array relationship"""
  purchases(
    """distinct select on columns"""
    distinctOn: [PurchaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseOrderBy!]

    """filter the rows returned"""
    where: PurchaseBoolExp
  ): [Purchase!]!

  """An aggregate relationship"""
  purchasesAggregate(
    """distinct select on columns"""
    distinctOn: [PurchaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseOrderBy!]

    """filter the rows returned"""
    where: PurchaseBoolExp
  ): PurchaseAggregate!
}

"""
Addresses for a customer which may be their residence or a place they have shipped to.
"""
type CustomerAddress {
  """Address of the customer."""
  addressLine1: String!

  """Line 2 of the address"""
  addressLine2: String

  """Care of"""
  careOf: String
  city: String!
  country: country!
  createdAt: timestamptz!

  """An object relationship"""
  customer: Customer!
  email: citext!
  firstName: String!

  """
  Whether or not we have validated this address is safely associated with a customer
  """
  isKnownSafe: Boolean!

  """
  Whether or not the address is just a mailbox without a real person living there
  """
  isPostbox: Boolean!

  """
  The primary address for the customer, which may be their place of residence.
          There can be only one primary address for each customer under one merchant.
  """
  isPrimary: Boolean!
  lastName: String!
  merchantId: bigint!
  phoneNumber: packed_phone_number!
  postalCode: String!

  """State or region."""
  region: String

  """Street name of the address. Not to be combined with address_line."""
  streetName: String

  """Street number. Not to be combined with address_line."""
  streetNumber: String

  """Mr., Ms, Mrs., Miss. ..."""
  title: String
}

"""
order by aggregate values of table "dna.customer_address"
"""
input CustomerAddressAggregateOrderBy {
  avg: CustomerAddressAvgOrderBy
  count: OrderBy
  max: CustomerAddressMaxOrderBy
  min: CustomerAddressMinOrderBy
  stddev: CustomerAddressStddevOrderBy
  stddev_pop: CustomerAddressStddevPopOrderBy
  stddev_samp: CustomerAddressStddevSampOrderBy
  sum: CustomerAddressSumOrderBy
  var_pop: CustomerAddressVarPopOrderBy
  var_samp: CustomerAddressVarSampOrderBy
  variance: CustomerAddressVarianceOrderBy
}

"""
order by avg() on columns of table "dna.customer_address"
"""
input CustomerAddressAvgOrderBy {
  merchantId: OrderBy
}

"""
Boolean expression to filter rows from the table "dna.customer_address". All fields are combined with a logical 'AND'.
"""
input CustomerAddressBoolExp {
  _and: [CustomerAddressBoolExp!]
  _not: CustomerAddressBoolExp
  _or: [CustomerAddressBoolExp!]
  addressLine1: StringComparisonExp
  addressLine2: StringComparisonExp
  careOf: StringComparisonExp
  city: StringComparisonExp
  country: CountryComparisonExp
  createdAt: TimestamptzComparisonExp
  customer: CustomerBoolExp
  email: CitextComparisonExp
  firstName: StringComparisonExp
  isKnownSafe: BooleanComparisonExp
  isPostbox: BooleanComparisonExp
  isPrimary: BooleanComparisonExp
  lastName: StringComparisonExp
  merchantId: BigintComparisonExp
  phoneNumber: PackedPhoneNumberComparisonExp
  postalCode: StringComparisonExp
  region: StringComparisonExp
  streetName: StringComparisonExp
  streetNumber: StringComparisonExp
  title: StringComparisonExp
}

"""
order by max() on columns of table "dna.customer_address"
"""
input CustomerAddressMaxOrderBy {
  """Address of the customer."""
  addressLine1: OrderBy

  """Line 2 of the address"""
  addressLine2: OrderBy

  """Care of"""
  careOf: OrderBy
  city: OrderBy
  createdAt: OrderBy
  email: OrderBy
  firstName: OrderBy
  lastName: OrderBy
  merchantId: OrderBy
  postalCode: OrderBy

  """State or region."""
  region: OrderBy

  """Street name of the address. Not to be combined with address_line."""
  streetName: OrderBy

  """Street number. Not to be combined with address_line."""
  streetNumber: OrderBy

  """Mr., Ms, Mrs., Miss. ..."""
  title: OrderBy
}

"""
order by min() on columns of table "dna.customer_address"
"""
input CustomerAddressMinOrderBy {
  """Address of the customer."""
  addressLine1: OrderBy

  """Line 2 of the address"""
  addressLine2: OrderBy

  """Care of"""
  careOf: OrderBy
  city: OrderBy
  createdAt: OrderBy
  email: OrderBy
  firstName: OrderBy
  lastName: OrderBy
  merchantId: OrderBy
  postalCode: OrderBy

  """State or region."""
  region: OrderBy

  """Street name of the address. Not to be combined with address_line."""
  streetName: OrderBy

  """Street number. Not to be combined with address_line."""
  streetNumber: OrderBy

  """Mr., Ms, Mrs., Miss. ..."""
  title: OrderBy
}

"""Ordering options when selecting data from "dna.customer_address"."""
input CustomerAddressOrderBy {
  addressLine1: OrderBy
  addressLine2: OrderBy
  careOf: OrderBy
  city: OrderBy
  country: OrderBy
  createdAt: OrderBy
  customer: CustomerOrderBy
  email: OrderBy
  firstName: OrderBy
  isKnownSafe: OrderBy
  isPostbox: OrderBy
  isPrimary: OrderBy
  lastName: OrderBy
  merchantId: OrderBy
  phoneNumber: OrderBy
  postalCode: OrderBy
  region: OrderBy
  streetName: OrderBy
  streetNumber: OrderBy
  title: OrderBy
}

"""
select columns of table "dna.customer_address"
"""
enum CustomerAddressSelectColumn {
  """column name"""
  addressLine1

  """column name"""
  addressLine2

  """column name"""
  careOf

  """column name"""
  city

  """column name"""
  country

  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  firstName

  """column name"""
  isKnownSafe

  """column name"""
  isPostbox

  """column name"""
  isPrimary

  """column name"""
  lastName

  """column name"""
  merchantId

  """column name"""
  phoneNumber

  """column name"""
  postalCode

  """column name"""
  region

  """column name"""
  streetName

  """column name"""
  streetNumber

  """column name"""
  title
}

"""
order by stddev() on columns of table "dna.customer_address"
"""
input CustomerAddressStddevOrderBy {
  merchantId: OrderBy
}

"""
order by stddev_pop() on columns of table "dna.customer_address"
"""
input CustomerAddressStddevPopOrderBy {
  merchantId: OrderBy
}

"""
order by stddev_samp() on columns of table "dna.customer_address"
"""
input CustomerAddressStddevSampOrderBy {
  merchantId: OrderBy
}

"""
order by sum() on columns of table "dna.customer_address"
"""
input CustomerAddressSumOrderBy {
  merchantId: OrderBy
}

"""
order by var_pop() on columns of table "dna.customer_address"
"""
input CustomerAddressVarPopOrderBy {
  merchantId: OrderBy
}

"""
order by var_samp() on columns of table "dna.customer_address"
"""
input CustomerAddressVarSampOrderBy {
  merchantId: OrderBy
}

"""
order by variance() on columns of table "dna.customer_address"
"""
input CustomerAddressVarianceOrderBy {
  merchantId: OrderBy
}

"""
aggregated selection of "dna.customer"
"""
type CustomerAggregate {
  aggregate: CustomerAggregateFields
  nodes: [Customer!]!
}

"""
aggregate fields of "dna.customer"
"""
type CustomerAggregateFields {
  avg: CustomerAvgFields
  count(columns: [CustomerSelectColumn!], distinct: Boolean): Int!
  max: CustomerMaxFields
  min: CustomerMinFields
  stddev: CustomerStddevFields
  stddevPop: CustomerStddevPopFields
  stddevSamp: CustomerStddevSampFields
  sum: CustomerSumFields
  varPop: CustomerVarPopFields
  varSamp: CustomerVarSampFields
  variance: CustomerVarianceFields
}

"""aggregate avg on columns"""
type CustomerAvgFields {
  """Serial id for each customer"""
  id: Float

  """Which merchant does this customer belong to."""
  merchantId: Float
}

"""A Customer Block directive based on person number or email"""
type CustomerBan {
  """An object relationship"""
  customer: Customer
  customerEmail: citext
  customerSsn: citext
  merchantId: bigint
}

"""
order by aggregate values of table "dna.blocked_customer"
"""
input CustomerBanAggregateOrderBy {
  avg: CustomerBanAvgOrderBy
  count: OrderBy
  max: CustomerBanMaxOrderBy
  min: CustomerBanMinOrderBy
  stddev: CustomerBanStddevOrderBy
  stddev_pop: CustomerBanStddevPopOrderBy
  stddev_samp: CustomerBanStddevSampOrderBy
  sum: CustomerBanSumOrderBy
  var_pop: CustomerBanVarPopOrderBy
  var_samp: CustomerBanVarSampOrderBy
  variance: CustomerBanVarianceOrderBy
}

"""
order by avg() on columns of table "dna.blocked_customer"
"""
input CustomerBanAvgOrderBy {
  merchantId: OrderBy
}

"""
Boolean expression to filter rows from the table "dna.blocked_customer". All fields are combined with a logical 'AND'.
"""
input CustomerBanBoolExp {
  _and: [CustomerBanBoolExp!]
  _not: CustomerBanBoolExp
  _or: [CustomerBanBoolExp!]
  customer: CustomerBoolExp
  customerEmail: CitextComparisonExp
  customerSsn: CitextComparisonExp
  merchantId: BigintComparisonExp
}

"""
order by max() on columns of table "dna.blocked_customer"
"""
input CustomerBanMaxOrderBy {
  customerEmail: OrderBy
  customerSsn: OrderBy
  merchantId: OrderBy
}

"""
order by min() on columns of table "dna.blocked_customer"
"""
input CustomerBanMinOrderBy {
  customerEmail: OrderBy
  customerSsn: OrderBy
  merchantId: OrderBy
}

"""Ordering options when selecting data from "dna.blocked_customer"."""
input CustomerBanOrderBy {
  customer: CustomerOrderBy
  customerEmail: OrderBy
  customerSsn: OrderBy
  merchantId: OrderBy
}

"""
select columns of table "dna.blocked_customer"
"""
enum CustomerBanSelectColumn {
  """column name"""
  customerEmail

  """column name"""
  customerSsn

  """column name"""
  merchantId
}

"""
order by stddev() on columns of table "dna.blocked_customer"
"""
input CustomerBanStddevOrderBy {
  merchantId: OrderBy
}

"""
order by stddev_pop() on columns of table "dna.blocked_customer"
"""
input CustomerBanStddevPopOrderBy {
  merchantId: OrderBy
}

"""
order by stddev_samp() on columns of table "dna.blocked_customer"
"""
input CustomerBanStddevSampOrderBy {
  merchantId: OrderBy
}

"""
order by sum() on columns of table "dna.blocked_customer"
"""
input CustomerBanSumOrderBy {
  merchantId: OrderBy
}

"""
order by var_pop() on columns of table "dna.blocked_customer"
"""
input CustomerBanVarPopOrderBy {
  merchantId: OrderBy
}

"""
order by var_samp() on columns of table "dna.blocked_customer"
"""
input CustomerBanVarSampOrderBy {
  merchantId: OrderBy
}

"""
order by variance() on columns of table "dna.blocked_customer"
"""
input CustomerBanVarianceOrderBy {
  merchantId: OrderBy
}

"""
Boolean expression to filter rows from the table "dna.customer". All fields are combined with a logical 'AND'.
"""
input CustomerBoolExp {
  _and: [CustomerBoolExp!]
  _not: CustomerBoolExp
  _or: [CustomerBoolExp!]
  addresses: CustomerAddressBoolExp
  blocked: CustomerBanBoolExp
  createdAt: TimestamptzComparisonExp
  emails: CustomerEmailBoolExp
  firstName: StringComparisonExp
  id: BigintComparisonExp
  lastName: StringComparisonExp
  locale: SpokenLangComparisonExp
  merchant: MerchantBoolExp
  merchantId: BigintComparisonExp
  phoneNumbers: CustomerPhoneNumberBoolExp
  purchases: PurchaseBoolExp
}

"""Emails associated with the customer."""
type CustomerEmail {
  createdAt: timestamptz!

  """Email address of the customer."""
  email: citext!

  """
  
          Whether this email address is the primary email for the customer.
          There should only be one primary email per customer.
      
  """
  isPrimary: Boolean!
  merchantId: bigint!
}

"""
order by aggregate values of table "dna.customer_email"
"""
input CustomerEmailAggregateOrderBy {
  avg: CustomerEmailAvgOrderBy
  count: OrderBy
  max: CustomerEmailMaxOrderBy
  min: CustomerEmailMinOrderBy
  stddev: CustomerEmailStddevOrderBy
  stddev_pop: CustomerEmailStddevPopOrderBy
  stddev_samp: CustomerEmailStddevSampOrderBy
  sum: CustomerEmailSumOrderBy
  var_pop: CustomerEmailVarPopOrderBy
  var_samp: CustomerEmailVarSampOrderBy
  variance: CustomerEmailVarianceOrderBy
}

"""
order by avg() on columns of table "dna.customer_email"
"""
input CustomerEmailAvgOrderBy {
  merchantId: OrderBy
}

"""
Boolean expression to filter rows from the table "dna.customer_email". All fields are combined with a logical 'AND'.
"""
input CustomerEmailBoolExp {
  _and: [CustomerEmailBoolExp!]
  _not: CustomerEmailBoolExp
  _or: [CustomerEmailBoolExp!]
  createdAt: TimestamptzComparisonExp
  email: CitextComparisonExp
  isPrimary: BooleanComparisonExp
  merchantId: BigintComparisonExp
}

"""
order by max() on columns of table "dna.customer_email"
"""
input CustomerEmailMaxOrderBy {
  createdAt: OrderBy

  """Email address of the customer."""
  email: OrderBy
  merchantId: OrderBy
}

"""
order by min() on columns of table "dna.customer_email"
"""
input CustomerEmailMinOrderBy {
  createdAt: OrderBy

  """Email address of the customer."""
  email: OrderBy
  merchantId: OrderBy
}

"""Ordering options when selecting data from "dna.customer_email"."""
input CustomerEmailOrderBy {
  createdAt: OrderBy
  email: OrderBy
  isPrimary: OrderBy
  merchantId: OrderBy
}

"""
select columns of table "dna.customer_email"
"""
enum CustomerEmailSelectColumn {
  """column name"""
  createdAt

  """column name"""
  email

  """column name"""
  isPrimary

  """column name"""
  merchantId
}

"""
order by stddev() on columns of table "dna.customer_email"
"""
input CustomerEmailStddevOrderBy {
  merchantId: OrderBy
}

"""
order by stddev_pop() on columns of table "dna.customer_email"
"""
input CustomerEmailStddevPopOrderBy {
  merchantId: OrderBy
}

"""
order by stddev_samp() on columns of table "dna.customer_email"
"""
input CustomerEmailStddevSampOrderBy {
  merchantId: OrderBy
}

"""
order by sum() on columns of table "dna.customer_email"
"""
input CustomerEmailSumOrderBy {
  merchantId: OrderBy
}

"""
order by var_pop() on columns of table "dna.customer_email"
"""
input CustomerEmailVarPopOrderBy {
  merchantId: OrderBy
}

"""
order by var_samp() on columns of table "dna.customer_email"
"""
input CustomerEmailVarSampOrderBy {
  merchantId: OrderBy
}

"""
order by variance() on columns of table "dna.customer_email"
"""
input CustomerEmailVarianceOrderBy {
  merchantId: OrderBy
}

"""aggregate max on columns"""
type CustomerMaxFields {
  createdAt: timestamptz
  firstName: String

  """Serial id for each customer"""
  id: bigint
  lastName: String

  """Which merchant does this customer belong to."""
  merchantId: bigint
}

"""aggregate min on columns"""
type CustomerMinFields {
  createdAt: timestamptz
  firstName: String

  """Serial id for each customer"""
  id: bigint
  lastName: String

  """Which merchant does this customer belong to."""
  merchantId: bigint
}

"""Ordering options when selecting data from "dna.customer"."""
input CustomerOrderBy {
  addressesAggregate: CustomerAddressAggregateOrderBy
  blockedAggregate: CustomerBanAggregateOrderBy
  createdAt: OrderBy
  emailsAggregate: CustomerEmailAggregateOrderBy
  firstName: OrderBy
  id: OrderBy
  lastName: OrderBy
  locale: OrderBy
  merchant: MerchantOrderBy
  merchantId: OrderBy
  phoneNumbersAggregate: CustomerPhoneNumberAggregateOrderBy
  purchasesAggregate: PurchaseAggregateOrderBy
}

"""Additional payment data"""
type CustomerPaymentData {
  """An object relationship"""
  device: Device
  email: citext!

  """IP address of the customer where the payment originated from"""
  ip: String!
  locale: spoken_lang!
  merchantId: bigint!
  name: String!
  reference: String!
}

"""
Boolean expression to filter rows from the table "dna.customer_payment_data". All fields are combined with a logical 'AND'.
"""
input CustomerPaymentDataBoolExp {
  _and: [CustomerPaymentDataBoolExp!]
  _not: CustomerPaymentDataBoolExp
  _or: [CustomerPaymentDataBoolExp!]
  device: DeviceBoolExp
  email: CitextComparisonExp
  ip: StringComparisonExp
  locale: SpokenLangComparisonExp
  merchantId: BigintComparisonExp
  name: StringComparisonExp
  reference: StringComparisonExp
}

"""Ordering options when selecting data from "dna.customer_payment_data"."""
input CustomerPaymentDataOrderBy {
  device: DeviceOrderBy
  email: OrderBy
  ip: OrderBy
  locale: OrderBy
  merchantId: OrderBy
  name: OrderBy
  reference: OrderBy
}

"""
select columns of table "dna.customer_payment_data"
"""
enum CustomerPaymentDataSelectColumn {
  """column name"""
  email

  """column name"""
  ip

  """column name"""
  locale

  """column name"""
  merchantId

  """column name"""
  name

  """column name"""
  reference
}

"""Phone numbers of the customer."""
type CustomerPhoneNumber {
  createdAt: timestamptz!

  """An object relationship"""
  customer: Customer!
  customerId: bigint!

  """Whether this is the primary phone number of the customer."""
  isPrimary: Boolean!
  merchantId: bigint!

  """Phone number of the customer."""
  phoneNumber: packed_phone_number!
}

"""
order by aggregate values of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberAggregateOrderBy {
  avg: CustomerPhoneNumberAvgOrderBy
  count: OrderBy
  max: CustomerPhoneNumberMaxOrderBy
  min: CustomerPhoneNumberMinOrderBy
  stddev: CustomerPhoneNumberStddevOrderBy
  stddev_pop: CustomerPhoneNumberStddevPopOrderBy
  stddev_samp: CustomerPhoneNumberStddevSampOrderBy
  sum: CustomerPhoneNumberSumOrderBy
  var_pop: CustomerPhoneNumberVarPopOrderBy
  var_samp: CustomerPhoneNumberVarSampOrderBy
  variance: CustomerPhoneNumberVarianceOrderBy
}

"""
order by avg() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberAvgOrderBy {
  customerId: OrderBy
  merchantId: OrderBy
}

"""
Boolean expression to filter rows from the table "dna.customer_phone_number". All fields are combined with a logical 'AND'.
"""
input CustomerPhoneNumberBoolExp {
  _and: [CustomerPhoneNumberBoolExp!]
  _not: CustomerPhoneNumberBoolExp
  _or: [CustomerPhoneNumberBoolExp!]
  createdAt: TimestamptzComparisonExp
  customer: CustomerBoolExp
  customerId: BigintComparisonExp
  isPrimary: BooleanComparisonExp
  merchantId: BigintComparisonExp
  phoneNumber: PackedPhoneNumberComparisonExp
}

"""
order by max() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberMaxOrderBy {
  createdAt: OrderBy
  customerId: OrderBy
  merchantId: OrderBy
}

"""
order by min() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberMinOrderBy {
  createdAt: OrderBy
  customerId: OrderBy
  merchantId: OrderBy
}

"""Ordering options when selecting data from "dna.customer_phone_number"."""
input CustomerPhoneNumberOrderBy {
  createdAt: OrderBy
  customer: CustomerOrderBy
  customerId: OrderBy
  isPrimary: OrderBy
  merchantId: OrderBy
  phoneNumber: OrderBy
}

"""
select columns of table "dna.customer_phone_number"
"""
enum CustomerPhoneNumberSelectColumn {
  """column name"""
  createdAt

  """column name"""
  customerId

  """column name"""
  isPrimary

  """column name"""
  merchantId

  """column name"""
  phoneNumber
}

"""
order by stddev() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberStddevOrderBy {
  customerId: OrderBy
  merchantId: OrderBy
}

"""
order by stddev_pop() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberStddevPopOrderBy {
  customerId: OrderBy
  merchantId: OrderBy
}

"""
order by stddev_samp() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberStddevSampOrderBy {
  customerId: OrderBy
  merchantId: OrderBy
}

"""
order by sum() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberSumOrderBy {
  customerId: OrderBy
  merchantId: OrderBy
}

"""
order by var_pop() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberVarPopOrderBy {
  customerId: OrderBy
  merchantId: OrderBy
}

"""
order by var_samp() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberVarSampOrderBy {
  customerId: OrderBy
  merchantId: OrderBy
}

"""
order by variance() on columns of table "dna.customer_phone_number"
"""
input CustomerPhoneNumberVarianceOrderBy {
  customerId: OrderBy
  merchantId: OrderBy
}

"""
select columns of table "dna.customer"
"""
enum CustomerSelectColumn {
  """column name"""
  createdAt

  """column name"""
  firstName

  """column name"""
  id

  """column name"""
  lastName

  """column name"""
  locale

  """column name"""
  merchantId
}

"""aggregate stddev on columns"""
type CustomerStddevFields {
  """Serial id for each customer"""
  id: Float

  """Which merchant does this customer belong to."""
  merchantId: Float
}

"""aggregate stddev_pop on columns"""
type CustomerStddevPopFields {
  """Serial id for each customer"""
  id: Float

  """Which merchant does this customer belong to."""
  merchantId: Float
}

"""aggregate stddev_samp on columns"""
type CustomerStddevSampFields {
  """Serial id for each customer"""
  id: Float

  """Which merchant does this customer belong to."""
  merchantId: Float
}

"""aggregate sum on columns"""
type CustomerSumFields {
  """Serial id for each customer"""
  id: bigint

  """Which merchant does this customer belong to."""
  merchantId: bigint
}

"""Customer's preferred title when addressed."""
enum CustomerTitle {
  Miss
  Mr
  Mrs
  Ms
}

"""aggregate var_pop on columns"""
type CustomerVarPopFields {
  """Serial id for each customer"""
  id: Float

  """Which merchant does this customer belong to."""
  merchantId: Float
}

"""aggregate var_samp on columns"""
type CustomerVarSampFields {
  """Serial id for each customer"""
  id: Float

  """Which merchant does this customer belong to."""
  merchantId: Float
}

"""aggregate variance on columns"""
type CustomerVarianceFields {
  """Serial id for each customer"""
  id: Float

  """Which merchant does this customer belong to."""
  merchantId: Float
}

"""
Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'.
"""
input DateComparisonExp {
  _eq: date
  _gt: date
  _gte: date
  _in: [date!]
  _isNull: Boolean
  _lt: date
  _lte: date
  _neq: date
  _nin: [date!]
}

"""
Stops the sending of webhooks to the provided URL. Any queued up
webhooks for that URL will be discarded.
"""
input DeleteWebhookUrlInput {
  """
  URL to which the webhook notifications will be sent
  
  Max length: 1000.
  """
  webhookUrl: String!
}

"""The result of deleting a webhook URL."""
type DeleteWebhookUrlResult {
  """Whether or not a webhook URL was deleted."""
  found: Boolean!
}

"""Device used by a customer"""
type Device {
  browserName: String
  browserVersion: String
  createdAt: timestamptz!

  """Fingerprint of the device. This should be generated on the client side"""
  fingerprint: String!
  ipAddress: inet!

  """City of the device when accessing our service calculated using the ip."""
  ipCity: String

  """
  Continent of the device when accessing our service calculated using the ip.
  """
  ipContinent: String

  """
  Country of the device when accessing our service calculated using the ip.
  """
  ipCountry: String

  """
  Location coordinates of the device when accessing our service calculated using the ip.
  """
  ipLocation: geography
  merchantId: bigint!
  osName: String
  osVersion: String
  userAgent: String!
}

"""
Boolean expression to filter rows from the table "dna.device". All fields are combined with a logical 'AND'.
"""
input DeviceBoolExp {
  _and: [DeviceBoolExp!]
  _not: DeviceBoolExp
  _or: [DeviceBoolExp!]
  browserName: StringComparisonExp
  browserVersion: StringComparisonExp
  createdAt: TimestamptzComparisonExp
  fingerprint: StringComparisonExp
  ipAddress: InetComparisonExp
  ipCity: StringComparisonExp
  ipContinent: StringComparisonExp
  ipCountry: StringComparisonExp
  ipLocation: GeographyComparisonExp
  merchantId: BigintComparisonExp
  osName: StringComparisonExp
  osVersion: StringComparisonExp
  userAgent: StringComparisonExp
}

"""Ordering options when selecting data from "dna.device"."""
input DeviceOrderBy {
  browserName: OrderBy
  browserVersion: OrderBy
  createdAt: OrderBy
  fingerprint: OrderBy
  ipAddress: OrderBy
  ipCity: OrderBy
  ipContinent: OrderBy
  ipCountry: OrderBy
  ipLocation: OrderBy
  merchantId: OrderBy
  osName: OrderBy
  osVersion: OrderBy
  userAgent: OrderBy
}

"""
select columns of table "dna.device"
"""
enum DeviceSelectColumn {
  """column name"""
  browserName

  """column name"""
  browserVersion

  """column name"""
  createdAt

  """column name"""
  fingerprint

  """column name"""
  ipAddress

  """column name"""
  ipCity

  """column name"""
  ipContinent

  """column name"""
  ipCountry

  """column name"""
  ipLocation

  """column name"""
  merchantId

  """column name"""
  osName

  """column name"""
  osVersion

  """column name"""
  userAgent
}

"""Arguments for creating a new direct debit payment"""
input DirectDebitPaymentInput {
  """
  The amount the customer pays in minor units.
  So 100,56 kr would be 10056
  """
  amount: Int!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  Merchant's own internal reference that may help the
  merchant in identifying this payment. These have to
  be globally unique but they should be reused for retrying
  a payment.
  
  Max length: 64.
  """
  merchantReference: String!

  """
  A message to show to the customer on their bank statement.
  It could be an order id or a reference.
  
  Max length: 50.
  """
  message: String!

  """Payment category that determines the payment flow"""
  paymentCategory: PaymentCategory!

  """
  Our system's own internal reference that can be used uniquely
  in identifying this payment.
  """
  paymentReference: String!

  """The url to return to after the payment is done."""
  returnUrl: String!
}

"""The result of initiating a direct debit payment."""
type DirectDebitPaymentResult {
  """
  Once a payment is initialized, we will start the direct debit payment
  workflow. You can use this token to query the current status
  of the payment.
  """
  waitToken: String!
}

"""
Discount on items made on a purchase after it was captured. The purchase must be captured before it can have discounts.

"""
type Discount {
  createdAt: timestamptz!

  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: bigint!
  id: bigint!

  """An object relationship"""
  item: PurchaseItem!
  merchantId: bigint!
  purchaseId: bigint!
  reference: citext!
}

"""
aggregated selection of "marketplace.purchase_capture_item_discount"
"""
type DiscountAggregate {
  aggregate: DiscountAggregateFields
  nodes: [Discount!]!
}

"""
aggregate fields of "marketplace.purchase_capture_item_discount"
"""
type DiscountAggregateFields {
  avg: DiscountAvgFields
  count(columns: [DiscountSelectColumn!], distinct: Boolean): Int!
  max: DiscountMaxFields
  min: DiscountMinFields
  stddev: DiscountStddevFields
  stddevPop: DiscountStddevPopFields
  stddevSamp: DiscountStddevSampFields
  sum: DiscountSumFields
  varPop: DiscountVarPopFields
  varSamp: DiscountVarSampFields
  variance: DiscountVarianceFields
}

"""
order by aggregate values of table "marketplace.purchase_capture_item_discount"
"""
input DiscountAggregateOrderBy {
  avg: DiscountAvgOrderBy
  count: OrderBy
  max: DiscountMaxOrderBy
  min: DiscountMinOrderBy
  stddev: DiscountStddevOrderBy
  stddev_pop: DiscountStddevPopOrderBy
  stddev_samp: DiscountStddevSampOrderBy
  sum: DiscountSumOrderBy
  var_pop: DiscountVarPopOrderBy
  var_samp: DiscountVarSampOrderBy
  variance: DiscountVarianceOrderBy
}

"""aggregate avg on columns"""
type DiscountAvgFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: Float
  id: Float
  merchantId: Float
  purchaseId: Float
}

"""
order by avg() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountAvgOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.purchase_capture_item_discount". All fields are combined with a logical 'AND'.
"""
input DiscountBoolExp {
  _and: [DiscountBoolExp!]
  _not: DiscountBoolExp
  _or: [DiscountBoolExp!]
  createdAt: TimestamptzComparisonExp
  discountAmount: BigintComparisonExp
  id: BigintComparisonExp
  item: PurchaseItemBoolExp
  merchantId: BigintComparisonExp
  purchaseId: BigintComparisonExp
  reference: CitextComparisonExp
}

"""aggregate max on columns"""
type DiscountMaxFields {
  createdAt: timestamptz

  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: bigint
  id: bigint
  merchantId: bigint
  purchaseId: bigint
  reference: citext
}

"""
order by max() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountMaxOrderBy {
  createdAt: OrderBy

  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
  reference: OrderBy
}

"""aggregate min on columns"""
type DiscountMinFields {
  createdAt: timestamptz

  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: bigint
  id: bigint
  merchantId: bigint
  purchaseId: bigint
  reference: citext
}

"""
order by min() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountMinOrderBy {
  createdAt: OrderBy

  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
  reference: OrderBy
}

"""
Ordering options when selecting data from "marketplace.purchase_capture_item_discount".
"""
input DiscountOrderBy {
  createdAt: OrderBy
  discountAmount: OrderBy
  id: OrderBy
  item: PurchaseItemOrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
  reference: OrderBy
}

"""
select columns of table "marketplace.purchase_capture_item_discount"
"""
enum DiscountSelectColumn {
  """column name"""
  createdAt

  """column name"""
  discountAmount

  """column name"""
  id

  """column name"""
  merchantId

  """column name"""
  purchaseId

  """column name"""
  reference
}

"""aggregate stddev on columns"""
type DiscountStddevFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: Float
  id: Float
  merchantId: Float
  purchaseId: Float
}

"""
order by stddev() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountStddevOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""aggregate stddev_pop on columns"""
type DiscountStddevPopFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: Float
  id: Float
  merchantId: Float
  purchaseId: Float
}

"""
order by stddev_pop() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountStddevPopOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""aggregate stddev_samp on columns"""
type DiscountStddevSampFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: Float
  id: Float
  merchantId: Float
  purchaseId: Float
}

"""
order by stddev_samp() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountStddevSampOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""aggregate sum on columns"""
type DiscountSumFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: bigint
  id: bigint
  merchantId: bigint
  purchaseId: bigint
}

"""
order by sum() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountSumOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""aggregate var_pop on columns"""
type DiscountVarPopFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: Float
  id: Float
  merchantId: Float
  purchaseId: Float
}

"""
order by var_pop() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountVarPopOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""aggregate var_samp on columns"""
type DiscountVarSampFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: Float
  id: Float
  merchantId: Float
  purchaseId: Float
}

"""
order by var_samp() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountVarSampOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""aggregate variance on columns"""
type DiscountVarianceFields {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: Float
  id: Float
  merchantId: Float
  purchaseId: Float
}

"""
order by variance() on columns of table "marketplace.purchase_capture_item_discount"
"""
input DiscountVarianceOrderBy {
  """The discount amount in currency units, includes tax to be discounted."""
  discountAmount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""Edit user's role."""
input EditUserInput {
  """Email of the user that is making the request."""
  currentUser: String!

  """List of users that should be changed."""
  editUsers: [EditUserSingleInput!]!
}

"""Result of the editions"""
type EditUserResult {
  """Result of the operation."""
  success: Boolean!
}

"""The information needed to edit a user role."""
input EditUserSingleInput {
  """Email of the user, for reference."""
  email: String!

  """Role that this user should have."""
  role: String!
}

"""
Describes the schema for the finshark payment transaction details to be used by hasura
"""
type FinsharkDetails {
  customerAccountBic: String

  """Currency code of the account if known"""
  customerAccountCurrencyCode: String

  """Account number of the customer"""
  customerAccountNumber: String

  """Account type (IBAN or BBAN)"""
  customerAccountType: String

  """Customer's email if known"""
  customerEmail: String

  """Customer's own message if set"""
  customerMessage: String
  customerName: String

  """Customer's phone number if known"""
  customerPhoneNumber: String

  """Payment ID as created in Finshark"""
  finsharkId: String
}

"""
order by aggregate values of table "runtime.transaction_finshark_details"
"""
input FinsharkDetailsAggregateOrderBy {
  count: OrderBy
  max: FinsharkDetailsMaxOrderBy
  min: FinsharkDetailsMinOrderBy
}

"""
Boolean expression to filter rows from the table "runtime.transaction_finshark_details". All fields are combined with a logical 'AND'.
"""
input FinsharkDetailsBoolExp {
  _and: [FinsharkDetailsBoolExp!]
  _not: FinsharkDetailsBoolExp
  _or: [FinsharkDetailsBoolExp!]
  customerAccountBic: StringComparisonExp
  customerAccountCurrencyCode: StringComparisonExp
  customerAccountNumber: StringComparisonExp
  customerAccountType: StringComparisonExp
  customerEmail: StringComparisonExp
  customerMessage: StringComparisonExp
  customerName: StringComparisonExp
  customerPhoneNumber: StringComparisonExp
  finsharkId: StringComparisonExp
}

"""
order by max() on columns of table "runtime.transaction_finshark_details"
"""
input FinsharkDetailsMaxOrderBy {
  customerAccountBic: OrderBy

  """Currency code of the account if known"""
  customerAccountCurrencyCode: OrderBy

  """Account number of the customer"""
  customerAccountNumber: OrderBy

  """Account type (IBAN or BBAN)"""
  customerAccountType: OrderBy

  """Customer's email if known"""
  customerEmail: OrderBy

  """Customer's own message if set"""
  customerMessage: OrderBy
  customerName: OrderBy

  """Customer's phone number if known"""
  customerPhoneNumber: OrderBy

  """Payment ID as created in Finshark"""
  finsharkId: OrderBy
}

"""
order by min() on columns of table "runtime.transaction_finshark_details"
"""
input FinsharkDetailsMinOrderBy {
  customerAccountBic: OrderBy

  """Currency code of the account if known"""
  customerAccountCurrencyCode: OrderBy

  """Account number of the customer"""
  customerAccountNumber: OrderBy

  """Account type (IBAN or BBAN)"""
  customerAccountType: OrderBy

  """Customer's email if known"""
  customerEmail: OrderBy

  """Customer's own message if set"""
  customerMessage: OrderBy
  customerName: OrderBy

  """Customer's phone number if known"""
  customerPhoneNumber: OrderBy

  """Payment ID as created in Finshark"""
  finsharkId: OrderBy
}

"""
Ordering options when selecting data from "runtime.transaction_finshark_details".
"""
input FinsharkDetailsOrderBy {
  customerAccountBic: OrderBy
  customerAccountCurrencyCode: OrderBy
  customerAccountNumber: OrderBy
  customerAccountType: OrderBy
  customerEmail: OrderBy
  customerMessage: OrderBy
  customerName: OrderBy
  customerPhoneNumber: OrderBy
  finsharkId: OrderBy
}

"""
select columns of table "runtime.transaction_finshark_details"
"""
enum FinsharkDetailsSelectColumn {
  """column name"""
  customerAccountBic

  """column name"""
  customerAccountCurrencyCode

  """column name"""
  customerAccountNumber

  """column name"""
  customerAccountType

  """column name"""
  customerEmail

  """column name"""
  customerMessage

  """column name"""
  customerName

  """column name"""
  customerPhoneNumber

  """column name"""
  finsharkId
}

"""Arguments to generate presigned URLs for the merchant"""
input GeneratePaymentCSVInput {
  """
  A date in yyyy-mm-dd format, non-nullable, filters payments in CSV, only including payments created till this date.
  Has to be greater or equal than start_date and no dates bigger than current date in UTC are allowed.
  """
  endDate: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  A date in yyyy-mm-dd format, non-nullable, filters payments in CSV, only including payments created from this date.
  Has to be smaller or equal than end_date.
  """
  startDate: String!
}

"""The result of a generatePaymentCSV mutation."""
type GeneratePaymentCSVResult {
  """You can use this token to query the generated payments csv link."""
  waitToken: bigint!
}

"""Arguments to generate presigned URLs for the merchant"""
input GeneratePaymentRequestCSVInput {
  """The email address of the customer that initiated the payment request."""
  customerEmail: String

  """
  A date in yyyy-mm-dd format, non-nullable, filters payment requests
  in CSV, only including payment requests created till this date. Has
  to be greater than or equal to start_date and no dates bigger than
  current date in UTC are allowed.
  """
  endDate: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """The highest amount, in minor units, to include."""
  maxAmount: Int

  """The lowest amount, in minor units, to include."""
  minAmount: Int

  """List of payment methods to be included in the CSV."""
  paymentMethodIn: [PaymentRequestMethod!]

  """The reference number of the payment request."""
  reference: String

  """List of refund statuses to be included in the CSV."""
  refundStatusIn: [PaymentRequestRefundStatus!]

  """
  A date in yyyy-mm-dd format, non-nullable, filters payment requests
  in CSV, only including payment requests created from this date. Has
  to be smaller than or equal to end_date.
  """
  startDate: String!

  """List of statuses to be included in the CSV."""
  statusIn: [PaymentRequestStatus!]
}

"""The result of a generatePaymentRequestCSV mutation."""
type GeneratePaymentRequestCSVResult {
  """
  You can use this token to query the generated payment requests csv link.
  """
  waitToken: bigint!
}

"""Arguments to generate presigned URLs for the merchant"""
input GeneratePurchaseCSVInput {
  """
  A date in yyyy-mm-dd format, non-nullable, filters purchases in CSV, only including purchases created before this date.
  Has to be greater or equal than start_date and no dates bigger than current date in UTC are allowed.
  """
  endDate: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  A list of statuses to filter, will only include purchases in CSV that contain one of the given statuses,
  empty list will omit this filter.
  """
  purchaseStatus: [String!]!

  """
  A date in yyyy-mm-dd format, non-nullable, filters purchases in CSV, only including purchases created after this date.
  Has to be smaller or equal than end_date.
  """
  startDate: String!
}

"""The result of a generatePurchaseCSV mutation."""
type GeneratePurchaseCSVResult {
  """You can use this token to query the generated purchases csv link."""
  waitToken: bigint!
}

"""
Arguments to generate presigned URLs for the merchant for a reconciliation report
"""
input GenerateReconciliationCSVInput {
  """
  A date in yyyy-mm-dd format, non-nullable, filters elements in CSV, only including elements created before this date.
  Has to be greater or equal than start_date and no dates bigger than current date in UTC are allowed.
  """
  endDate: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  A date in yyyy-mm-dd format, non-nullable, filters elements in CSV, only including elements created after this date.
  Has to be smaller or equal than end_date.
  """
  startDate: String!
}

"""The result of a generateReconciliationCSV mutation."""
type GenerateReconciliationCSVResult {
  """You can use this token to query the generated reconciliation csv link."""
  waitToken: bigint!
}

"""Arguments to generate presigned URLs for the merchant"""
input GenerateReportInput {
  """
  The end date till when the report is to be generated for.
  Provide the dates in the merchant's own time zone. Only CET for now.
  """
  endDate: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  The start date from when the report is to be generated for.
  Provide the dates in the merchant's own time zone. Only CET for now.
  """
  startDate: String!
}

"""The result of a generateReport mutation."""
type GenerateReportResult {
  """You can use this token to query the generated reports link."""
  waitToken: Int!
}

input GeographyCastExp {
  geometry: GeometryComparisonExp
}

"""
Boolean expression to compare columns of type "geography". All fields are combined with logical 'AND'.
"""
input GeographyComparisonExp {
  _cast: GeographyCastExp
  _eq: geography
  _gt: geography
  _gte: geography
  _in: [geography!]
  _isNull: Boolean
  _lt: geography
  _lte: geography
  _neq: geography
  _nin: [geography!]

  """is the column within a given distance from the given geography value"""
  _stDWithin: st_d_within_geography_input

  """does the column spatially intersect the given geography value"""
  _stIntersects: geography
}

input GeometryCastExp {
  geography: GeographyComparisonExp
}

"""
Boolean expression to compare columns of type "geometry". All fields are combined with logical 'AND'.
"""
input GeometryComparisonExp {
  _cast: GeometryCastExp
  _eq: geometry
  _gt: geometry
  _gte: geometry
  _in: [geometry!]
  _isNull: Boolean
  _lt: geometry
  _lte: geometry
  _neq: geometry
  _nin: [geometry!]

  """is the column within a given 3D distance from the given geometry value"""
  _st3dDWithin: st_d_within_input

  """does the column spatially intersect the given geometry value in 3D"""
  _st3dIntersects: geometry

  """does the column contain the given geometry value"""
  _stContains: geometry

  """does the column cross the given geometry value"""
  _stCrosses: geometry

  """is the column within a given distance from the given geometry value"""
  _stDWithin: st_d_within_input

  """
  is the column equal to given geometry value (directionality is ignored)
  """
  _stEquals: geometry

  """does the column spatially intersect the given geometry value"""
  _stIntersects: geometry

  """
  does the column 'spatially overlap' (intersect but not completely contain) the given geometry value
  """
  _stOverlaps: geometry

  """
  does the column have atleast one point in common with the given geometry value
  """
  _stTouches: geometry

  """is the column contained in the given geometry value"""
  _stWithin: geometry
}

"""
Boolean expression to compare columns of type "inet". All fields are combined with logical 'AND'.
"""
input InetComparisonExp {
  _eq: inet
  _gt: inet
  _gte: inet
  _in: [inet!]
  _isNull: Boolean
  _lt: inet
  _lte: inet
  _neq: inet
  _nin: [inet!]
}

"""

One of the parts into with a debt is divided for a purchase.
Payment is dived in intervals of 30 days.

"""
type Instalment {
  """Contains the total amount to pay, including fees"""
  amountDue: bigint!
  amountPaid: bigint!

  """Date the payment for the instalment is due"""
  dueDate: timestamptz!
  id: bigint!
  merchantId: bigint!

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: bigint!

  """The part number for the debt, in sequential numbering"""
  partNumber: smallint!
  paymentMethod: PaymentMethodEnum
  purchaseId: bigint!
  reminderFee: bigint!
  serviceFee: bigint!
  status: String!
}

"""
order by aggregate values of table "instalment.instalment"
"""
input InstalmentAggregateOrderBy {
  avg: InstalmentAvgOrderBy
  count: OrderBy
  max: InstalmentMaxOrderBy
  min: InstalmentMinOrderBy
  stddev: InstalmentStddevOrderBy
  stddev_pop: InstalmentStddevPopOrderBy
  stddev_samp: InstalmentStddevSampOrderBy
  sum: InstalmentSumOrderBy
  var_pop: InstalmentVarPopOrderBy
  var_samp: InstalmentVarSampOrderBy
  variance: InstalmentVarianceOrderBy
}

"""
order by avg() on columns of table "instalment.instalment"
"""
input InstalmentAvgOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
Boolean expression to filter rows from the table "instalment.instalment". All fields are combined with a logical 'AND'.
"""
input InstalmentBoolExp {
  _and: [InstalmentBoolExp!]
  _not: InstalmentBoolExp
  _or: [InstalmentBoolExp!]
  amountDue: BigintComparisonExp
  amountPaid: BigintComparisonExp
  dueDate: TimestamptzComparisonExp
  id: BigintComparisonExp
  merchantId: BigintComparisonExp
  monthlyInstalment: BigintComparisonExp
  partNumber: SmallintComparisonExp
  paymentMethod: PaymentMethodEnumComparisonExp
  purchaseId: BigintComparisonExp
  reminderFee: BigintComparisonExp
  serviceFee: BigintComparisonExp
  status: StringComparisonExp
}

"""
order by max() on columns of table "instalment.instalment"
"""
input InstalmentMaxOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy

  """Date the payment for the instalment is due"""
  dueDate: OrderBy
  id: OrderBy
  merchantId: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
  status: OrderBy
}

"""
order by min() on columns of table "instalment.instalment"
"""
input InstalmentMinOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy

  """Date the payment for the instalment is due"""
  dueDate: OrderBy
  id: OrderBy
  merchantId: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
  status: OrderBy
}

"""Ordering options when selecting data from "instalment.instalment"."""
input InstalmentOrderBy {
  amountDue: OrderBy
  amountPaid: OrderBy
  dueDate: OrderBy
  id: OrderBy
  merchantId: OrderBy
  monthlyInstalment: OrderBy
  partNumber: OrderBy
  paymentMethod: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
  status: OrderBy
}

"""
select columns of table "instalment.instalment"
"""
enum InstalmentSelectColumn {
  """column name"""
  amountDue

  """column name"""
  amountPaid

  """column name"""
  dueDate

  """column name"""
  id

  """column name"""
  merchantId

  """column name"""
  monthlyInstalment

  """column name"""
  partNumber

  """column name"""
  paymentMethod

  """column name"""
  purchaseId

  """column name"""
  reminderFee

  """column name"""
  serviceFee

  """column name"""
  status
}

"""
order by stddev() on columns of table "instalment.instalment"
"""
input InstalmentStddevOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
order by stddev_pop() on columns of table "instalment.instalment"
"""
input InstalmentStddevPopOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
order by stddev_samp() on columns of table "instalment.instalment"
"""
input InstalmentStddevSampOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
order by sum() on columns of table "instalment.instalment"
"""
input InstalmentSumOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
order by var_pop() on columns of table "instalment.instalment"
"""
input InstalmentVarPopOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
order by var_samp() on columns of table "instalment.instalment"
"""
input InstalmentVarSampOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
order by variance() on columns of table "instalment.instalment"
"""
input InstalmentVarianceOrderBy {
  """Contains the total amount to pay, including fees"""
  amountDue: OrderBy
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy

  """Contains the total amount to pay, minus any added fees"""
  monthlyInstalment: OrderBy

  """The part number for the debt, in sequential numbering"""
  partNumber: OrderBy
  purchaseId: OrderBy
  reminderFee: OrderBy
  serviceFee: OrderBy
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input IntComparisonExp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _isNull: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "interval". All fields are combined with logical 'AND'.
"""
input IntervalComparisonExp {
  _eq: interval
  _gt: interval
  _gte: interval
  _in: [interval!]
  _isNull: Boolean
  _lt: interval
  _lte: interval
  _neq: interval
  _nin: [interval!]
}

"""
Purchase invoice containing current balance, deadline dates and customer data.
"""
type Invoice {
  createdAt: timestamptz!
  dueDate: timestamptz!
  expectedAmount: bigint!
  invoiceNumber: bigint!

  """An object relationship"""
  invoicePage: InvoicePage
  invoicePageJwt: String!
  merchantId: bigint!
  merchantReference: String!

  """An array relationship"""
  notes(
    """distinct select on columns"""
    distinctOn: [InvoiceNoteSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceNoteOrderBy!]

    """filter the rows returned"""
    where: InvoiceNoteBoolExp
  ): [InvoiceNote!]!

  """An aggregate relationship"""
  notesAggregate(
    """distinct select on columns"""
    distinctOn: [InvoiceNoteSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceNoteOrderBy!]

    """filter the rows returned"""
    where: InvoiceNoteBoolExp
  ): InvoiceNoteAggregate!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinctOn: [InvoicePaymentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoicePaymentOrderBy!]

    """filter the rows returned"""
    where: InvoicePaymentBoolExp
  ): [InvoicePayment!]!
  purchaseId: bigint!
}

"""
aggregated selection of "invoice.invoice"
"""
type InvoiceAggregate {
  aggregate: InvoiceAggregateFields
  nodes: [Invoice!]!
}

"""
aggregate fields of "invoice.invoice"
"""
type InvoiceAggregateFields {
  avg: InvoiceAvgFields
  count(columns: [InvoiceSelectColumn!], distinct: Boolean): Int!
  max: InvoiceMaxFields
  min: InvoiceMinFields
  stddev: InvoiceStddevFields
  stddevPop: InvoiceStddevPopFields
  stddevSamp: InvoiceStddevSampFields
  sum: InvoiceSumFields
  varPop: InvoiceVarPopFields
  varSamp: InvoiceVarSampFields
  variance: InvoiceVarianceFields
}

"""aggregate avg on columns"""
type InvoiceAvgFields {
  expectedAmount: Float
  invoiceNumber: Float
  merchantId: Float
  purchaseId: Float
}

"""
Boolean expression to filter rows from the table "invoice.invoice". All fields are combined with a logical 'AND'.
"""
input InvoiceBoolExp {
  _and: [InvoiceBoolExp!]
  _not: InvoiceBoolExp
  _or: [InvoiceBoolExp!]
  createdAt: TimestamptzComparisonExp
  dueDate: TimestamptzComparisonExp
  expectedAmount: BigintComparisonExp
  invoiceNumber: BigintComparisonExp
  invoicePage: InvoicePageBoolExp
  invoicePageJwt: StringComparisonExp
  merchantId: BigintComparisonExp
  merchantReference: StringComparisonExp
  notes: InvoiceNoteBoolExp
  payments: InvoicePaymentBoolExp
  purchaseId: BigintComparisonExp
}

"""A new date for an invoiced purchase"""
input InvoiceDueDateAdjustInput {
  """
  The new invoice due date. Only CET for now.
  The due date should be within 60 days of the current date.
  """
  dueDate: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """This is the id of the purchase associated with the invoice."""
  purchaseId: bigint!
}

"""The result of processing an invoice due date adjustment."""
type InvoiceDueDateAdjustResult {
  """The adjusted due date."""
  dueDate: String!

  """The id of the newly created adjustment."""
  returnId: Int!
}

"""aggregate max on columns"""
type InvoiceMaxFields {
  createdAt: timestamptz
  dueDate: timestamptz
  expectedAmount: bigint
  invoiceNumber: bigint
  invoicePageJwt: String
  merchantId: bigint
  merchantReference: String
  purchaseId: bigint
}

"""aggregate min on columns"""
type InvoiceMinFields {
  createdAt: timestamptz
  dueDate: timestamptz
  expectedAmount: bigint
  invoiceNumber: bigint
  invoicePageJwt: String
  merchantId: bigint
  merchantReference: String
  purchaseId: bigint
}

"""A note added by a merchant admin on an invoice"""
type InvoiceNote {
  createdAt: timestamptz!
  createdBy: String!
  id: bigint!
  invoiceNumber: bigint!
  merchantId: bigint!
  note: String!
  purchaseId: bigint!
}

"""
aggregated selection of "invoice.note"
"""
type InvoiceNoteAggregate {
  aggregate: InvoiceNoteAggregateFields
  nodes: [InvoiceNote!]!
}

"""
aggregate fields of "invoice.note"
"""
type InvoiceNoteAggregateFields {
  avg: InvoiceNoteAvgFields
  count(columns: [InvoiceNoteSelectColumn!], distinct: Boolean): Int!
  max: InvoiceNoteMaxFields
  min: InvoiceNoteMinFields
  stddev: InvoiceNoteStddevFields
  stddevPop: InvoiceNoteStddevPopFields
  stddevSamp: InvoiceNoteStddevSampFields
  sum: InvoiceNoteSumFields
  varPop: InvoiceNoteVarPopFields
  varSamp: InvoiceNoteVarSampFields
  variance: InvoiceNoteVarianceFields
}

"""
order by aggregate values of table "invoice.note"
"""
input InvoiceNoteAggregateOrderBy {
  avg: InvoiceNoteAvgOrderBy
  count: OrderBy
  max: InvoiceNoteMaxOrderBy
  min: InvoiceNoteMinOrderBy
  stddev: InvoiceNoteStddevOrderBy
  stddev_pop: InvoiceNoteStddevPopOrderBy
  stddev_samp: InvoiceNoteStddevSampOrderBy
  sum: InvoiceNoteSumOrderBy
  var_pop: InvoiceNoteVarPopOrderBy
  var_samp: InvoiceNoteVarSampOrderBy
  variance: InvoiceNoteVarianceOrderBy
}

"""aggregate avg on columns"""
type InvoiceNoteAvgFields {
  id: Float
  invoiceNumber: Float
  merchantId: Float
  purchaseId: Float
}

"""
order by avg() on columns of table "invoice.note"
"""
input InvoiceNoteAvgOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
Boolean expression to filter rows from the table "invoice.note". All fields are combined with a logical 'AND'.
"""
input InvoiceNoteBoolExp {
  _and: [InvoiceNoteBoolExp!]
  _not: InvoiceNoteBoolExp
  _or: [InvoiceNoteBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: StringComparisonExp
  id: BigintComparisonExp
  invoiceNumber: BigintComparisonExp
  merchantId: BigintComparisonExp
  note: StringComparisonExp
  purchaseId: BigintComparisonExp
}

"""Arguments for adding a note to an invoice"""
input InvoiceNoteInput {
  """The invoice the note corresponds to."""
  invoiceNumber: bigint!

  """
  The message the admin wants to add to the invoice.
  
  Max length: 1000.
  """
  message: String!

  """
  The purchaseId corresponding to the invoice to which the note is to be added.
  """
  purchaseId: bigint!
}

"""aggregate max on columns"""
type InvoiceNoteMaxFields {
  createdAt: timestamptz
  createdBy: String
  id: bigint
  invoiceNumber: bigint
  merchantId: bigint
  note: String
  purchaseId: bigint
}

"""
order by max() on columns of table "invoice.note"
"""
input InvoiceNoteMaxOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  id: OrderBy
  invoiceNumber: OrderBy
  merchantId: OrderBy
  note: OrderBy
  purchaseId: OrderBy
}

"""aggregate min on columns"""
type InvoiceNoteMinFields {
  createdAt: timestamptz
  createdBy: String
  id: bigint
  invoiceNumber: bigint
  merchantId: bigint
  note: String
  purchaseId: bigint
}

"""
order by min() on columns of table "invoice.note"
"""
input InvoiceNoteMinOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  id: OrderBy
  invoiceNumber: OrderBy
  merchantId: OrderBy
  note: OrderBy
  purchaseId: OrderBy
}

"""Ordering options when selecting data from "invoice.note"."""
input InvoiceNoteOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  id: OrderBy
  invoiceNumber: OrderBy
  merchantId: OrderBy
  note: OrderBy
  purchaseId: OrderBy
}

"""The result of adding a note to the invoice."""
type InvoiceNoteResult {
  """The resulting id of adding a note to the invoice."""
  resultingNoteId: bigint!
}

"""
select columns of table "invoice.note"
"""
enum InvoiceNoteSelectColumn {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  id

  """column name"""
  invoiceNumber

  """column name"""
  merchantId

  """column name"""
  note

  """column name"""
  purchaseId
}

"""aggregate stddev on columns"""
type InvoiceNoteStddevFields {
  id: Float
  invoiceNumber: Float
  merchantId: Float
  purchaseId: Float
}

"""
order by stddev() on columns of table "invoice.note"
"""
input InvoiceNoteStddevOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""aggregate stddev_pop on columns"""
type InvoiceNoteStddevPopFields {
  id: Float
  invoiceNumber: Float
  merchantId: Float
  purchaseId: Float
}

"""
order by stddev_pop() on columns of table "invoice.note"
"""
input InvoiceNoteStddevPopOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""aggregate stddev_samp on columns"""
type InvoiceNoteStddevSampFields {
  id: Float
  invoiceNumber: Float
  merchantId: Float
  purchaseId: Float
}

"""
order by stddev_samp() on columns of table "invoice.note"
"""
input InvoiceNoteStddevSampOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""aggregate sum on columns"""
type InvoiceNoteSumFields {
  id: bigint
  invoiceNumber: bigint
  merchantId: bigint
  purchaseId: bigint
}

"""
order by sum() on columns of table "invoice.note"
"""
input InvoiceNoteSumOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""aggregate var_pop on columns"""
type InvoiceNoteVarPopFields {
  id: Float
  invoiceNumber: Float
  merchantId: Float
  purchaseId: Float
}

"""
order by var_pop() on columns of table "invoice.note"
"""
input InvoiceNoteVarPopOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""aggregate var_samp on columns"""
type InvoiceNoteVarSampFields {
  id: Float
  invoiceNumber: Float
  merchantId: Float
  purchaseId: Float
}

"""
order by var_samp() on columns of table "invoice.note"
"""
input InvoiceNoteVarSampOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""aggregate variance on columns"""
type InvoiceNoteVarianceFields {
  id: Float
  invoiceNumber: Float
  merchantId: Float
  purchaseId: Float
}

"""
order by variance() on columns of table "invoice.note"
"""
input InvoiceNoteVarianceOrderBy {
  id: OrderBy
  invoiceNumber: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""Ordering options when selecting data from "invoice.invoice"."""
input InvoiceOrderBy {
  createdAt: OrderBy
  dueDate: OrderBy
  expectedAmount: OrderBy
  invoiceNumber: OrderBy
  invoicePage: InvoicePageOrderBy
  invoicePageJwt: OrderBy
  merchantId: OrderBy
  merchantReference: OrderBy
  notesAggregate: InvoiceNoteAggregateOrderBy
  paymentsAggregate: InvoicePaymentAggregateOrderBy
  purchaseId: OrderBy
}

"""A view of everything needed to render an invoice"""
type InvoicePage {
  currency: String!
  dueDate: timestamptz!
  expectedAmount: bigint!
  invoiceNumber: bigint!
  invoicePageJwt: String!
  locale: spoken_lang!
  merchantId: bigint!
  merchantReference: String
  minimumExpected: bigint!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinctOn: [InvoicePaymentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoicePaymentOrderBy!]

    """filter the rows returned"""
    where: InvoicePaymentBoolExp
  ): [InvoicePayment!]!
  purchaseId: bigint!
  status: String!

  """An array relationship"""
  surcharges(
    """distinct select on columns"""
    distinctOn: [InvoiceSurchargeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceSurchargeOrderBy!]

    """filter the rows returned"""
    where: InvoiceSurchargeBoolExp
  ): [InvoiceSurcharge!]!

  """An array relationship"""
  transactions(
    """distinct select on columns"""
    distinctOn: [InvoiceTransactionSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceTransactionOrderBy!]

    """filter the rows returned"""
    where: InvoiceTransactionBoolExp
  ): [InvoiceTransaction!]!
}

"""
Boolean expression to filter rows from the table "invoice_page.invoice_page". All fields are combined with a logical 'AND'.
"""
input InvoicePageBoolExp {
  _and: [InvoicePageBoolExp!]
  _not: InvoicePageBoolExp
  _or: [InvoicePageBoolExp!]
  currency: StringComparisonExp
  dueDate: TimestamptzComparisonExp
  expectedAmount: BigintComparisonExp
  invoiceNumber: BigintComparisonExp
  invoicePageJwt: StringComparisonExp
  locale: SpokenLangComparisonExp
  merchantId: BigintComparisonExp
  merchantReference: StringComparisonExp
  minimumExpected: BigintComparisonExp
  payments: InvoicePaymentBoolExp
  purchaseId: BigintComparisonExp
  status: StringComparisonExp
  surcharges: InvoiceSurchargeBoolExp
  transactions: InvoiceTransactionBoolExp
}

"""Ordering options when selecting data from "invoice_page.invoice_page"."""
input InvoicePageOrderBy {
  currency: OrderBy
  dueDate: OrderBy
  expectedAmount: OrderBy
  invoiceNumber: OrderBy
  invoicePageJwt: OrderBy
  locale: OrderBy
  merchantId: OrderBy
  merchantReference: OrderBy
  minimumExpected: OrderBy
  paymentsAggregate: InvoicePaymentAggregateOrderBy
  purchaseId: OrderBy
  status: OrderBy
  surchargesAggregate: InvoiceSurchargeAggregateOrderBy
  transactionsAggregate: InvoiceTransactionAggregateOrderBy
}

"""
select columns of table "invoice_page.invoice_page"
"""
enum InvoicePageSelectColumn {
  """column name"""
  currency

  """column name"""
  dueDate

  """column name"""
  expectedAmount

  """column name"""
  invoiceNumber

  """column name"""
  invoicePageJwt

  """column name"""
  locale

  """column name"""
  merchantId

  """column name"""
  merchantReference

  """column name"""
  minimumExpected

  """column name"""
  purchaseId

  """column name"""
  status
}

"""A payment done towards an invoice"""
type InvoicePayment {
  amountPaid: bigint!
  createdAt: timestamptz!
  currency: currency!
  id: bigint!
  merchantId: bigint!
  paymentMethod: String!
  purchaseId: bigint!
}

"""
order by aggregate values of table "invoice_page.invoice_payment"
"""
input InvoicePaymentAggregateOrderBy {
  avg: InvoicePaymentAvgOrderBy
  count: OrderBy
  max: InvoicePaymentMaxOrderBy
  min: InvoicePaymentMinOrderBy
  stddev: InvoicePaymentStddevOrderBy
  stddev_pop: InvoicePaymentStddevPopOrderBy
  stddev_samp: InvoicePaymentStddevSampOrderBy
  sum: InvoicePaymentSumOrderBy
  var_pop: InvoicePaymentVarPopOrderBy
  var_samp: InvoicePaymentVarSampOrderBy
  variance: InvoicePaymentVarianceOrderBy
}

"""
order by avg() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentAvgOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
Boolean expression to filter rows from the table "invoice_page.invoice_payment". All fields are combined with a logical 'AND'.
"""
input InvoicePaymentBoolExp {
  _and: [InvoicePaymentBoolExp!]
  _not: InvoicePaymentBoolExp
  _or: [InvoicePaymentBoolExp!]
  amountPaid: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  currency: CurrencyComparisonExp
  id: BigintComparisonExp
  merchantId: BigintComparisonExp
  paymentMethod: StringComparisonExp
  purchaseId: BigintComparisonExp
}

"""
order by max() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentMaxOrderBy {
  amountPaid: OrderBy
  createdAt: OrderBy
  id: OrderBy
  merchantId: OrderBy
  paymentMethod: OrderBy
  purchaseId: OrderBy
}

"""
order by min() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentMinOrderBy {
  amountPaid: OrderBy
  createdAt: OrderBy
  id: OrderBy
  merchantId: OrderBy
  paymentMethod: OrderBy
  purchaseId: OrderBy
}

"""
Ordering options when selecting data from "invoice_page.invoice_payment".
"""
input InvoicePaymentOrderBy {
  amountPaid: OrderBy
  createdAt: OrderBy
  currency: OrderBy
  id: OrderBy
  merchantId: OrderBy
  paymentMethod: OrderBy
  purchaseId: OrderBy
}

"""
select columns of table "invoice_page.invoice_payment"
"""
enum InvoicePaymentSelectColumn {
  """column name"""
  amountPaid

  """column name"""
  createdAt

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  merchantId

  """column name"""
  paymentMethod

  """column name"""
  purchaseId
}

"""
order by stddev() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentStddevOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by stddev_pop() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentStddevPopOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by stddev_samp() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentStddevSampOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by sum() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentSumOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by var_pop() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentVarPopOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by var_samp() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentVarSampOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by variance() on columns of table "invoice_page.invoice_payment"
"""
input InvoicePaymentVarianceOrderBy {
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
select columns of table "invoice.invoice"
"""
enum InvoiceSelectColumn {
  """column name"""
  createdAt

  """column name"""
  dueDate

  """column name"""
  expectedAmount

  """column name"""
  invoiceNumber

  """column name"""
  invoicePageJwt

  """column name"""
  merchantId

  """column name"""
  merchantReference

  """column name"""
  purchaseId
}

"""aggregate stddev on columns"""
type InvoiceStddevFields {
  expectedAmount: Float
  invoiceNumber: Float
  merchantId: Float
  purchaseId: Float
}

"""aggregate stddev_pop on columns"""
type InvoiceStddevPopFields {
  expectedAmount: Float
  invoiceNumber: Float
  merchantId: Float
  purchaseId: Float
}

"""aggregate stddev_samp on columns"""
type InvoiceStddevSampFields {
  expectedAmount: Float
  invoiceNumber: Float
  merchantId: Float
  purchaseId: Float
}

"""aggregate sum on columns"""
type InvoiceSumFields {
  expectedAmount: bigint
  invoiceNumber: bigint
  merchantId: bigint
  purchaseId: bigint
}

"""A surcharge (fee) added to an invoice"""
type InvoiceSurcharge {
  amount: bigint!
  createdAt: timestamptz!
  currency: currency!
  id: bigint!
  merchantId: bigint!
  purchaseId: bigint!
  surchargeType: citext!
}

"""
order by aggregate values of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeAggregateOrderBy {
  avg: InvoiceSurchargeAvgOrderBy
  count: OrderBy
  max: InvoiceSurchargeMaxOrderBy
  min: InvoiceSurchargeMinOrderBy
  stddev: InvoiceSurchargeStddevOrderBy
  stddev_pop: InvoiceSurchargeStddevPopOrderBy
  stddev_samp: InvoiceSurchargeStddevSampOrderBy
  sum: InvoiceSurchargeSumOrderBy
  var_pop: InvoiceSurchargeVarPopOrderBy
  var_samp: InvoiceSurchargeVarSampOrderBy
  variance: InvoiceSurchargeVarianceOrderBy
}

"""
order by avg() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeAvgOrderBy {
  amount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
Boolean expression to filter rows from the table "invoice_page.invoice_surcharge". All fields are combined with a logical 'AND'.
"""
input InvoiceSurchargeBoolExp {
  _and: [InvoiceSurchargeBoolExp!]
  _not: InvoiceSurchargeBoolExp
  _or: [InvoiceSurchargeBoolExp!]
  amount: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  currency: CurrencyComparisonExp
  id: BigintComparisonExp
  merchantId: BigintComparisonExp
  purchaseId: BigintComparisonExp
  surchargeType: CitextComparisonExp
}

"""
order by max() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeMaxOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
  surchargeType: OrderBy
}

"""
order by min() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeMinOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
  surchargeType: OrderBy
}

"""
Ordering options when selecting data from "invoice_page.invoice_surcharge".
"""
input InvoiceSurchargeOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  currency: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
  surchargeType: OrderBy
}

"""
select columns of table "invoice_page.invoice_surcharge"
"""
enum InvoiceSurchargeSelectColumn {
  """column name"""
  amount

  """column name"""
  createdAt

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  merchantId

  """column name"""
  purchaseId

  """column name"""
  surchargeType
}

"""
order by stddev() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeStddevOrderBy {
  amount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by stddev_pop() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeStddevPopOrderBy {
  amount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by stddev_samp() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeStddevSampOrderBy {
  amount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by sum() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeSumOrderBy {
  amount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by var_pop() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeVarPopOrderBy {
  amount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by var_samp() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeVarSampOrderBy {
  amount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by variance() on columns of table "invoice_page.invoice_surcharge"
"""
input InvoiceSurchargeVarianceOrderBy {
  amount: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""A transaction (capture, return, discount, etc.) for an invoice"""
type InvoiceTransaction {
  createdAt: timestamptz!
  id: bigint!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinctOn: [InvoiceTransactionItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceTransactionItemOrderBy!]

    """filter the rows returned"""
    where: InvoiceTransactionItemBoolExp
  ): [InvoiceTransactionItem!]!
  merchantId: bigint!
  purchaseId: bigint!

  """An enum value of possible transaction types"""
  transactionType: invoice_transaction_type!
}

"""
order by aggregate values of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionAggregateOrderBy {
  avg: InvoiceTransactionAvgOrderBy
  count: OrderBy
  max: InvoiceTransactionMaxOrderBy
  min: InvoiceTransactionMinOrderBy
  stddev: InvoiceTransactionStddevOrderBy
  stddev_pop: InvoiceTransactionStddevPopOrderBy
  stddev_samp: InvoiceTransactionStddevSampOrderBy
  sum: InvoiceTransactionSumOrderBy
  var_pop: InvoiceTransactionVarPopOrderBy
  var_samp: InvoiceTransactionVarSampOrderBy
  variance: InvoiceTransactionVarianceOrderBy
}

"""
order by avg() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionAvgOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
Boolean expression to filter rows from the table "invoice_page.invoice_transaction". All fields are combined with a logical 'AND'.
"""
input InvoiceTransactionBoolExp {
  _and: [InvoiceTransactionBoolExp!]
  _not: InvoiceTransactionBoolExp
  _or: [InvoiceTransactionBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  items: InvoiceTransactionItemBoolExp
  merchantId: BigintComparisonExp
  purchaseId: BigintComparisonExp
  transactionType: InvoiceTransactionTypeComparisonExp
}

"""Items apprearing on invoice transactions"""
type InvoiceTransactionItem {
  currency: currency!
  imageUrl: String
  itemUrl: String
  merchantId: bigint!
  name: String!
  purchaseId: bigint!
  quantity: Int!
  reference: citext!
  totalAmount: bigint!
  totalDiscount: bigint!
  transactionId: bigint!
  transactionType: invoice_transaction_type!
}

"""
order by aggregate values of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemAggregateOrderBy {
  avg: InvoiceTransactionItemAvgOrderBy
  count: OrderBy
  max: InvoiceTransactionItemMaxOrderBy
  min: InvoiceTransactionItemMinOrderBy
  stddev: InvoiceTransactionItemStddevOrderBy
  stddev_pop: InvoiceTransactionItemStddevPopOrderBy
  stddev_samp: InvoiceTransactionItemStddevSampOrderBy
  sum: InvoiceTransactionItemSumOrderBy
  var_pop: InvoiceTransactionItemVarPopOrderBy
  var_samp: InvoiceTransactionItemVarSampOrderBy
  variance: InvoiceTransactionItemVarianceOrderBy
}

"""
order by avg() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemAvgOrderBy {
  merchantId: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
Boolean expression to filter rows from the table "invoice_page.invoice_transaction_item". All fields are combined with a logical 'AND'.
"""
input InvoiceTransactionItemBoolExp {
  _and: [InvoiceTransactionItemBoolExp!]
  _not: InvoiceTransactionItemBoolExp
  _or: [InvoiceTransactionItemBoolExp!]
  currency: CurrencyComparisonExp
  imageUrl: StringComparisonExp
  itemUrl: StringComparisonExp
  merchantId: BigintComparisonExp
  name: StringComparisonExp
  purchaseId: BigintComparisonExp
  quantity: IntComparisonExp
  reference: CitextComparisonExp
  totalAmount: BigintComparisonExp
  totalDiscount: BigintComparisonExp
  transactionId: BigintComparisonExp
  transactionType: InvoiceTransactionTypeComparisonExp
}

"""
order by max() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemMaxOrderBy {
  imageUrl: OrderBy
  itemUrl: OrderBy
  merchantId: OrderBy
  name: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  reference: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
  transactionType: OrderBy
}

"""
order by min() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemMinOrderBy {
  imageUrl: OrderBy
  itemUrl: OrderBy
  merchantId: OrderBy
  name: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  reference: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
  transactionType: OrderBy
}

"""
Ordering options when selecting data from "invoice_page.invoice_transaction_item".
"""
input InvoiceTransactionItemOrderBy {
  currency: OrderBy
  imageUrl: OrderBy
  itemUrl: OrderBy
  merchantId: OrderBy
  name: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  reference: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
  transactionType: OrderBy
}

"""
select columns of table "invoice_page.invoice_transaction_item"
"""
enum InvoiceTransactionItemSelectColumn {
  """column name"""
  currency

  """column name"""
  imageUrl

  """column name"""
  itemUrl

  """column name"""
  merchantId

  """column name"""
  name

  """column name"""
  purchaseId

  """column name"""
  quantity

  """column name"""
  reference

  """column name"""
  totalAmount

  """column name"""
  totalDiscount

  """column name"""
  transactionId

  """column name"""
  transactionType
}

"""
order by stddev() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemStddevOrderBy {
  merchantId: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
order by stddev_pop() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemStddevPopOrderBy {
  merchantId: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
order by stddev_samp() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemStddevSampOrderBy {
  merchantId: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
order by sum() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemSumOrderBy {
  merchantId: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
order by var_pop() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemVarPopOrderBy {
  merchantId: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
order by var_samp() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemVarSampOrderBy {
  merchantId: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
order by variance() on columns of table "invoice_page.invoice_transaction_item"
"""
input InvoiceTransactionItemVarianceOrderBy {
  merchantId: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  totalAmount: OrderBy
  totalDiscount: OrderBy
  transactionId: OrderBy
}

"""
order by max() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """An enum value of possible transaction types"""
  transactionType: OrderBy
}

"""
order by min() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """An enum value of possible transaction types"""
  transactionType: OrderBy
}

"""
Ordering options when selecting data from "invoice_page.invoice_transaction".
"""
input InvoiceTransactionOrderBy {
  createdAt: OrderBy
  id: OrderBy
  itemsAggregate: InvoiceTransactionItemAggregateOrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
  transactionType: OrderBy
}

"""
select columns of table "invoice_page.invoice_transaction"
"""
enum InvoiceTransactionSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  merchantId

  """column name"""
  purchaseId

  """column name"""
  transactionType
}

"""
order by stddev() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionStddevOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by stddev_pop() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionStddevPopOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by stddev_samp() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionStddevSampOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by sum() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionSumOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
Boolean expression to compare columns of type "invoice_transaction_type". All fields are combined with logical 'AND'.
"""
input InvoiceTransactionTypeComparisonExp {
  _eq: invoice_transaction_type
  _gt: invoice_transaction_type
  _gte: invoice_transaction_type
  _in: [invoice_transaction_type!]
  _isNull: Boolean
  _lt: invoice_transaction_type
  _lte: invoice_transaction_type
  _neq: invoice_transaction_type
  _nin: [invoice_transaction_type!]
}

"""
order by var_pop() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionVarPopOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by var_samp() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionVarSampOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""
order by variance() on columns of table "invoice_page.invoice_transaction"
"""
input InvoiceTransactionVarianceOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""aggregate var_pop on columns"""
type InvoiceVarPopFields {
  expectedAmount: Float
  invoiceNumber: Float
  merchantId: Float
  purchaseId: Float
}

"""aggregate var_samp on columns"""
type InvoiceVarSampFields {
  expectedAmount: Float
  invoiceNumber: Float
  merchantId: Float
  purchaseId: Float
}

"""aggregate variance on columns"""
type InvoiceVarianceFields {
  expectedAmount: Float
  invoiceNumber: Float
  merchantId: Float
  purchaseId: Float
}

"""
A list of discounts to apply on items that has been captured and are in an invoice.
"""
input ItemDiscountInput {
  """List of discounts to apply."""
  discounts: [ItemDiscountLineInput!]!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!
}

"""List of discount items that are part of this request."""
input ItemDiscountLineInput {
  """
  Total amount of the discount. Includes tax discounts.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.
  """
  discountAmount: Int!

  """
  Merchant's own internal item number or any other reference that may help the
  merchant in identifying this purchase.
  """
  itemReference: String!

  """Id of the purchase"""
  purchaseId: bigint!
}

"""The result of adding the item discount."""
type ItemDiscountResult {
  """Ids of the discounts created."""
  captureItemDiscountIds: [Int!]!
}

input JsonbCastExp {
  String: StringComparisonExp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input JsonbComparisonExp {
  _cast: JsonbCastExp

  """is the column contained in the given json value"""
  _containedIn: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _hasKey: String

  """do all of these strings exist as top-level keys in the column"""
  _hasKeysAll: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _hasKeysAny: [String!]
  _in: [jsonb!]
  _isNull: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""Supported languages"""
enum Language {
  DA
  EN
  IS
  NO
  SV
}

"""List of merchants registered with us."""
type Merchant {
  """
  
          Interval after which a purchase expires and can no more be captured.
      
  """
  captureExpiryWindow: interval!

  """
  
          Currency in which the purchase and other operations are done.
          Only currencies in ISO-4217 format are recognized.
          The currency needs to match the supported currencies for the merchant.
          Example: SEK, EUR.
      
  """
  currency: currency!
  id: bigint!
  name: String!

  """
  
          Interval after which a partially captured purchase expires after which it can no more be captured.
      
  """
  partialCaptureWindow: interval!
}

"""
Boolean expression to filter rows from the table "tenant.merchant". All fields are combined with a logical 'AND'.
"""
input MerchantBoolExp {
  _and: [MerchantBoolExp!]
  _not: MerchantBoolExp
  _or: [MerchantBoolExp!]
  captureExpiryWindow: IntervalComparisonExp
  currency: CurrencyComparisonExp
  id: BigintComparisonExp
  name: StringComparisonExp
  partialCaptureWindow: IntervalComparisonExp
}

enum MerchantMetricEnum {
  INSTALMENT_PURCHASES
  INVOICE_PURCHASES
  REFUNDS
  SUCCESSFUL_CREDIT_CARD_PAYMENTS
  SUCCESSFUL_DIRECT_DEBIT_PAYMENTS
  SUCCESSFUL_MOBILEPAY_PAYMENTS
  SUCCESSFUL_PAYMENTS
  SUCCESSFUL_SWISH_PAYMENTS
  SUCCESSFUL_VIPPS_PAYMENTS
}

"""
Boolean expression to compare columns of type "MerchantMetricEnum". All fields are combined with logical 'AND'.
"""
input MerchantMetricEnumComparisonExp {
  _eq: MerchantMetricEnum
  _in: [MerchantMetricEnum!]
  _isNull: Boolean
  _neq: MerchantMetricEnum
  _nin: [MerchantMetricEnum!]
}

"""Ordering options when selecting data from "tenant.merchant"."""
input MerchantOrderBy {
  captureExpiryWindow: OrderBy
  currency: OrderBy
  id: OrderBy
  name: OrderBy
  partialCaptureWindow: OrderBy
}

"""Describe the schema for mobilepay details."""
type MobilePayDetails {
  cardCountry: String
  cardExpiryDate: date
  cardNumber: String
  cardType: String
  threeDSecureStatus: Boolean
}

"""
order by aggregate values of table "runtime.transaction_mobilepay_details"
"""
input MobilePayDetailsAggregateOrderBy {
  count: OrderBy
  max: MobilePayDetailsMaxOrderBy
  min: MobilePayDetailsMinOrderBy
}

"""
Boolean expression to filter rows from the table "runtime.transaction_mobilepay_details". All fields are combined with a logical 'AND'.
"""
input MobilePayDetailsBoolExp {
  _and: [MobilePayDetailsBoolExp!]
  _not: MobilePayDetailsBoolExp
  _or: [MobilePayDetailsBoolExp!]
  cardCountry: StringComparisonExp
  cardExpiryDate: DateComparisonExp
  cardNumber: StringComparisonExp
  cardType: StringComparisonExp
  threeDSecureStatus: BooleanComparisonExp
}

"""
order by max() on columns of table "runtime.transaction_mobilepay_details"
"""
input MobilePayDetailsMaxOrderBy {
  cardCountry: OrderBy
  cardExpiryDate: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
}

"""
order by min() on columns of table "runtime.transaction_mobilepay_details"
"""
input MobilePayDetailsMinOrderBy {
  cardCountry: OrderBy
  cardExpiryDate: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
}

"""
Ordering options when selecting data from "runtime.transaction_mobilepay_details".
"""
input MobilePayDetailsOrderBy {
  cardCountry: OrderBy
  cardExpiryDate: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
  threeDSecureStatus: OrderBy
}

"""
select columns of table "runtime.transaction_mobilepay_details"
"""
enum MobilePayDetailsSelectColumn {
  """column name"""
  cardCountry

  """column name"""
  cardExpiryDate

  """column name"""
  cardNumber

  """column name"""
  cardType

  """column name"""
  threeDSecureStatus
}

"""column ordering options"""
enum OrderBy {
  """in ascending order, nulls last"""
  ASC

  """in ascending order, nulls first"""
  ASC_NULLS_FIRST

  """in ascending order, nulls last"""
  ASC_NULLS_LAST

  """in descending order, nulls first"""
  DESC

  """in descending order, nulls first"""
  DESC_NULLS_FIRST

  """in descending order, nulls last"""
  DESC_NULLS_LAST
}

enum OrderStatusEnum {
  """The order was cancelled by the merchant"""
  CANCELLED

  """The order has been fully captured by the merchant"""
  CAPTURE_DONE

  """The customer needs to setup recurring payments"""
  INSTALMENTS_AUTHORIZE

  """The customer needs to pay the first instalment"""
  INSTALMENT_PRE_PAYMENT

  """The order has been captured partially by the merchant"""
  PARTIALLY_CAPTURED

  """Validating the order and the customer"""
  PRE_FLIGHT_SCORING

  """The order was rejected because of its risk profile"""
  REJECTED

  """Assessing the customer"""
  RISK_SCORING

  """Strong Customer Authentication is needed before completing the order"""
  SCA_REQUIRED

  """The order has been processed as is waiting for capture"""
  WAITING_FOR_CAPTURE
}

"""
Boolean expression to compare columns of type "OrderStatusEnum". All fields are combined with logical 'AND'.
"""
input OrderStatusEnumComparisonExp {
  _eq: OrderStatusEnum
  _in: [OrderStatusEnum!]
  _isNull: Boolean
  _neq: OrderStatusEnum
  _nin: [OrderStatusEnum!]
}

"""
Boolean expression to compare columns of type "packed_phone_number". All fields are combined with logical 'AND'.
"""
input PackedPhoneNumberComparisonExp {
  _eq: packed_phone_number
  _gt: packed_phone_number
  _gte: packed_phone_number
  _in: [packed_phone_number!]
  _isNull: Boolean
  _lt: packed_phone_number
  _lte: packed_phone_number
  _neq: packed_phone_number
  _nin: [packed_phone_number!]
}

"""Arguments for paying an instalment"""
input PayInstalmentInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  The purchaseId is the purchase for which the customer
  is paying the instalment.
  
  Max length: 64.
  """
  purchaseId: bigint!
}

"""The result of initiating a payment for an instalment."""
type PayInstalmentResult {
  """
  Once a payment is initialized, we will return a bearer token.
  You can use this token to start the payment flow either with
  swish or finshark.
  """
  token: String!
}

"""Arguments for creating a new PayPal payment"""
input PayPalPaymentInput {
  """
  The amount the customer pays in minor units.
  So 100,56 kr would be 10056
  """
  amount: Int!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  Merchant's own internal reference that may help the
  merchant in identifying this payment. These have to
  be globally unique but they should be reused for retrying
  a payment.
  
  Max length: 64.
  """
  merchantReference: String!

  """
  A message to show to the customer on their bank statement.
  It could be an order id or a reference.
  
  Max length: 50.
  """
  message: String!

  """Payment category that determines the payment flow"""
  paymentCategory: PaymentCategory!

  """
  Our system's own internal reference that can be used uniquely
  in identifying this payment.
  """
  paymentReference: String!

  """The url to return to after the payment is done."""
  returnUrl: String!
}

"""The result of initiating a PayPal payment."""
type PayPalPaymentResult {
  """
  The amount the customer pays in minor units.
  So 100,56 kr would be 10056
  """
  amount: String!

  """The currency of the payment"""
  currency: String!

  """
  Once a payment is initialized, we will start the PayPal payment
  workflow. You can use this id to query the current status of the
  payment.
  """
  paymentId: String!
}

"""Record of payment made to a merchant that we processed."""
type Payment {
  amountAuthorized: bigint

  """Amount paid by the customer to the merchant."""
  amountPaid: bigint!

  """An array relationship"""
  captures(
    """distinct select on columns"""
    distinctOn: [PaymentCaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCaptureOrderBy!]

    """filter the rows returned"""
    where: PaymentCaptureBoolExp
  ): [PaymentCapture!]!

  """An aggregate relationship"""
  capturesAggregate(
    """distinct select on columns"""
    distinctOn: [PaymentCaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCaptureOrderBy!]

    """filter the rows returned"""
    where: PaymentCaptureBoolExp
  ): PaymentCaptureAggregate!
  createdAt: timestamptz!
  currency: SupportedCurrencyEnum!

  """An object relationship"""
  customer: CustomerPaymentData
  id: bigint!
  materializedStatus: String!

  """An object relationship"""
  merchant: Merchant!
  merchantId: bigint!

  """Reference use by the merchant when creating the payment"""
  merchantReference: String!
  paymentMethod: PaymentMethodEnum!
  paymentRefundStatus: PaymentRefundStatusEnum

  """An array relationship"""
  refunds(
    """distinct select on columns"""
    distinctOn: [RefundSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RefundOrderBy!]

    """filter the rows returned"""
    where: RefundBoolExp
  ): [Refund!]!

  """An aggregate relationship"""
  refundsAggregate(
    """distinct select on columns"""
    distinctOn: [RefundSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RefundOrderBy!]

    """filter the rows returned"""
    where: RefundBoolExp
  ): RefundAggregate!
}

"""
aggregated selection of "payment_gateway.payment"
"""
type PaymentAggregate {
  aggregate: PaymentAggregateFields
  nodes: [Payment!]!
}

"""
aggregate fields of "payment_gateway.payment"
"""
type PaymentAggregateFields {
  avg: PaymentAvgFields
  count(columns: [PaymentSelectColumn!], distinct: Boolean): Int!
  max: PaymentMaxFields
  min: PaymentMinFields
  stddev: PaymentStddevFields
  stddevPop: PaymentStddevPopFields
  stddevSamp: PaymentStddevSampFields
  sum: PaymentSumFields
  varPop: PaymentVarPopFields
  varSamp: PaymentVarSampFields
  variance: PaymentVarianceFields
}

"""aggregate avg on columns"""
type PaymentAvgFields {
  amountAuthorized: Float

  """Amount paid by the customer to the merchant."""
  amountPaid: Float
  id: Float
  merchantId: Float
}

"""
Boolean expression to filter rows from the table "payment_gateway.payment". All fields are combined with a logical 'AND'.
"""
input PaymentBoolExp {
  _and: [PaymentBoolExp!]
  _not: PaymentBoolExp
  _or: [PaymentBoolExp!]
  amountAuthorized: BigintComparisonExp
  amountPaid: BigintComparisonExp
  captures: PaymentCaptureBoolExp
  createdAt: TimestamptzComparisonExp
  currency: SupportedCurrencyEnumComparisonExp
  customer: CustomerPaymentDataBoolExp
  id: BigintComparisonExp
  materializedStatus: StringComparisonExp
  merchant: MerchantBoolExp
  merchantId: BigintComparisonExp
  merchantReference: StringComparisonExp
  paymentMethod: PaymentMethodEnumComparisonExp
  paymentRefundStatus: PaymentRefundStatusEnumComparisonExp
  refunds: RefundBoolExp
}

"""URL containing a downloadable CSV with payment data"""
type PaymentCSV {
  createdAt: timestamptz!

  """
  
          End date till which the csv is generated.
          
  """
  endDate: date!

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String
  expiresAt: timestamptz

  """This is the key that we send to query for the links."""
  id: bigint!

  """
  The Amazon S3 presigned URL shared with merchant for them to download the csv.
  """
  link: String
  merchantId: bigint!

  """
  
          Start date from which the csv is generated.
          
  """
  startDate: date!

  """The status of creating the presigned URL."""
  status: ReportLinkStatusEnum!
}

"""
aggregated selection of "merchant_portal.generated_payments_csv"
"""
type PaymentCSVAggregate {
  aggregate: PaymentCSVAggregateFields
  nodes: [PaymentCSV!]!
}

"""
aggregate fields of "merchant_portal.generated_payments_csv"
"""
type PaymentCSVAggregateFields {
  avg: PaymentCSVAvgFields
  count(columns: [PaymentCSVSelectColumn!], distinct: Boolean): Int!
  max: PaymentCSVMaxFields
  min: PaymentCSVMinFields
  stddev: PaymentCSVStddevFields
  stddevPop: PaymentCSVStddevPopFields
  stddevSamp: PaymentCSVStddevSampFields
  sum: PaymentCSVSumFields
  varPop: PaymentCSVVarPopFields
  varSamp: PaymentCSVVarSampFields
  variance: PaymentCSVVarianceFields
}

"""aggregate avg on columns"""
type PaymentCSVAvgFields {
  """This is the key that we send to query for the links."""
  id: Float
  merchantId: Float
}

"""
Boolean expression to filter rows from the table "merchant_portal.generated_payments_csv". All fields are combined with a logical 'AND'.
"""
input PaymentCSVBoolExp {
  _and: [PaymentCSVBoolExp!]
  _not: PaymentCSVBoolExp
  _or: [PaymentCSVBoolExp!]
  createdAt: TimestamptzComparisonExp
  endDate: DateComparisonExp
  errMessage: StringComparisonExp
  expiresAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  link: StringComparisonExp
  merchantId: BigintComparisonExp
  startDate: DateComparisonExp
  status: ReportLinkStatusEnumComparisonExp
}

"""aggregate max on columns"""
type PaymentCSVMaxFields {
  createdAt: timestamptz

  """
  
          End date till which the csv is generated.
          
  """
  endDate: date

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String
  expiresAt: timestamptz

  """This is the key that we send to query for the links."""
  id: bigint

  """
  The Amazon S3 presigned URL shared with merchant for them to download the csv.
  """
  link: String
  merchantId: bigint

  """
  
          Start date from which the csv is generated.
          
  """
  startDate: date
}

"""aggregate min on columns"""
type PaymentCSVMinFields {
  createdAt: timestamptz

  """
  
          End date till which the csv is generated.
          
  """
  endDate: date

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String
  expiresAt: timestamptz

  """This is the key that we send to query for the links."""
  id: bigint

  """
  The Amazon S3 presigned URL shared with merchant for them to download the csv.
  """
  link: String
  merchantId: bigint

  """
  
          Start date from which the csv is generated.
          
  """
  startDate: date
}

"""
Ordering options when selecting data from "merchant_portal.generated_payments_csv".
"""
input PaymentCSVOrderBy {
  createdAt: OrderBy
  endDate: OrderBy
  errMessage: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  link: OrderBy
  merchantId: OrderBy
  startDate: OrderBy
  status: OrderBy
}

"""
select columns of table "merchant_portal.generated_payments_csv"
"""
enum PaymentCSVSelectColumn {
  """column name"""
  createdAt

  """column name"""
  endDate

  """column name"""
  errMessage

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  link

  """column name"""
  merchantId

  """column name"""
  startDate

  """column name"""
  status
}

"""aggregate stddev on columns"""
type PaymentCSVStddevFields {
  """This is the key that we send to query for the links."""
  id: Float
  merchantId: Float
}

"""aggregate stddev_pop on columns"""
type PaymentCSVStddevPopFields {
  """This is the key that we send to query for the links."""
  id: Float
  merchantId: Float
}

"""aggregate stddev_samp on columns"""
type PaymentCSVStddevSampFields {
  """This is the key that we send to query for the links."""
  id: Float
  merchantId: Float
}

"""aggregate sum on columns"""
type PaymentCSVSumFields {
  """This is the key that we send to query for the links."""
  id: bigint
  merchantId: bigint
}

"""aggregate var_pop on columns"""
type PaymentCSVVarPopFields {
  """This is the key that we send to query for the links."""
  id: Float
  merchantId: Float
}

"""aggregate var_samp on columns"""
type PaymentCSVVarSampFields {
  """This is the key that we send to query for the links."""
  id: Float
  merchantId: Float
}

"""aggregate variance on columns"""
type PaymentCSVVarianceFields {
  """This is the key that we send to query for the links."""
  id: Float
  merchantId: Float
}

"""Arguments for cancelling payment"""
input PaymentCancelInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """The payment reference to cancel."""
  paymentReference: String!
}

"""The result of cancelling a payment request."""
type PaymentCancelResult {
  """
  The returned token can be used to query whether the payment has
  been cancelled or not.
  """
  waitToken: String
}

"""Table to store payment captures."""
type PaymentCapture {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: bigint!
  createdAt: timestamptz!
  id: bigint!
  latestStatus: String!

  """Merchant who has created the capture."""
  merchantId: bigint!

  """Message for this capture."""
  message: String

  """An object relationship"""
  payment: Payment

  """Payment to which this capture belongs to."""
  paymentId: bigint!

  """List of statuses the capture is currently on"""
  status(
    """distinct select on columns"""
    distinctOn: [CurrentCaptureStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentCaptureStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentCaptureStatusBoolExp
  ): [CurrentCaptureStatus!]

  """List of statuses the capture has been on"""
  statusHistory(
    """distinct select on columns"""
    distinctOn: [CurrentCaptureStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentCaptureStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentCaptureStatusBoolExp
  ): [CurrentCaptureStatus!]
}

"""
aggregated selection of "payment_gateway.payment_capture"
"""
type PaymentCaptureAggregate {
  aggregate: PaymentCaptureAggregateFields
  nodes: [PaymentCapture!]!
}

"""
aggregate fields of "payment_gateway.payment_capture"
"""
type PaymentCaptureAggregateFields {
  avg: PaymentCaptureAvgFields
  count(columns: [PaymentCaptureSelectColumn!], distinct: Boolean): Int!
  max: PaymentCaptureMaxFields
  min: PaymentCaptureMinFields
  stddev: PaymentCaptureStddevFields
  stddevPop: PaymentCaptureStddevPopFields
  stddevSamp: PaymentCaptureStddevSampFields
  sum: PaymentCaptureSumFields
  varPop: PaymentCaptureVarPopFields
  varSamp: PaymentCaptureVarSampFields
  variance: PaymentCaptureVarianceFields
}

"""
order by aggregate values of table "payment_gateway.payment_capture"
"""
input PaymentCaptureAggregateOrderBy {
  avg: PaymentCaptureAvgOrderBy
  count: OrderBy
  max: PaymentCaptureMaxOrderBy
  min: PaymentCaptureMinOrderBy
  stddev: PaymentCaptureStddevOrderBy
  stddev_pop: PaymentCaptureStddevPopOrderBy
  stddev_samp: PaymentCaptureStddevSampOrderBy
  sum: PaymentCaptureSumOrderBy
  var_pop: PaymentCaptureVarPopOrderBy
  var_samp: PaymentCaptureVarSampOrderBy
  variance: PaymentCaptureVarianceOrderBy
}

"""Arguments for fully capturing a payment."""
input PaymentCaptureAllInput {
  """
  The amount to capture in minor units.
  So 100,56 kr would be 10056.
  Amount should be in between 0 and authorized amount.
  If omited, a capture would be created for the amount required to capture all that was authorized.
  If lower than authorized amount - amount paid, a refund will be created if the capture is successful.
  """
  amount: Int

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  A message to be displayed on the portal associated with this capture.
  Message will appear in the customer's account statement.
  
  Max length: 50.
  """
  message: String

  """Id of the payment to capture."""
  paymentId: bigint!

  """
  A message to be displayed to the customer in case a refund is made
  when returning excess amount. This message will appear in the customer's account statement if any refund is made.
  
  Max length: 50.
  """
  refundMessage: String
}

"""aggregate avg on columns"""
type PaymentCaptureAvgFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: Float
  id: Float

  """Merchant who has created the capture."""
  merchantId: Float

  """Payment to which this capture belongs to."""
  paymentId: Float
}

"""
order by avg() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureAvgOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Merchant who has created the capture."""
  merchantId: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""
Boolean expression to filter rows from the table "payment_gateway.payment_capture". All fields are combined with a logical 'AND'.
"""
input PaymentCaptureBoolExp {
  _and: [PaymentCaptureBoolExp!]
  _not: PaymentCaptureBoolExp
  _or: [PaymentCaptureBoolExp!]
  amount: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  latestStatus: StringComparisonExp
  merchantId: BigintComparisonExp
  message: StringComparisonExp
  payment: PaymentBoolExp
  paymentId: BigintComparisonExp
  status: CurrentCaptureStatusBoolExp
  statusHistory: CurrentCaptureStatusBoolExp
}

"""Arguments for partially capturing a payment."""
input PaymentCaptureInput {
  """
  The amount to capture in minor units.
  So 100,56 kr would be 10056.
  Amount should be in between 0 and authorized amount.
  """
  amount: Int!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  A message to be displayed on the portal associated with this capture.
  Message will appear in the customer's account statement.
  
  Max length: 50.
  """
  message: String

  """Id of the payment to capture."""
  paymentId: bigint!
}

"""aggregate max on columns"""
type PaymentCaptureMaxFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: bigint
  createdAt: timestamptz
  id: bigint
  latestStatus: String

  """Merchant who has created the capture."""
  merchantId: bigint

  """Message for this capture."""
  message: String

  """Payment to which this capture belongs to."""
  paymentId: bigint
}

"""
order by max() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureMaxOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  createdAt: OrderBy
  id: OrderBy
  latestStatus: OrderBy

  """Merchant who has created the capture."""
  merchantId: OrderBy

  """Message for this capture."""
  message: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""aggregate min on columns"""
type PaymentCaptureMinFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: bigint
  createdAt: timestamptz
  id: bigint
  latestStatus: String

  """Merchant who has created the capture."""
  merchantId: bigint

  """Message for this capture."""
  message: String

  """Payment to which this capture belongs to."""
  paymentId: bigint
}

"""
order by min() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureMinOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  createdAt: OrderBy
  id: OrderBy
  latestStatus: OrderBy

  """Merchant who has created the capture."""
  merchantId: OrderBy

  """Message for this capture."""
  message: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""
Ordering options when selecting data from "payment_gateway.payment_capture".
"""
input PaymentCaptureOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  id: OrderBy
  latestStatus: OrderBy
  merchantId: OrderBy
  message: OrderBy
  payment: PaymentOrderBy
  paymentId: OrderBy
  statusAggregate: CurrentCaptureStatusAggregateOrderBy
  statusHistoryAggregate: CurrentCaptureStatusAggregateOrderBy
}

"""The result of capturing a payment."""
type PaymentCaptureResult {
  """
  Once a payment is captured. We will start processing the capture.
  You can use this token to query the created capture.
  """
  captureId: bigint!
}

"""
select columns of table "payment_gateway.payment_capture"
"""
enum PaymentCaptureSelectColumn {
  """column name"""
  amount

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  latestStatus

  """column name"""
  merchantId

  """column name"""
  message

  """column name"""
  paymentId
}

enum PaymentCaptureStatusEnum {
  CAPTURE_COOLDOWN
  CAPTURE_DECLINED
  CAPTURE_DONE
  CAPTURING
  ERROR
  WAITING_FOR_CAPTURE
}

"""
Boolean expression to compare columns of type "PaymentCaptureStatusEnum". All fields are combined with logical 'AND'.
"""
input PaymentCaptureStatusEnumComparisonExp {
  _eq: PaymentCaptureStatusEnum
  _in: [PaymentCaptureStatusEnum!]
  _isNull: Boolean
  _neq: PaymentCaptureStatusEnum
  _nin: [PaymentCaptureStatusEnum!]
}

"""aggregate stddev on columns"""
type PaymentCaptureStddevFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: Float
  id: Float

  """Merchant who has created the capture."""
  merchantId: Float

  """Payment to which this capture belongs to."""
  paymentId: Float
}

"""
order by stddev() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureStddevOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Merchant who has created the capture."""
  merchantId: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""aggregate stddev_pop on columns"""
type PaymentCaptureStddevPopFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: Float
  id: Float

  """Merchant who has created the capture."""
  merchantId: Float

  """Payment to which this capture belongs to."""
  paymentId: Float
}

"""
order by stddev_pop() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureStddevPopOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Merchant who has created the capture."""
  merchantId: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""aggregate stddev_samp on columns"""
type PaymentCaptureStddevSampFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: Float
  id: Float

  """Merchant who has created the capture."""
  merchantId: Float

  """Payment to which this capture belongs to."""
  paymentId: Float
}

"""
order by stddev_samp() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureStddevSampOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Merchant who has created the capture."""
  merchantId: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""aggregate sum on columns"""
type PaymentCaptureSumFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: bigint
  id: bigint

  """Merchant who has created the capture."""
  merchantId: bigint

  """Payment to which this capture belongs to."""
  paymentId: bigint
}

"""
order by sum() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureSumOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Merchant who has created the capture."""
  merchantId: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""aggregate var_pop on columns"""
type PaymentCaptureVarPopFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: Float
  id: Float

  """Merchant who has created the capture."""
  merchantId: Float

  """Payment to which this capture belongs to."""
  paymentId: Float
}

"""
order by var_pop() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureVarPopOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Merchant who has created the capture."""
  merchantId: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""aggregate var_samp on columns"""
type PaymentCaptureVarSampFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: Float
  id: Float

  """Merchant who has created the capture."""
  merchantId: Float

  """Payment to which this capture belongs to."""
  paymentId: Float
}

"""
order by var_samp() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureVarSampOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Merchant who has created the capture."""
  merchantId: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""aggregate variance on columns"""
type PaymentCaptureVarianceFields {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: Float
  id: Float

  """Merchant who has created the capture."""
  merchantId: Float

  """Payment to which this capture belongs to."""
  paymentId: Float
}

"""
order by variance() on columns of table "payment_gateway.payment_capture"
"""
input PaymentCaptureVarianceOrderBy {
  """Amount to capture, should be less than or equal to authorized amount."""
  amount: OrderBy
  id: OrderBy

  """Merchant who has created the capture."""
  merchantId: OrderBy

  """Payment to which this capture belongs to."""
  paymentId: OrderBy
}

"""Payment Category that determines the payment flow"""
enum PaymentCategory {
  Account
  Instalment
  Invoice
  StandAlone
}

"""aggregate max on columns"""
type PaymentMaxFields {
  amountAuthorized: bigint

  """Amount paid by the customer to the merchant."""
  amountPaid: bigint
  createdAt: timestamptz
  id: bigint
  materializedStatus: String
  merchantId: bigint

  """Reference use by the merchant when creating the payment"""
  merchantReference: String
}

enum PaymentMethodEnum {
  """Credit or Debit cards"""
  CREDIT_CARD

  """Open Banking direct debit via Finshark"""
  FINSHARK_DIRECT_DEBIT

  """Open Banking recurring debit via Finshark"""
  FINSHARK_RECURRING_DEBIT

  """Pay with MobilePay Online"""
  MOBILEPAY

  """Pay with PayPal"""
  PAYPAL

  """Swish"""
  SWISH

  """Pay with Vipps"""
  VIPPS
}

"""
Boolean expression to compare columns of type "PaymentMethodEnum". All fields are combined with logical 'AND'.
"""
input PaymentMethodEnumComparisonExp {
  _eq: PaymentMethodEnum
  _in: [PaymentMethodEnum!]
  _isNull: Boolean
  _neq: PaymentMethodEnum
  _nin: [PaymentMethodEnum!]
}

"""Payment methods available for a merchant."""
type PaymentMethodStatus {
  country: country!
  currency: currency!
  enabled: Boolean
  gateway: String!
  gatewayPaymentMethod: String

  """Merchant id of the merchant."""
  merchantId: bigint!

  """The payment method supported / available for this merchant.."""
  paymentMethod: PaymentMethodEnum!
}

"""
Boolean expression to filter rows from the table "tenant.payment_method_available". All fields are combined with a logical 'AND'.
"""
input PaymentMethodStatusBoolExp {
  _and: [PaymentMethodStatusBoolExp!]
  _not: PaymentMethodStatusBoolExp
  _or: [PaymentMethodStatusBoolExp!]
  country: CountryComparisonExp
  currency: CurrencyComparisonExp
  enabled: BooleanComparisonExp
  gateway: StringComparisonExp
  gatewayPaymentMethod: StringComparisonExp
  merchantId: BigintComparisonExp
  paymentMethod: PaymentMethodEnumComparisonExp
}

"""
Ordering options when selecting data from "tenant.payment_method_available".
"""
input PaymentMethodStatusOrderBy {
  country: OrderBy
  currency: OrderBy
  enabled: OrderBy
  gateway: OrderBy
  gatewayPaymentMethod: OrderBy
  merchantId: OrderBy
  paymentMethod: OrderBy
}

"""
select columns of table "tenant.payment_method_available"
"""
enum PaymentMethodStatusSelectColumn {
  """column name"""
  country

  """column name"""
  currency

  """column name"""
  enabled

  """column name"""
  gateway

  """column name"""
  gatewayPaymentMethod

  """column name"""
  merchantId

  """column name"""
  paymentMethod
}

"""aggregate min on columns"""
type PaymentMinFields {
  amountAuthorized: bigint

  """Amount paid by the customer to the merchant."""
  amountPaid: bigint
  createdAt: timestamptz
  id: bigint
  materializedStatus: String
  merchantId: bigint

  """Reference use by the merchant when creating the payment"""
  merchantReference: String
}

"""Ordering options when selecting data from "payment_gateway.payment"."""
input PaymentOrderBy {
  amountAuthorized: OrderBy
  amountPaid: OrderBy
  capturesAggregate: PaymentCaptureAggregateOrderBy
  createdAt: OrderBy
  currency: OrderBy
  customer: CustomerPaymentDataOrderBy
  id: OrderBy
  materializedStatus: OrderBy
  merchant: MerchantOrderBy
  merchantId: OrderBy
  merchantReference: OrderBy
  paymentMethod: OrderBy
  paymentRefundStatus: OrderBy
  refundsAggregate: RefundAggregateOrderBy
}

enum PaymentRefundStatusEnum {
  """The payment is fully refunded"""
  FULLY_REFUNDED

  """The payment has no refunds"""
  NO_REFUND

  """The payment is partially refunded"""
  PARTIALLY_REFUNDED
}

"""
Boolean expression to compare columns of type "PaymentRefundStatusEnum". All fields are combined with logical 'AND'.
"""
input PaymentRefundStatusEnumComparisonExp {
  _eq: PaymentRefundStatusEnum
  _in: [PaymentRefundStatusEnum!]
  _isNull: Boolean
  _neq: PaymentRefundStatusEnum
  _nin: [PaymentRefundStatusEnum!]
}

"""A payment requested"""
type PaymentRequest {
  amount: bigint!
  createdAt: timestamptz!
  currency: SupportedCurrencyEnum!

  """The payment's latest known status"""
  currentStatus: PaymentStatusEnum!

  """An object relationship"""
  customer: CustomerPaymentData

  """Gives the latest status that the payment is on."""
  latestStatus(
    """distinct select on columns"""
    distinctOn: [CurrentPaymentStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentPaymentStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentPaymentStatusBoolExp
  ): [CurrentPaymentStatus!]

  """An object relationship"""
  merchant: Merchant!
  merchantId: bigint!
  message: String!

  """An object relationship"""
  payment: Payment
  paymentFlow: String
  paymentProvider: PaymentMethodEnum

  """
  
  Payments are linked to a reference, this can be a purchase id or
  any reference the merchant sends when making a stand alone payment.
  
  """
  reference: String!

  """Id of the generated gateway payment (stand alone payments only)."""
  resultingPaymentId: bigint

  """List of statuses the payment is currently on"""
  status(
    """distinct select on columns"""
    distinctOn: [CurrentPaymentStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentPaymentStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentPaymentStatusBoolExp
  ): [CurrentPaymentStatus!]

  """List of statuses the payment has been on"""
  statusHistory(
    """distinct select on columns"""
    distinctOn: [CurrentPaymentStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentPaymentStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentPaymentStatusBoolExp
  ): [CurrentPaymentStatus!]

  """
  A computed field, executes function "runtime.get_transaction_credit_card_details"
  """
  transactionCreditCardDetails(
    """distinct select on columns"""
    distinctOn: [CreditCardDetailsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CreditCardDetailsOrderBy!]

    """filter the rows returned"""
    where: CreditCardDetailsBoolExp
  ): [CreditCardDetails!]

  """
  A computed field, executes function "runtime.get_transaction_finshark_details"
  """
  transactionFinsharkDetails(
    """distinct select on columns"""
    distinctOn: [FinsharkDetailsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [FinsharkDetailsOrderBy!]

    """filter the rows returned"""
    where: FinsharkDetailsBoolExp
  ): [FinsharkDetails!]

  """
  A computed field, executes function "runtime.get_transaction_mobilepay_details"
  """
  transactionMobilePayDetails(
    """distinct select on columns"""
    distinctOn: [MobilePayDetailsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [MobilePayDetailsOrderBy!]

    """filter the rows returned"""
    where: MobilePayDetailsBoolExp
  ): [MobilePayDetails!]

  """
  A computed field, executes function "runtime.get_transaction_swish_details"
  """
  transactionSwishDetails(
    """distinct select on columns"""
    distinctOn: [SwishDetailsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SwishDetailsOrderBy!]

    """filter the rows returned"""
    where: SwishDetailsBoolExp
  ): [SwishDetails!]

  """
  A computed field, executes function "runtime.get_transaction_vipps_details"
  """
  transactionVippsDetails(
    """distinct select on columns"""
    distinctOn: [VippsDetailsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [VippsDetailsOrderBy!]

    """filter the rows returned"""
    where: VippsDetailsBoolExp
  ): [VippsDetails!]
  waitToken: uuid!
}

"""
Boolean expression to filter rows from the table "runtime.payment". All fields are combined with a logical 'AND'.
"""
input PaymentRequestBoolExp {
  _and: [PaymentRequestBoolExp!]
  _not: PaymentRequestBoolExp
  _or: [PaymentRequestBoolExp!]
  amount: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  currency: SupportedCurrencyEnumComparisonExp
  currentStatus: PaymentStatusEnumComparisonExp
  customer: CustomerPaymentDataBoolExp
  latestStatus: CurrentPaymentStatusBoolExp
  merchant: MerchantBoolExp
  merchantId: BigintComparisonExp
  message: StringComparisonExp
  payment: PaymentBoolExp
  paymentFlow: StringComparisonExp
  paymentProvider: PaymentMethodEnumComparisonExp
  reference: StringComparisonExp
  resultingPaymentId: BigintComparisonExp
  status: CurrentPaymentStatusBoolExp
  statusHistory: CurrentPaymentStatusBoolExp
  transactionCreditCardDetails: CreditCardDetailsBoolExp
  transactionFinsharkDetails: FinsharkDetailsBoolExp
  transactionMobilePayDetails: MobilePayDetailsBoolExp
  transactionSwishDetails: SwishDetailsBoolExp
  transactionVippsDetails: VippsDetailsBoolExp
  waitToken: UuidComparisonExp
}

"""URL containing a downloadable CSV with payment request data"""
type PaymentRequestCSV {
  createdAt: timestamptz!
  customerEmail: String

  """
  
          End date till which the csv is generated.
          
  """
  endDate: date!

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String
  expiresAt: timestamptz

  """This is the key that we send to query for the links."""
  id: bigint!

  """
  The Amazon S3 presigned URL shared with merchant for them to download the csv.
  """
  link: String
  maxAmount: bigint
  merchantId: bigint!
  minAmount: bigint
  reference: String

  """
  
          Start date from which the csv is generated.
          
  """
  startDate: date!

  """The status of creating the presigned URL."""
  status: ReportLinkStatusEnum!
}

"""
Boolean expression to filter rows from the table "merchant_portal.generated_payment_requests_csv". All fields are combined with a logical 'AND'.
"""
input PaymentRequestCSVBoolExp {
  _and: [PaymentRequestCSVBoolExp!]
  _not: PaymentRequestCSVBoolExp
  _or: [PaymentRequestCSVBoolExp!]
  createdAt: TimestamptzComparisonExp
  customerEmail: StringComparisonExp
  endDate: DateComparisonExp
  errMessage: StringComparisonExp
  expiresAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  link: StringComparisonExp
  maxAmount: BigintComparisonExp
  merchantId: BigintComparisonExp
  minAmount: BigintComparisonExp
  reference: StringComparisonExp
  startDate: DateComparisonExp
  status: ReportLinkStatusEnumComparisonExp
}

"""
Ordering options when selecting data from "merchant_portal.generated_payment_requests_csv".
"""
input PaymentRequestCSVOrderBy {
  createdAt: OrderBy
  customerEmail: OrderBy
  endDate: OrderBy
  errMessage: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  link: OrderBy
  maxAmount: OrderBy
  merchantId: OrderBy
  minAmount: OrderBy
  reference: OrderBy
  startDate: OrderBy
  status: OrderBy
}

"""
select columns of table "merchant_portal.generated_payment_requests_csv"
"""
enum PaymentRequestCSVSelectColumn {
  """column name"""
  createdAt

  """column name"""
  customerEmail

  """column name"""
  endDate

  """column name"""
  errMessage

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  link

  """column name"""
  maxAmount

  """column name"""
  merchantId

  """column name"""
  minAmount

  """column name"""
  reference

  """column name"""
  startDate

  """column name"""
  status
}

"""Payment method"""
enum PaymentRequestMethod {
  """Credit or Debit cards"""
  CREDIT_CARD

  """Open Banking direct debit via Finshark"""
  FINSHARK_DIRECT_DEBIT

  """Open Banking recurring debit via Finshark"""
  FINSHARK_RECURRING_DEBIT

  """Pay with MobilePay Online"""
  MOBILEPAY

  """Pay with PayPal"""
  PAYPAL

  """Swish"""
  SWISH

  """Pay with Vipps"""
  VIPPS
}

"""Ordering options when selecting data from "runtime.payment"."""
input PaymentRequestOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  currency: OrderBy
  currentStatus: OrderBy
  customer: CustomerPaymentDataOrderBy
  latestStatusAggregate: CurrentPaymentStatusAggregateOrderBy
  merchant: MerchantOrderBy
  merchantId: OrderBy
  message: OrderBy
  payment: PaymentOrderBy
  paymentFlow: OrderBy
  paymentProvider: OrderBy
  reference: OrderBy
  resultingPaymentId: OrderBy
  statusAggregate: CurrentPaymentStatusAggregateOrderBy
  statusHistoryAggregate: CurrentPaymentStatusAggregateOrderBy
  transactionCreditCardDetailsAggregate: CreditCardDetailsAggregateOrderBy
  transactionFinsharkDetailsAggregate: FinsharkDetailsAggregateOrderBy
  transactionMobilePayDetailsAggregate: MobilePayDetailsAggregateOrderBy
  transactionSwishDetailsAggregate: SwishDetailsAggregateOrderBy
  transactionVippsDetailsAggregate: VippsDetailsAggregateOrderBy
  waitToken: OrderBy
}

"""The refund status of the resulting payment"""
enum PaymentRequestRefundStatus {
  """The payment is fully refunded"""
  FULLY_REFUNDED

  """The payment has no refunds"""
  NO_REFUND

  """The payment is partially refunded"""
  PARTIALLY_REFUNDED
}

"""
select columns of table "runtime.payment"
"""
enum PaymentRequestSelectColumn {
  """column name"""
  amount

  """column name"""
  createdAt

  """column name"""
  currency

  """column name"""
  currentStatus

  """column name"""
  merchantId

  """column name"""
  message

  """column name"""
  paymentFlow

  """column name"""
  paymentProvider

  """column name"""
  reference

  """column name"""
  resultingPaymentId

  """column name"""
  waitToken
}

"""Payment status"""
enum PaymentRequestStatus {
  """Payment is authorized. Can be captured now."""
  AUTHORIZED

  """Payment was cancelled."""
  CANCELLED

  """Attempting to cancel the payment."""
  CANCELLING

  """
  Payment capture is declined. Please create a new payment. (Only applicable for credit card payments)
  """
  CAPTURE_DECLINED

  """Payment was declined by the customer."""
  DECLINED

  """Payment errored."""
  ERROR

  """Payment is initialising."""
  INITIALIZING

  """Payment is paid."""
  PAID

  """
  Payment is partially captured. (Only applicable for credit card payments)
  """
  PARTIALLY_CAPTURED

  """Payment is undergoing check."""
  PRE_FLIGHT_CHECK

  """Payment is requested and waiting for confirmation."""
  WAITING_FOR_PAYMENT
}

"""
select columns of table "payment_gateway.payment"
"""
enum PaymentSelectColumn {
  """column name"""
  amountAuthorized

  """column name"""
  amountPaid

  """column name"""
  createdAt

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  materializedStatus

  """column name"""
  merchantId

  """column name"""
  merchantReference

  """column name"""
  paymentMethod

  """column name"""
  paymentRefundStatus
}

"""Arguments for adding additional data to a payment."""
input PaymentSessionAdditionalData {
  """The E-mail address of the customer."""
  email: String!

  """IP address of the customer attempting the payment."""
  ip: String!

  """
  Language in which the payment is being handled
  Only languages in two-letter `ISO-639-1` format are recognized.
  Example: `SV`, `DA`, `NO`, `IS`, `EN`.
  """
  language: Language!

  """
  The name of the customer that the payment is associated with.
  
  Max length: 100.
  """
  name: String!

  """
  Phone number
  Max length: 100.
  """
  phoneNumber: String
}

"""Arguments for creating a new payment session."""
input PaymentSessionInput {
  """Additional data about the customer attempting the payment."""
  additionalData: PaymentSessionAdditionalData

  """
  The amount the customer pays in minor units.
  So 100,56 kr would be 10056
  """
  amount: Int!

  """
  When `currency` is not set, it defaults to the merchant's default currency.
  
  When no payment method is available for the given currency, then
  `newPaymentSession` fails with an error. Similarly, attempting to
  create a payment with a payment method that is not available for
  the given currency also results in an error.
  """
  currency: SupportedCurrencyEnum

  """
  Session expiry timestamp in ISO8601 format.
  E.g. '1970-01-01T00:00:00Z'
  Max is 24 hrs from creation of session.
  """
  expiresAt: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  Merchant's own internal reference that may help the
  merchant in identifying this payment. These have to
  be globally unique but they should be reused for retrying
  a payment.
  
  Max length: 64.
  """
  merchantReference: String!

  """
  A message to show to the customer. It could be an order id or a reference.
  Only alphanumeric, Swedish characters, and the following are allowed:
  - ':'
  - ';'
  - '.'
  - ','
  - '?'
  - '!'
  - '('
  - ')'
  - ''
  - '"'
  - ' '
  
  Max length: 50.
  """
  message: String!
}

"""The result of starting a new payment session."""
type PaymentSessionResult {
  """
  Once a payment session is initialized, you can use this token to start the payment flow.
  """
  token: String!
}

enum PaymentStatusEnum {
  """Payment is authorized. Can be captured now."""
  AUTHORIZED

  """Payment was cancelled."""
  CANCELLED

  """Attempting to cancel the payment."""
  CANCELLING

  """
  Payment capture is declined. Please create a new payment. (Only applicable for credit card payments)
  """
  CAPTURE_DECLINED

  """Payment was declined by the customer."""
  DECLINED

  """Payment errored."""
  ERROR

  """Payment is initialising."""
  INITIALIZING

  """Payment is paid."""
  PAID

  """
  Payment is partially captured. (Only applicable for credit card payments)
  """
  PARTIALLY_CAPTURED

  """Payment is undergoing check."""
  PRE_FLIGHT_CHECK

  """Payment is requested and waiting for confirmation."""
  WAITING_FOR_PAYMENT
}

"""
Boolean expression to compare columns of type "PaymentStatusEnum". All fields are combined with logical 'AND'.
"""
input PaymentStatusEnumComparisonExp {
  _eq: PaymentStatusEnum
  _in: [PaymentStatusEnum!]
  _isNull: Boolean
  _neq: PaymentStatusEnum
  _nin: [PaymentStatusEnum!]
}

"""aggregate stddev on columns"""
type PaymentStddevFields {
  amountAuthorized: Float

  """Amount paid by the customer to the merchant."""
  amountPaid: Float
  id: Float
  merchantId: Float
}

"""aggregate stddev_pop on columns"""
type PaymentStddevPopFields {
  amountAuthorized: Float

  """Amount paid by the customer to the merchant."""
  amountPaid: Float
  id: Float
  merchantId: Float
}

"""aggregate stddev_samp on columns"""
type PaymentStddevSampFields {
  amountAuthorized: Float

  """Amount paid by the customer to the merchant."""
  amountPaid: Float
  id: Float
  merchantId: Float
}

"""aggregate sum on columns"""
type PaymentSumFields {
  amountAuthorized: bigint

  """Amount paid by the customer to the merchant."""
  amountPaid: bigint
  id: bigint
  merchantId: bigint
}

"""aggregate var_pop on columns"""
type PaymentVarPopFields {
  amountAuthorized: Float

  """Amount paid by the customer to the merchant."""
  amountPaid: Float
  id: Float
  merchantId: Float
}

"""aggregate var_samp on columns"""
type PaymentVarSampFields {
  amountAuthorized: Float

  """Amount paid by the customer to the merchant."""
  amountPaid: Float
  id: Float
  merchantId: Float
}

"""aggregate variance on columns"""
type PaymentVarianceFields {
  amountAuthorized: Float

  """Amount paid by the customer to the merchant."""
  amountPaid: Float
  id: Float
  merchantId: Float
}

"""

        A purchase is an order that has been fully acknowledged by us and linked to an authenticated customer.
    
"""
type Purchase {
  """An object relationship"""
  billingAddress: CustomerAddress!
  billingAddressId: bigint!

  """An array relationship"""
  captureItemDiscounts(
    """distinct select on columns"""
    distinctOn: [DiscountSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DiscountOrderBy!]

    """filter the rows returned"""
    where: DiscountBoolExp
  ): [Discount!]!

  """An aggregate relationship"""
  captureItemDiscountsAggregate(
    """distinct select on columns"""
    distinctOn: [DiscountSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DiscountOrderBy!]

    """filter the rows returned"""
    where: DiscountBoolExp
  ): DiscountAggregate!

  """An array relationship"""
  captures(
    """distinct select on columns"""
    distinctOn: [CaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CaptureOrderBy!]

    """filter the rows returned"""
    where: CaptureBoolExp
  ): [Capture!]!

  """An aggregate relationship"""
  capturesAggregate(
    """distinct select on columns"""
    distinctOn: [CaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CaptureOrderBy!]

    """filter the rows returned"""
    where: CaptureBoolExp
  ): CaptureAggregate!
  createdAt: timestamptz!

  """An object relationship"""
  customer: Customer!
  customerId: bigint!
  deliveryAddressId: bigint
  deliveryMethod: String!

  """An object relationship"""
  expiration: PurchaseExpiration
  id: bigint!

  """List of instalment statuses the purchase is currently on"""
  instalmentStatus(
    """distinct select on columns"""
    distinctOn: [CurrentInstalmentStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentInstalmentStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentInstalmentStatusBoolExp
  ): [CurrentInstalmentStatus!]

  """An array relationship"""
  instalments(
    """distinct select on columns"""
    distinctOn: [InstalmentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InstalmentOrderBy!]

    """filter the rows returned"""
    where: InstalmentBoolExp
  ): [Instalment!]!

  """An object relationship"""
  invoice: Invoice

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinctOn: [PurchaseItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseItemOrderBy!]

    """filter the rows returned"""
    where: PurchaseItemBoolExp
  ): [PurchaseItem!]!

  """An aggregate relationship"""
  itemsAggregate(
    """distinct select on columns"""
    distinctOn: [PurchaseItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseItemOrderBy!]

    """filter the rows returned"""
    where: PurchaseItemBoolExp
  ): PurchaseItemAggregate!

  """An object relationship"""
  merchant: Merchant!
  merchantId: bigint!

  """
  This is a reference key that the merchant provides for their internal tracking.
  """
  merchantReference: String!

  """An array relationship"""
  payments(
    """distinct select on columns"""
    distinctOn: [PurchasePaymentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchasePaymentOrderBy!]

    """filter the rows returned"""
    where: PurchasePaymentBoolExp
  ): [PurchasePayment!]!

  """An aggregate relationship"""
  paymentsAggregate(
    """distinct select on columns"""
    distinctOn: [PurchasePaymentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchasePaymentOrderBy!]

    """filter the rows returned"""
    where: PurchasePaymentBoolExp
  ): PurchasePaymentAggregate!

  """An array relationship"""
  returns(
    """distinct select on columns"""
    distinctOn: [ReturnSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReturnOrderBy!]

    """filter the rows returned"""
    where: ReturnBoolExp
  ): [Return!]!

  """An aggregate relationship"""
  returnsAggregate(
    """distinct select on columns"""
    distinctOn: [ReturnSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReturnOrderBy!]

    """filter the rows returned"""
    where: ReturnBoolExp
  ): ReturnAggregate!

  """An object relationship"""
  shippingAddress: CustomerAddress

  """List of statuses the purchase is currently on"""
  status(
    """distinct select on columns"""
    distinctOn: [CurrentPurchaseStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentPurchaseStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentPurchaseStatusBoolExp
  ): [CurrentPurchaseStatus!]

  """An array relationship"""
  surcharges(
    """distinct select on columns"""
    distinctOn: [SurchargeSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SurchargeOrderBy!]

    """filter the rows returned"""
    where: SurchargeBoolExp
  ): [Surcharge!]!
  taxAmount: bigint!

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: bigint!
}

"""
aggregated selection of "marketplace.purchase"
"""
type PurchaseAggregate {
  aggregate: PurchaseAggregateFields
  nodes: [Purchase!]!
}

"""
aggregate fields of "marketplace.purchase"
"""
type PurchaseAggregateFields {
  avg: PurchaseAvgFields
  count(columns: [PurchaseSelectColumn!], distinct: Boolean): Int!
  max: PurchaseMaxFields
  min: PurchaseMinFields
  stddev: PurchaseStddevFields
  stddevPop: PurchaseStddevPopFields
  stddevSamp: PurchaseStddevSampFields
  sum: PurchaseSumFields
  varPop: PurchaseVarPopFields
  varSamp: PurchaseVarSampFields
  variance: PurchaseVarianceFields
}

"""
order by aggregate values of table "marketplace.purchase"
"""
input PurchaseAggregateOrderBy {
  avg: PurchaseAvgOrderBy
  count: OrderBy
  max: PurchaseMaxOrderBy
  min: PurchaseMinOrderBy
  stddev: PurchaseStddevOrderBy
  stddev_pop: PurchaseStddevPopOrderBy
  stddev_samp: PurchaseStddevSampOrderBy
  sum: PurchaseSumOrderBy
  var_pop: PurchaseVarPopOrderBy
  var_samp: PurchaseVarSampOrderBy
  variance: PurchaseVarianceOrderBy
}

"""aggregate avg on columns"""
type PurchaseAvgFields {
  billingAddressId: Float
  customerId: Float
  deliveryAddressId: Float
  id: Float
  merchantId: Float
  taxAmount: Float

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: Float
}

"""
order by avg() on columns of table "marketplace.purchase"
"""
input PurchaseAvgOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.purchase". All fields are combined with a logical 'AND'.
"""
input PurchaseBoolExp {
  _and: [PurchaseBoolExp!]
  _not: PurchaseBoolExp
  _or: [PurchaseBoolExp!]
  billingAddress: CustomerAddressBoolExp
  billingAddressId: BigintComparisonExp
  captureItemDiscounts: DiscountBoolExp
  captures: CaptureBoolExp
  createdAt: TimestamptzComparisonExp
  customer: CustomerBoolExp
  customerId: BigintComparisonExp
  deliveryAddressId: BigintComparisonExp
  deliveryMethod: StringComparisonExp
  expiration: PurchaseExpirationBoolExp
  id: BigintComparisonExp
  instalmentStatus: CurrentInstalmentStatusBoolExp
  instalments: InstalmentBoolExp
  invoice: InvoiceBoolExp
  items: PurchaseItemBoolExp
  merchant: MerchantBoolExp
  merchantId: BigintComparisonExp
  merchantReference: StringComparisonExp
  payments: PurchasePaymentBoolExp
  returns: ReturnBoolExp
  shippingAddress: CustomerAddressBoolExp
  status: CurrentPurchaseStatusBoolExp
  surcharges: SurchargeBoolExp
  taxAmount: BigintComparisonExp
  totalAmount: BigintComparisonExp
}

"""The current status of the bulk capture request"""
type PurchaseBulkCaptureStatus {
  captureId: bigint
  createdAt: timestamptz!
  description: String
  errMessage: String
  merchantId: bigint!
  purchaseId: bigint!
  status: CaptureStatusEnum!
  waitToken: String!
}

"""
Boolean expression to filter rows from the table "runtime.purchase_capture_job_status". All fields are combined with a logical 'AND'.
"""
input PurchaseBulkCaptureStatusBoolExp {
  _and: [PurchaseBulkCaptureStatusBoolExp!]
  _not: PurchaseBulkCaptureStatusBoolExp
  _or: [PurchaseBulkCaptureStatusBoolExp!]
  captureId: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  description: StringComparisonExp
  errMessage: StringComparisonExp
  merchantId: BigintComparisonExp
  purchaseId: BigintComparisonExp
  status: CaptureStatusEnumComparisonExp
  waitToken: StringComparisonExp
}

"""
Ordering options when selecting data from "runtime.purchase_capture_job_status".
"""
input PurchaseBulkCaptureStatusOrderBy {
  captureId: OrderBy
  createdAt: OrderBy
  description: OrderBy
  errMessage: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
  status: OrderBy
  waitToken: OrderBy
}

"""
select columns of table "runtime.purchase_capture_job_status"
"""
enum PurchaseBulkCaptureStatusSelectColumn {
  """column name"""
  captureId

  """column name"""
  createdAt

  """column name"""
  description

  """column name"""
  errMessage

  """column name"""
  merchantId

  """column name"""
  purchaseId

  """column name"""
  status

  """column name"""
  waitToken
}

"""URL containing a downloadable CSV with purchase data"""
type PurchaseCSV {
  createdAt: timestamptz!

  """
  
          End date till which the csv is generated.
          
  """
  endDate: date!

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String
  expiresAt: timestamptz

  """This is the key that we send to query for the links."""
  id: bigint!

  """
  The Amazon S3 presigned URL shared with merchant for them to download the csv.
  """
  link: String
  merchantId: bigint!

  """
  
          Start date from which the csv is generated.
          
  """
  startDate: date!

  """The status of creating the presigned URL."""
  status: ReportLinkStatusEnum!
}

"""
Boolean expression to filter rows from the table "merchant_portal.generated_purchases_csv". All fields are combined with a logical 'AND'.
"""
input PurchaseCSVBoolExp {
  _and: [PurchaseCSVBoolExp!]
  _not: PurchaseCSVBoolExp
  _or: [PurchaseCSVBoolExp!]
  createdAt: TimestamptzComparisonExp
  endDate: DateComparisonExp
  errMessage: StringComparisonExp
  expiresAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  link: StringComparisonExp
  merchantId: BigintComparisonExp
  startDate: DateComparisonExp
  status: ReportLinkStatusEnumComparisonExp
}

"""
Ordering options when selecting data from "merchant_portal.generated_purchases_csv".
"""
input PurchaseCSVOrderBy {
  createdAt: OrderBy
  endDate: OrderBy
  errMessage: OrderBy
  expiresAt: OrderBy
  id: OrderBy
  link: OrderBy
  merchantId: OrderBy
  startDate: OrderBy
  status: OrderBy
}

"""
select columns of table "merchant_portal.generated_purchases_csv"
"""
enum PurchaseCSVSelectColumn {
  """column name"""
  createdAt

  """column name"""
  endDate

  """column name"""
  errMessage

  """column name"""
  expiresAt

  """column name"""
  id

  """column name"""
  link

  """column name"""
  merchantId

  """column name"""
  startDate

  """column name"""
  status
}

"""
A purchase cancellation made when we are waiting for captures or we already have a capture
"""
input PurchaseCancelInput {
  """This is the id of the purchase to cancel."""
  purchaseId: bigint!
}

"""The result of cancelling a purchase."""
type PurchaseCancelResult {
  """We return True for success and False for failure."""
  result: Boolean!
}

"""A complete shipment of multiple purchases."""
input PurchaseCaptureAllBatchInput {
  """
  Description of the purchase capture.
  Max length: 10000.
  """
  description: String

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """Id of the purchase"""
  purchaseIds: [bigint!]!
}

"""The result of initiating a full capture of multiple purchases."""
type PurchaseCaptureAllBatchResult {
  """
  Once a capture for multiple purchases is received, we will start processing the capture for each purchase.
  We can use the waitToken to query the status of capture for each of the purchases.
  """
  waitToken: String!
}

"""A complete shipment of a purchase."""
input PurchaseCaptureAllInput {
  """
  Description of the purchase capture.
  Max length: 10000.
  """
  description: String

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """Id of the purchase"""
  purchaseId: bigint!
}

"""A set of purchase filters to use for performing a full capture."""
input PurchaseCaptureAllRangeFilterByInput {
  """Purchase status to filter by for full capture"""
  status: [PurchaseCaptureStatus!]!
}

"""A complete shipment of multiple purchases."""
input PurchaseCaptureAllRangeInput {
  """
  Description of the purchase capture.
  Max length: 10000.
  """
  description: String

  """End date (inclusive) to filter for purchases."""
  endDate: String!

  """A set of filters to filter the purchase by."""
  filterBy: PurchaseCaptureAllRangeFilterByInput!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """Start date (inclusive) from when to filter for purchases."""
  startDate: String!
}

"""
The result of initiating a full capture for the date range and/or purchase status filter.
"""
type PurchaseCaptureAllRangeResult {
  """
  Once a capture for multiple purchases is received, we will start processing the capture for each purchase.
  We can use the waitToken to query the status of capture for purchases in the date range and the purchase status filter used.
  """
  waitToken: String!
}

"""The result of capturing a purchase."""
type PurchaseCaptureAllResult {
  """
  Once a purchase is captured. We will start processing the payout to the merchant.
  You can use this token to query the created capture.
  """
  captureId: bigint!
}

"""A partial or complete shipment of a purchase."""
input PurchaseCaptureInput {
  """List of items captured in this purchase."""
  captureItems: [PurchaseCaptureItemInput!]!

  """
  Description of the purchase capture.
  Max length: 10000.
  """
  description: String

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """Id of the purchase"""
  purchaseId: bigint!
}

"""An item from the purchase order"""
input PurchaseCaptureItemInput {
  """Unit price including tax in minor units."""
  pricePerItem: Int!

  """Number of items captured sharing the same reference."""
  quantity: Int!

  """
  Unique item identification reference.';
  Max length: 64.
  """
  reference: String!

  """
  The tax rate in percent with two implicit decimals. Non-negative. Example: 1500 = 15%
  """
  taxRate: Int!

  """
  Total amount (including tax and discounts) in minor units for the items being captured.
  """
  totalAmount: Int!

  """
  Total tax amount on all the captured items of this type in minor units.
  Example: 1500,25 SEk should be 150025.
  
  Example 100 SEK should be 10000.
  """
  totalTaxAmount: Int!
}

"""The result of capturing a purchase."""
type PurchaseCaptureResult {
  """
  Once a purchase is captured. We will start processing the payout to the merchant.
  You can use this token to query the created capture.
  """
  captureId: bigint!
}

"""Purchase capture status to be used for filtering"""
enum PurchaseCaptureStatus {
  CAPTURE_DONE
  PARTIALLY_CAPTURED
  WAITING_FOR_CAPTURE
}

"""A partial or complete shipment of the items in a purchase."""
input PurchaseCaptureWithItemReferencesInput {
  """
  Description of the purchase capture.
  Max length: 10000.
  """
  description: String

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """List of items references in the purchase to be captured."""
  itemReferences: [String!]!

  """ID of the purchase"""
  purchaseId: bigint!
}

"""The result of capturing the items in the purchase."""
type PurchaseCaptureWithItemReferencesResult {
  """
  Once a purchase is captured, we will start processing the payout to the merchant.
  You can use this token to query the created capture.
  """
  captureId: bigint!
}

"""Edit a purchase address (billing or shipping)."""
input PurchaseEditAddressInput {
  """Id of the address that will be changed."""
  addressId: bigint!

  """City of the customer."""
  city: String!

  """Country of the customer."""
  country: String!

  """Email of the customer."""
  email: String!

  """Customer's first name."""
  firstName: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """Customer's last name."""
  lastName: String!

  """Line 1 of the customer address."""
  line1: String!

  """Line 2 of the customer address."""
  line2: String

  """Phone number of the customer."""
  phoneNumber: String!

  """Postal code of the customer."""
  postalCode: String!

  """Id of the purchase to edit."""
  purchaseId: bigint!
}

"""Result of editing an address of a purchase (billing or shipping)."""
type PurchaseEditAddressResult {
  """Customer who made the purchase."""
  customerId: bigint!
}

"""Edit a purchase that hasn't been captured yet."""
input PurchaseEditInput {
  """A list with new purchase items to add to this order."""
  addPurchaseItems: [PurchaseOrderLineInput!]

  """
  Edit the delivery method for the purchase.
  
  Max length: 100.
  """
  deliveryMethod: String

  """A list with all purchase items to edit."""
  editPurchaseItems: [PurchaseItemEditInput!]

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  Merchant's own internal order number or any other reference that may help the
  merchant in identifying this edit of the purchase.
  
  Max length: 64.
  """
  merchantReference: String

  """Id of the purchase to edit."""
  purchaseId: bigint!

  """
  Total tax amount of all the order in minor units.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.
  
  Must be within 1 of: totalAmount - totalAmount * 10000 / (10000 + taxRate).
  """
  purchaseTaxAmount: Int

  """
  Total amount of all the order in minor units. Includes tax and discounts.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.
  
  Must fulfill equation: total_amount = (quantity x pricePerItem) - totalDiscountAmount
  """
  purchaseTotalAmount: Int
}

"""The result of editing a purchase."""
type PurchaseEditResult {
  """True if a purchase has been successfully edited, False otherwise"""
  success: Boolean!
}

"""
Tracks when a purchase that is still in `waiting_for_capture` would expire
"""
type PurchaseExpiration {
  """Date when the purchase expires"""
  expiresAt: date!
  merchantId: bigint!
  purchaseId: bigint!
}

"""
Boolean expression to filter rows from the table "marketplace.purchase_expiry_tracker". All fields are combined with a logical 'AND'.
"""
input PurchaseExpirationBoolExp {
  _and: [PurchaseExpirationBoolExp!]
  _not: PurchaseExpirationBoolExp
  _or: [PurchaseExpirationBoolExp!]
  expiresAt: DateComparisonExp
  merchantId: BigintComparisonExp
  purchaseId: BigintComparisonExp
}

"""
Ordering options when selecting data from "marketplace.purchase_expiry_tracker".
"""
input PurchaseExpirationOrderBy {
  expiresAt: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
}

"""Item(s) purchased by the customer."""
type PurchaseItem {
  extraDiscountedAmount: bigint!

  """
  
          URL to an image that can be used later in communications between kronor
          and the customer.
      
  """
  imageUrl: String

  """
  
          URL to item in the merchant catalog, that will be used in communications between
          kronor and the customer.
      
  """
  itemUrl: String
  merchantId: bigint!

  """Name of the item provided by the merchant."""
  name: String!

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: bigint!
  purchaseId: bigint!

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Int!

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Int!

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Int!

  """
  Identification number of the item either provided by the merchant as bar code or generated by us.
  """
  reference: citext!

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: smallint!

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: bigint!

  """Amount that has been captured."""
  totalCapturedAmount: bigint!

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: bigint!
  totalReturnedAmount: bigint!

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: bigint!
}

"""
aggregated selection of "marketplace.purchase_item"
"""
type PurchaseItemAggregate {
  aggregate: PurchaseItemAggregateFields
  nodes: [PurchaseItem!]!
}

"""
aggregate fields of "marketplace.purchase_item"
"""
type PurchaseItemAggregateFields {
  avg: PurchaseItemAvgFields
  count(columns: [PurchaseItemSelectColumn!], distinct: Boolean): Int!
  max: PurchaseItemMaxFields
  min: PurchaseItemMinFields
  stddev: PurchaseItemStddevFields
  stddevPop: PurchaseItemStddevPopFields
  stddevSamp: PurchaseItemStddevSampFields
  sum: PurchaseItemSumFields
  varPop: PurchaseItemVarPopFields
  varSamp: PurchaseItemVarSampFields
  variance: PurchaseItemVarianceFields
}

"""
order by aggregate values of table "marketplace.purchase_item"
"""
input PurchaseItemAggregateOrderBy {
  avg: PurchaseItemAvgOrderBy
  count: OrderBy
  max: PurchaseItemMaxOrderBy
  min: PurchaseItemMinOrderBy
  stddev: PurchaseItemStddevOrderBy
  stddev_pop: PurchaseItemStddevPopOrderBy
  stddev_samp: PurchaseItemStddevSampOrderBy
  sum: PurchaseItemSumOrderBy
  var_pop: PurchaseItemVarPopOrderBy
  var_samp: PurchaseItemVarSampOrderBy
  variance: PurchaseItemVarianceOrderBy
}

"""aggregate avg on columns"""
type PurchaseItemAvgFields {
  extraDiscountedAmount: Float
  merchantId: Float

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: Float
  purchaseId: Float

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Float

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Float

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Float

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: Float

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: Float

  """Amount that has been captured."""
  totalCapturedAmount: Float

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: Float
  totalReturnedAmount: Float

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: Float
}

"""
order by avg() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemAvgOrderBy {
  extraDiscountedAmount: OrderBy
  merchantId: OrderBy

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: OrderBy

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.purchase_item". All fields are combined with a logical 'AND'.
"""
input PurchaseItemBoolExp {
  _and: [PurchaseItemBoolExp!]
  _not: PurchaseItemBoolExp
  _or: [PurchaseItemBoolExp!]
  extraDiscountedAmount: BigintComparisonExp
  imageUrl: StringComparisonExp
  itemUrl: StringComparisonExp
  merchantId: BigintComparisonExp
  name: StringComparisonExp
  pricePerItem: BigintComparisonExp
  purchaseId: BigintComparisonExp
  quantity: IntComparisonExp
  quantityDelivered: IntComparisonExp
  quantityReturned: IntComparisonExp
  reference: CitextComparisonExp
  taxRate: SmallintComparisonExp
  totalAmount: BigintComparisonExp
  totalCapturedAmount: BigintComparisonExp
  totalDiscountAmount: BigintComparisonExp
  totalReturnedAmount: BigintComparisonExp
  totalTaxAmount: BigintComparisonExp
}

"""
Purchase item to add to a purchase
or edit an existing item in the purchase."
"""
input PurchaseItemEditInput {
  """
  URL to an image that can be used later in communications between kronor
  and the customer.
  
  Max length: 10000.
  """
  imageUrl: String

  """
  URL to item in the merchant catalog, that will be used in communications between
  kronor and the customer.
  
  Max length: 10000.
  """
  itemUrl: String

  """
  The name of the purchased item
  
  Max length: 100.
  """
  name: String

  """
  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.
  """
  pricePerItem: Int

  """
  Number of items ordered by the customer. Needs to be a positive number.
  """
  quantity: Int

  """
  The reference of the item to edit the purchase item. Reference can be queried
  from the 'purchase' query.
  
  Max length: 64.
  """
  reference: String!

  """
  Tax rate on the items ordered in this line.
  Needs to be a non-negative number.
  Example: `15%` discount should be represented as `1500`.
  """
  taxRate: Int

  """
  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.
  """
  totalAmount: Int

  """
  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: `1500,25` SEk should be `150025`.
  Example `100` SEK should be `10000`.
  """
  totalDiscountAmount: Int

  """
  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  
  Example 100 SEK should be 10000.
  """
  totalTaxAmount: Int
}

"""aggregate max on columns"""
type PurchaseItemMaxFields {
  extraDiscountedAmount: bigint

  """
  
          URL to an image that can be used later in communications between kronor
          and the customer.
      
  """
  imageUrl: String

  """
  
          URL to item in the merchant catalog, that will be used in communications between
          kronor and the customer.
      
  """
  itemUrl: String
  merchantId: bigint

  """Name of the item provided by the merchant."""
  name: String

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: bigint
  purchaseId: bigint

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Int

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Int

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Int

  """
  Identification number of the item either provided by the merchant as bar code or generated by us.
  """
  reference: citext

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: smallint

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: bigint

  """Amount that has been captured."""
  totalCapturedAmount: bigint

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: bigint
  totalReturnedAmount: bigint

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: bigint
}

"""
order by max() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemMaxOrderBy {
  extraDiscountedAmount: OrderBy

  """
  
          URL to an image that can be used later in communications between kronor
          and the customer.
      
  """
  imageUrl: OrderBy

  """
  
          URL to item in the merchant catalog, that will be used in communications between
          kronor and the customer.
      
  """
  itemUrl: OrderBy
  merchantId: OrderBy

  """Name of the item provided by the merchant."""
  name: OrderBy

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """
  Identification number of the item either provided by the merchant as bar code or generated by us.
  """
  reference: OrderBy

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: OrderBy

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""aggregate min on columns"""
type PurchaseItemMinFields {
  extraDiscountedAmount: bigint

  """
  
          URL to an image that can be used later in communications between kronor
          and the customer.
      
  """
  imageUrl: String

  """
  
          URL to item in the merchant catalog, that will be used in communications between
          kronor and the customer.
      
  """
  itemUrl: String
  merchantId: bigint

  """Name of the item provided by the merchant."""
  name: String

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: bigint
  purchaseId: bigint

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Int

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Int

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Int

  """
  Identification number of the item either provided by the merchant as bar code or generated by us.
  """
  reference: citext

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: smallint

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: bigint

  """Amount that has been captured."""
  totalCapturedAmount: bigint

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: bigint
  totalReturnedAmount: bigint

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: bigint
}

"""
order by min() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemMinOrderBy {
  extraDiscountedAmount: OrderBy

  """
  
          URL to an image that can be used later in communications between kronor
          and the customer.
      
  """
  imageUrl: OrderBy

  """
  
          URL to item in the merchant catalog, that will be used in communications between
          kronor and the customer.
      
  """
  itemUrl: OrderBy
  merchantId: OrderBy

  """Name of the item provided by the merchant."""
  name: OrderBy

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """
  Identification number of the item either provided by the merchant as bar code or generated by us.
  """
  reference: OrderBy

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: OrderBy

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""Ordering options when selecting data from "marketplace.purchase_item"."""
input PurchaseItemOrderBy {
  extraDiscountedAmount: OrderBy
  imageUrl: OrderBy
  itemUrl: OrderBy
  merchantId: OrderBy
  name: OrderBy
  pricePerItem: OrderBy
  purchaseId: OrderBy
  quantity: OrderBy
  quantityDelivered: OrderBy
  quantityReturned: OrderBy
  reference: OrderBy
  taxRate: OrderBy
  totalAmount: OrderBy
  totalCapturedAmount: OrderBy
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy
  totalTaxAmount: OrderBy
}

"""
select columns of table "marketplace.purchase_item"
"""
enum PurchaseItemSelectColumn {
  """column name"""
  extraDiscountedAmount

  """column name"""
  imageUrl

  """column name"""
  itemUrl

  """column name"""
  merchantId

  """column name"""
  name

  """column name"""
  pricePerItem

  """column name"""
  purchaseId

  """column name"""
  quantity

  """column name"""
  quantityDelivered

  """column name"""
  quantityReturned

  """column name"""
  reference

  """column name"""
  taxRate

  """column name"""
  totalAmount

  """column name"""
  totalCapturedAmount

  """column name"""
  totalDiscountAmount

  """column name"""
  totalReturnedAmount

  """column name"""
  totalTaxAmount
}

"""aggregate stddev on columns"""
type PurchaseItemStddevFields {
  extraDiscountedAmount: Float
  merchantId: Float

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: Float
  purchaseId: Float

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Float

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Float

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Float

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: Float

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: Float

  """Amount that has been captured."""
  totalCapturedAmount: Float

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: Float
  totalReturnedAmount: Float

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: Float
}

"""
order by stddev() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemStddevOrderBy {
  extraDiscountedAmount: OrderBy
  merchantId: OrderBy

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: OrderBy

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""aggregate stddev_pop on columns"""
type PurchaseItemStddevPopFields {
  extraDiscountedAmount: Float
  merchantId: Float

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: Float
  purchaseId: Float

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Float

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Float

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Float

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: Float

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: Float

  """Amount that has been captured."""
  totalCapturedAmount: Float

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: Float
  totalReturnedAmount: Float

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: Float
}

"""
order by stddev_pop() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemStddevPopOrderBy {
  extraDiscountedAmount: OrderBy
  merchantId: OrderBy

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: OrderBy

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""aggregate stddev_samp on columns"""
type PurchaseItemStddevSampFields {
  extraDiscountedAmount: Float
  merchantId: Float

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: Float
  purchaseId: Float

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Float

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Float

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Float

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: Float

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: Float

  """Amount that has been captured."""
  totalCapturedAmount: Float

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: Float
  totalReturnedAmount: Float

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: Float
}

"""
order by stddev_samp() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemStddevSampOrderBy {
  extraDiscountedAmount: OrderBy
  merchantId: OrderBy

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: OrderBy

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""aggregate sum on columns"""
type PurchaseItemSumFields {
  extraDiscountedAmount: bigint
  merchantId: bigint

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: bigint
  purchaseId: bigint

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Int

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Int

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Int

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: smallint

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: bigint

  """Amount that has been captured."""
  totalCapturedAmount: bigint

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: bigint
  totalReturnedAmount: bigint

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: bigint
}

"""
order by sum() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemSumOrderBy {
  extraDiscountedAmount: OrderBy
  merchantId: OrderBy

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: OrderBy

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""aggregate var_pop on columns"""
type PurchaseItemVarPopFields {
  extraDiscountedAmount: Float
  merchantId: Float

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: Float
  purchaseId: Float

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Float

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Float

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Float

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: Float

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: Float

  """Amount that has been captured."""
  totalCapturedAmount: Float

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: Float
  totalReturnedAmount: Float

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: Float
}

"""
order by var_pop() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemVarPopOrderBy {
  extraDiscountedAmount: OrderBy
  merchantId: OrderBy

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: OrderBy

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""aggregate var_samp on columns"""
type PurchaseItemVarSampFields {
  extraDiscountedAmount: Float
  merchantId: Float

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: Float
  purchaseId: Float

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Float

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Float

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Float

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: Float

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: Float

  """Amount that has been captured."""
  totalCapturedAmount: Float

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: Float
  totalReturnedAmount: Float

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: Float
}

"""
order by var_samp() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemVarSampOrderBy {
  extraDiscountedAmount: OrderBy
  merchantId: OrderBy

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: OrderBy

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""aggregate variance on columns"""
type PurchaseItemVarianceFields {
  extraDiscountedAmount: Float
  merchantId: Float

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: Float
  purchaseId: Float

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: Float

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: Float

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: Float

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: Float

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: Float

  """Amount that has been captured."""
  totalCapturedAmount: Float

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: Float
  totalReturnedAmount: Float

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: Float
}

"""
order by variance() on columns of table "marketplace.purchase_item"
"""
input PurchaseItemVarianceOrderBy {
  extraDiscountedAmount: OrderBy
  merchantId: OrderBy

  """
  
          Price per item in this line in minor units. It should include tax, but not any discounts.
          Example: 1500,25 SEK should be 150025.
          Example 100 SEK should be 10000.
      
  """
  pricePerItem: OrderBy
  purchaseId: OrderBy

  """
  Number of items purchased by the customer. Needs to be a positive number.
  """
  quantity: OrderBy

  """
  Number of items delivered by the merchant to the customer. Needs to be a non-negative number.
  """
  quantityDelivered: OrderBy

  """
  Number of items returned by the customer to the merchant. Needs to be a non-negative number.
  """
  quantityReturned: OrderBy

  """
  
          Tax rate on the items purchased in this line.
          Needs to be a non-negative number.
          Example: 15% discount should be represented as 1500.
      
  """
  taxRate: OrderBy

  """
  
          Total amount of all the items in the line in minor units. Includes tax and discounts.
          It should be calculated with (price_per_item * quantity) - discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalAmount: OrderBy

  """Amount that has been captured."""
  totalCapturedAmount: OrderBy

  """
  
          Discount applied on all the items in this line in minor units.
          This value should include any applicable tax.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalDiscountAmount: OrderBy
  totalReturnedAmount: OrderBy

  """
  
          Total tax amount on all the items in this line in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""aggregate max on columns"""
type PurchaseMaxFields {
  billingAddressId: bigint
  createdAt: timestamptz
  customerId: bigint
  deliveryAddressId: bigint
  deliveryMethod: String
  id: bigint
  merchantId: bigint

  """
  This is a reference key that the merchant provides for their internal tracking.
  """
  merchantReference: String
  taxAmount: bigint

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: bigint
}

"""
order by max() on columns of table "marketplace.purchase"
"""
input PurchaseMaxOrderBy {
  billingAddressId: OrderBy
  createdAt: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  deliveryMethod: OrderBy
  id: OrderBy
  merchantId: OrderBy

  """
  This is a reference key that the merchant provides for their internal tracking.
  """
  merchantReference: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""aggregate min on columns"""
type PurchaseMinFields {
  billingAddressId: bigint
  createdAt: timestamptz
  customerId: bigint
  deliveryAddressId: bigint
  deliveryMethod: String
  id: bigint
  merchantId: bigint

  """
  This is a reference key that the merchant provides for their internal tracking.
  """
  merchantReference: String
  taxAmount: bigint

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: bigint
}

"""
order by min() on columns of table "marketplace.purchase"
"""
input PurchaseMinOrderBy {
  billingAddressId: OrderBy
  createdAt: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  deliveryMethod: OrderBy
  id: OrderBy
  merchantId: OrderBy

  """
  This is a reference key that the merchant provides for their internal tracking.
  """
  merchantReference: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""An order placed by a yet to be authenticated customer"""
type PurchaseOrder {
  createdAt: timestamptz!

  """
  
          Idempotency key is required to prevent double processing an order.
          It is recommended to use a deterministic unique value, such as the combination of
          the order id and the customer id. Avoid using time-based values.
      
  """
  id: String!
  merchantId: bigint!
  merchantReference: String!

  """
  
          Country where the purchase is taking place.
          Only countries in two-letter ISO-3166 format are recognized.
          Example: SE, DA, NO, DE, EN
      
  """
  purchaseCountry: country!

  """
  
          Language in which the purchase is being handled
          Only languages in two-letter ISO-639-1 format are recognized.
          Example: SV, DA, NO, DE.
      
  """
  purchaseLanguage: spoken_lang!

  """
  
          Total tax amount for the entire order in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  purchaseTaxAmount: bigint!

  """
  
          Total amount of all the order in minor units. Includes tax and discounts.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  purchaseTotalAmount: bigint!
  resultingPurchaseId: bigint

  """List of statuses the order is currently on"""
  status(
    """distinct select on columns"""
    distinctOn: [CurrentPurchaseOrderStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentPurchaseOrderStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentPurchaseOrderStatusBoolExp
  ): [CurrentPurchaseOrderStatus!]
}

"""
Boolean expression to filter rows from the table "checkout.purchase_order". All fields are combined with a logical 'AND'.
"""
input PurchaseOrderBoolExp {
  _and: [PurchaseOrderBoolExp!]
  _not: PurchaseOrderBoolExp
  _or: [PurchaseOrderBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: StringComparisonExp
  merchantId: BigintComparisonExp
  merchantReference: StringComparisonExp
  purchaseCountry: CountryComparisonExp
  purchaseLanguage: SpokenLangComparisonExp
  purchaseTaxAmount: BigintComparisonExp
  purchaseTotalAmount: BigintComparisonExp
  resultingPurchaseId: BigintComparisonExp
  status: CurrentPurchaseOrderStatusBoolExp
}

"""Ordering options when selecting data from "marketplace.purchase"."""
input PurchaseOrderBy {
  billingAddress: CustomerAddressOrderBy
  billingAddressId: OrderBy
  captureItemDiscountsAggregate: DiscountAggregateOrderBy
  capturesAggregate: CaptureAggregateOrderBy
  createdAt: OrderBy
  customer: CustomerOrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  deliveryMethod: OrderBy
  expiration: PurchaseExpirationOrderBy
  id: OrderBy
  instalmentStatusAggregate: CurrentInstalmentStatusAggregateOrderBy
  instalmentsAggregate: InstalmentAggregateOrderBy
  invoice: InvoiceOrderBy
  itemsAggregate: PurchaseItemAggregateOrderBy
  merchant: MerchantOrderBy
  merchantId: OrderBy
  merchantReference: OrderBy
  paymentsAggregate: PurchasePaymentAggregateOrderBy
  returnsAggregate: ReturnAggregateOrderBy
  shippingAddress: CustomerAddressOrderBy
  statusAggregate: CurrentPurchaseStatusAggregateOrderBy
  surchargesAggregate: SurchargeAggregateOrderBy
  taxAmount: OrderBy
  totalAmount: OrderBy
}

"""
A purchase cancellation intent by a customer that is yet to be fully authenticated.
"""
input PurchaseOrderCancelInput {
  """
  This is the id of the order to cancel.
  
  Max length: 64.
  """
  purchaseOrderId: String!
}

"""The result of cancelling a purchase order."""
type PurchaseOrderCancelResult {
  """We return True for success and False for failure."""
  result: Boolean!
}

"""List of order items which are part of this checkout."""
input PurchaseOrderLineInput {
  """
  URL to an image that can be used later in communications between kronor
  and the customer.
  
  Max length: 10000.
  """
  imageUrl: String

  """
  URL to item in the merchant catalog, that will be used in communications between
  kronor and the customer.
  
  Max length: 10000.
  """
  itemUrl: String

  """
  The name of the purchased item
  
  Max length: 100.
  """
  name: String!

  """
  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.
  """
  pricePerItem: Int!

  """
  Number of items ordered by the customer. Needs to be a positive number.
  """
  quantity: Int!

  """
  Merchant's own internal item number or any other reference that may help the
  merchant in identifying this purchase.
  
  Max length: 64.
  """
  reference: String

  """
  Tax rate on the items ordered in this line.
  Needs to be a non-negative number.
  Example: `15%` discount should be represented as `1500`.
  """
  taxRate: Int!

  """
  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  Example 100 SEK should be 10000.
  """
  totalAmount: Int!

  """
  Discount applied on all the items in this line in minor units.
  This value should include any applicable tax.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.
  """
  totalDiscountAmount: Int

  """
  Total tax amount on all the items in this line in minor units.
  Example: 1500,25 SEk should be 150025.
  
  Example 100 SEK should be 10000.
  """
  totalTaxAmount: Int!
}

"""Ordering options when selecting data from "checkout.purchase_order"."""
input PurchaseOrderOrderBy {
  createdAt: OrderBy
  id: OrderBy
  merchantId: OrderBy
  merchantReference: OrderBy
  purchaseCountry: OrderBy
  purchaseLanguage: OrderBy
  purchaseTaxAmount: OrderBy
  purchaseTotalAmount: OrderBy
  resultingPurchaseId: OrderBy
  statusAggregate: CurrentPurchaseOrderStatusAggregateOrderBy
}

"""
select columns of table "checkout.purchase_order"
"""
enum PurchaseOrderSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  merchantId

  """column name"""
  merchantReference

  """column name"""
  purchaseCountry

  """column name"""
  purchaseLanguage

  """column name"""
  purchaseTaxAmount

  """column name"""
  purchaseTotalAmount

  """column name"""
  resultingPurchaseId
}

"""
A purchase intent by a customer that is yet to be fully authenticated, uses instalments in contrast to PurchaseOrderWithInvoiceInput, and a fee will be added to each instalment.
"""
input PurchaseOrderWithInstalmentsInput {
  """The billing address for the customer making the purchase."""
  billingAddress: AddressInput!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  Merchant's own internal order number or any other reference that may help the
  merchant in identifying this purchase.
  
  Max length: 64.
  """
  merchantReference: String

  """
  National identification number for the customer.
  This will be use to perform strong customer authentication, that is,
  making sure of the customer's identity.
  """
  nationalIdentificationNumber: String!

  """
  Country where the purchase is taking place.
  Example: `Sweden`, `Denmark`, `Norway`, `Iceland`
  """
  purchaseCountry: Country!

  """
  Language in which the purchase is being handled
  Only languages in two-letter `ISO-639-1` format are recognized.
  Example: `SV`, `DA`, `NO`, `IS`, `EN`.
  """
  purchaseLanguage: Language!

  """A list with all purchase items in this order."""
  purchaseLines: [PurchaseOrderLineInput!]!

  """
  Total tax amount of all the order in minor units.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.
  
  Must be within 1 of: totalAmount - totalAmount * 10000 / (10000 + taxRate).
  """
  purchaseTaxAmount: Int!

  """
  Total amount of all the order in minor units. Includes tax and discounts.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.
  
  Must fulfill equation: totalAmount = (quantity x pricePerItem) - totalDiscountAmount
  """
  purchaseTotalAmount: Int!

  """The address the customer wants to ship the purchased items to."""
  shippingAddress: AddressInput
}

"""The result of initiating a purchase order with instalments."""
type PurchaseOrderWithInstalmentsResult {
  """The resulting purchase order ID (same as the idempotency key)"""
  id: String!

  """
  Once a purchase order is received, we will start processing for
  fraud and final approval. You can use this token to query the current
  status.
  """
  waitToken: String!
}

"""A purchase intent by a customer that is yet to be fully authenticated."""
input PurchaseOrderWithInvoiceInput {
  """The billing address for the customer making the purchase."""
  billingAddress: AddressInput!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  Merchant's own internal order number or any other reference that may help the
  merchant in identifying this purchase.
  
  Max length: 64.
  """
  merchantReference: String

  """
  National identification number for the customer.
  This will be use to perform strong customer authentication, that is,
  making sure of the customer's identity.
  """
  nationalIdentificationNumber: String!

  """
  Country where the purchase is taking place.
  Example: `Sweden`, `Denmark`, `Norway`, `Iceland`
  """
  purchaseCountry: Country!

  """
  Language in which the purchase is being handled
  Only languages in two-letter `ISO-639-1` format are recognized.
  Example: `SV`, `DA`, `NO`, `IS`, `EN`.
  """
  purchaseLanguage: Language!

  """A list with all purchase items in this order."""
  purchaseLines: [PurchaseOrderLineInput!]!

  """
  Total tax amount of all the order in minor units.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.
  
  Must be within 1 of: totalAmount - totalAmount * 10000 / (10000 + taxRate).
  """
  purchaseTaxAmount: Int!

  """
  Total amount of all the order in minor units. Includes tax and discounts.
  Example: `1500,25` SEK should be `150025`.
  Example `100` SEK should be `10000`.
  
  Must fulfill equation: totalAmount = (quantity x pricePerItem) - totalDiscountAmount
  """
  purchaseTotalAmount: Int!

  """The address the customer wants to ship the purchased items to."""
  shippingAddress: AddressInput
}

"""The result of initiating a purchase order with invoice."""
type PurchaseOrderWithInvoiceResult {
  """The resulting purchase order ID (same as the idempotency key)"""
  id: String!

  """
  Once a purchase order is received, we will start processing for
  fraud and final approval. You can use this token to query the current
  status.
  """
  waitToken: String!
}

"""Record of payments the customer has made to us."""
type PurchasePayment {
  """Amount paid by the customer to us."""
  amountPaid: bigint!
  createdAt: timestamptz!
  currency: SupportedCurrencyEnum!
  id: bigint!
  merchantId: bigint!
  paymentMethod: PaymentMethodEnum!
}

"""
aggregated selection of "marketplace.payment"
"""
type PurchasePaymentAggregate {
  aggregate: PurchasePaymentAggregateFields
  nodes: [PurchasePayment!]!
}

"""
aggregate fields of "marketplace.payment"
"""
type PurchasePaymentAggregateFields {
  avg: PurchasePaymentAvgFields
  count(columns: [PurchasePaymentSelectColumn!], distinct: Boolean): Int!
  max: PurchasePaymentMaxFields
  min: PurchasePaymentMinFields
  stddev: PurchasePaymentStddevFields
  stddevPop: PurchasePaymentStddevPopFields
  stddevSamp: PurchasePaymentStddevSampFields
  sum: PurchasePaymentSumFields
  varPop: PurchasePaymentVarPopFields
  varSamp: PurchasePaymentVarSampFields
  variance: PurchasePaymentVarianceFields
}

"""
order by aggregate values of table "marketplace.payment"
"""
input PurchasePaymentAggregateOrderBy {
  avg: PurchasePaymentAvgOrderBy
  count: OrderBy
  max: PurchasePaymentMaxOrderBy
  min: PurchasePaymentMinOrderBy
  stddev: PurchasePaymentStddevOrderBy
  stddev_pop: PurchasePaymentStddevPopOrderBy
  stddev_samp: PurchasePaymentStddevSampOrderBy
  sum: PurchasePaymentSumOrderBy
  var_pop: PurchasePaymentVarPopOrderBy
  var_samp: PurchasePaymentVarSampOrderBy
  variance: PurchasePaymentVarianceOrderBy
}

"""aggregate avg on columns"""
type PurchasePaymentAvgFields {
  """Amount paid by the customer to us."""
  amountPaid: Float
  id: Float
  merchantId: Float
}

"""
order by avg() on columns of table "marketplace.payment"
"""
input PurchasePaymentAvgOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.payment". All fields are combined with a logical 'AND'.
"""
input PurchasePaymentBoolExp {
  _and: [PurchasePaymentBoolExp!]
  _not: PurchasePaymentBoolExp
  _or: [PurchasePaymentBoolExp!]
  amountPaid: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  currency: SupportedCurrencyEnumComparisonExp
  id: BigintComparisonExp
  merchantId: BigintComparisonExp
  paymentMethod: PaymentMethodEnumComparisonExp
}

"""aggregate max on columns"""
type PurchasePaymentMaxFields {
  """Amount paid by the customer to us."""
  amountPaid: bigint
  createdAt: timestamptz
  id: bigint
  merchantId: bigint
}

"""
order by max() on columns of table "marketplace.payment"
"""
input PurchasePaymentMaxOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  createdAt: OrderBy
  id: OrderBy
  merchantId: OrderBy
}

"""aggregate min on columns"""
type PurchasePaymentMinFields {
  """Amount paid by the customer to us."""
  amountPaid: bigint
  createdAt: timestamptz
  id: bigint
  merchantId: bigint
}

"""
order by min() on columns of table "marketplace.payment"
"""
input PurchasePaymentMinOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  createdAt: OrderBy
  id: OrderBy
  merchantId: OrderBy
}

"""Ordering options when selecting data from "marketplace.payment"."""
input PurchasePaymentOrderBy {
  amountPaid: OrderBy
  createdAt: OrderBy
  currency: OrderBy
  id: OrderBy
  merchantId: OrderBy
  paymentMethod: OrderBy
}

"""
select columns of table "marketplace.payment"
"""
enum PurchasePaymentSelectColumn {
  """column name"""
  amountPaid

  """column name"""
  createdAt

  """column name"""
  currency

  """column name"""
  id

  """column name"""
  merchantId

  """column name"""
  paymentMethod
}

"""aggregate stddev on columns"""
type PurchasePaymentStddevFields {
  """Amount paid by the customer to us."""
  amountPaid: Float
  id: Float
  merchantId: Float
}

"""
order by stddev() on columns of table "marketplace.payment"
"""
input PurchasePaymentStddevOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
}

"""aggregate stddev_pop on columns"""
type PurchasePaymentStddevPopFields {
  """Amount paid by the customer to us."""
  amountPaid: Float
  id: Float
  merchantId: Float
}

"""
order by stddev_pop() on columns of table "marketplace.payment"
"""
input PurchasePaymentStddevPopOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
}

"""aggregate stddev_samp on columns"""
type PurchasePaymentStddevSampFields {
  """Amount paid by the customer to us."""
  amountPaid: Float
  id: Float
  merchantId: Float
}

"""
order by stddev_samp() on columns of table "marketplace.payment"
"""
input PurchasePaymentStddevSampOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
}

"""aggregate sum on columns"""
type PurchasePaymentSumFields {
  """Amount paid by the customer to us."""
  amountPaid: bigint
  id: bigint
  merchantId: bigint
}

"""
order by sum() on columns of table "marketplace.payment"
"""
input PurchasePaymentSumOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
}

"""aggregate var_pop on columns"""
type PurchasePaymentVarPopFields {
  """Amount paid by the customer to us."""
  amountPaid: Float
  id: Float
  merchantId: Float
}

"""
order by var_pop() on columns of table "marketplace.payment"
"""
input PurchasePaymentVarPopOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
}

"""aggregate var_samp on columns"""
type PurchasePaymentVarSampFields {
  """Amount paid by the customer to us."""
  amountPaid: Float
  id: Float
  merchantId: Float
}

"""
order by var_samp() on columns of table "marketplace.payment"
"""
input PurchasePaymentVarSampOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
}

"""aggregate variance on columns"""
type PurchasePaymentVarianceFields {
  """Amount paid by the customer to us."""
  amountPaid: Float
  id: Float
  merchantId: Float
}

"""
order by variance() on columns of table "marketplace.payment"
"""
input PurchasePaymentVarianceOrderBy {
  """Amount paid by the customer to us."""
  amountPaid: OrderBy
  id: OrderBy
  merchantId: OrderBy
}

"""A complete return of a purchase."""
input PurchaseReturnAllInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """Id of the purchase"""
  purchaseId: bigint!

  """
  Reason for the purchase return.
  Max length: 10000.
  """
  reason: String

  """Any return fee charged."""
  returnFee: Int
}

"""The result of returning a purchase."""
type PurchaseReturnAllResult {
  """
  Once a purchase is returned, you can use this token to query the status of return.
  """
  returnId: bigint!
}

"""Purchase return."""
input PurchaseReturnInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """Id of the purchase"""
  purchaseId: bigint!

  """Any return fee charged."""
  returnFee: Int

  """List of items returned."""
  returnItems: [PurchaseReturnItemInput!]!

  """
  Reason for returning the items.
  Max length: 1000.
  """
  returnReason: String
}

"""Item return."""
input PurchaseReturnItemInput {
  """
  Price per item in this line in minor units. It should include tax, but not any discounts.
  Example: `1500,25` SEK should be `150025`.
  Example: `100` SEK should be `10000`.
  """
  pricePerItem: Int!

  """Number of items captured sharing the same reference."""
  quantity: Int!

  """
  Unique item identification reference.
  Max length: 64.
  """
  reference: String!

  """
  Tax rate on the items ordered in this line.
  Needs to be a non-negative number.
  Example: `15%` discount should be represented as `1500`.
  """
  taxRate: Int!

  """
  Total amount including tax on all the items in this line in minor units.
  Example: 1500,25 SEK should be 150025.
  Example: 100 SEK should be 10000.
  """
  totalAmount: Int!

  """
  Total tax amount on all the returned items of this type in minor units.
  Example: 1500,25 SEk should be 150025.
  
  Example 100 SEK should be 10000.
  """
  totalTaxAmount: Int!
}

"""The result of processing an item return."""
type PurchaseReturnResult {
  """Query the status of an item return."""
  returnId: bigint!
}

"""
select columns of table "marketplace.purchase"
"""
enum PurchaseSelectColumn {
  """column name"""
  billingAddressId

  """column name"""
  createdAt

  """column name"""
  customerId

  """column name"""
  deliveryAddressId

  """column name"""
  deliveryMethod

  """column name"""
  id

  """column name"""
  merchantId

  """column name"""
  merchantReference

  """column name"""
  taxAmount

  """column name"""
  totalAmount
}

enum PurchaseStatusEnum {
  """The order was cancelled by the merchant"""
  CANCELLED

  """The order has been fully captured by the merchant"""
  CAPTURE_DONE

  """The customer needs to setup recurring payments"""
  INSTALMENTS_AUTHORIZE

  """The customer needs to pay the first instalment"""
  INSTALMENT_PRE_PAYMENT

  """The order has been captured partially by the merchant"""
  PARTIALLY_CAPTURED

  """The order has been fully captured and returned."""
  RETURNED

  """The order has been processed as is waiting for capture"""
  WAITING_FOR_CAPTURE
}

"""
Boolean expression to compare columns of type "PurchaseStatusEnum". All fields are combined with logical 'AND'.
"""
input PurchaseStatusEnumComparisonExp {
  _eq: PurchaseStatusEnum
  _in: [PurchaseStatusEnum!]
  _isNull: Boolean
  _neq: PurchaseStatusEnum
  _nin: [PurchaseStatusEnum!]
}

"""aggregate stddev on columns"""
type PurchaseStddevFields {
  billingAddressId: Float
  customerId: Float
  deliveryAddressId: Float
  id: Float
  merchantId: Float
  taxAmount: Float

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: Float
}

"""
order by stddev() on columns of table "marketplace.purchase"
"""
input PurchaseStddevOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""aggregate stddev_pop on columns"""
type PurchaseStddevPopFields {
  billingAddressId: Float
  customerId: Float
  deliveryAddressId: Float
  id: Float
  merchantId: Float
  taxAmount: Float

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: Float
}

"""
order by stddev_pop() on columns of table "marketplace.purchase"
"""
input PurchaseStddevPopOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""aggregate stddev_samp on columns"""
type PurchaseStddevSampFields {
  billingAddressId: Float
  customerId: Float
  deliveryAddressId: Float
  id: Float
  merchantId: Float
  taxAmount: Float

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: Float
}

"""
order by stddev_samp() on columns of table "marketplace.purchase"
"""
input PurchaseStddevSampOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""aggregate sum on columns"""
type PurchaseSumFields {
  billingAddressId: bigint
  customerId: bigint
  deliveryAddressId: bigint
  id: bigint
  merchantId: bigint
  taxAmount: bigint

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: bigint
}

"""
order by sum() on columns of table "marketplace.purchase"
"""
input PurchaseSumOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""aggregate var_pop on columns"""
type PurchaseVarPopFields {
  billingAddressId: Float
  customerId: Float
  deliveryAddressId: Float
  id: Float
  merchantId: Float
  taxAmount: Float

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: Float
}

"""
order by var_pop() on columns of table "marketplace.purchase"
"""
input PurchaseVarPopOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""aggregate var_samp on columns"""
type PurchaseVarSampFields {
  billingAddressId: Float
  customerId: Float
  deliveryAddressId: Float
  id: Float
  merchantId: Float
  taxAmount: Float

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: Float
}

"""
order by var_samp() on columns of table "marketplace.purchase"
"""
input PurchaseVarSampOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""aggregate variance on columns"""
type PurchaseVarianceFields {
  billingAddressId: Float
  customerId: Float
  deliveryAddressId: Float
  id: Float
  merchantId: Float
  taxAmount: Float

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: Float
}

"""
order by variance() on columns of table "marketplace.purchase"
"""
input PurchaseVarianceOrderBy {
  billingAddressId: OrderBy
  customerId: OrderBy
  deliveryAddressId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  taxAmount: OrderBy

  """
  Total amount of the purchase which included the total amounts of all purchase items.
  """
  totalAmount: OrderBy
}

"""List of generated reports given a date range"""
type Reconciliation {
  createdAt: timestamptz!

  """
  
      End date till which the reports are generated.
      For daily reports the 'start_date' and 'end_date' are the same.
      
  """
  endDate: date!
  isAuto: Boolean!
  merchantId: bigint!

  """
  
        Start date from which the reports are generated.
        For daily reports the 'start_date' and 'end_date' are the same.
        
  """
  startDate: date!
}

"""
aggregated selection of "reconciliation.generated_report"
"""
type ReconciliationAggregate {
  aggregate: ReconciliationAggregateFields
  nodes: [Reconciliation!]!
}

"""
aggregate fields of "reconciliation.generated_report"
"""
type ReconciliationAggregateFields {
  avg: ReconciliationAvgFields
  count(columns: [ReconciliationSelectColumn!], distinct: Boolean): Int!
  max: ReconciliationMaxFields
  min: ReconciliationMinFields
  stddev: ReconciliationStddevFields
  stddevPop: ReconciliationStddevPopFields
  stddevSamp: ReconciliationStddevSampFields
  sum: ReconciliationSumFields
  varPop: ReconciliationVarPopFields
  varSamp: ReconciliationVarSampFields
  variance: ReconciliationVarianceFields
}

"""aggregate avg on columns"""
type ReconciliationAvgFields {
  merchantId: Float
}

"""
Boolean expression to filter rows from the table "reconciliation.generated_report". All fields are combined with a logical 'AND'.
"""
input ReconciliationBoolExp {
  _and: [ReconciliationBoolExp!]
  _not: ReconciliationBoolExp
  _or: [ReconciliationBoolExp!]
  createdAt: TimestamptzComparisonExp
  endDate: DateComparisonExp
  isAuto: BooleanComparisonExp
  merchantId: BigintComparisonExp
  startDate: DateComparisonExp
}

"""aggregate max on columns"""
type ReconciliationMaxFields {
  createdAt: timestamptz

  """
  
      End date till which the reports are generated.
      For daily reports the 'start_date' and 'end_date' are the same.
      
  """
  endDate: date
  merchantId: bigint

  """
  
        Start date from which the reports are generated.
        For daily reports the 'start_date' and 'end_date' are the same.
        
  """
  startDate: date
}

"""aggregate min on columns"""
type ReconciliationMinFields {
  createdAt: timestamptz

  """
  
      End date till which the reports are generated.
      For daily reports the 'start_date' and 'end_date' are the same.
      
  """
  endDate: date
  merchantId: bigint

  """
  
        Start date from which the reports are generated.
        For daily reports the 'start_date' and 'end_date' are the same.
        
  """
  startDate: date
}

"""
Ordering options when selecting data from "reconciliation.generated_report".
"""
input ReconciliationOrderBy {
  createdAt: OrderBy
  endDate: OrderBy
  isAuto: OrderBy
  merchantId: OrderBy
  startDate: OrderBy
}

"""URL for downloadable CSV reconciliation reports"""
type ReconciliationReportLink {
  createdAt: timestamptz!

  """
  
          End date till which the reports are generated.
          For daily reports the 'start_date' and 'end_date' are the same.
          
  """
  endDate: date!

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String

  """This is the key that we send to query for the links."""
  id: bigint!

  """
  The Amazon S3 presigned URL shared with merchant for them to download the report.
  """
  link: String
  merchantId: bigint!

  """
  
          Start date from which the reports are generated.
          For daily reports the 'start_date' and 'end_date' are the same.
          
  """
  startDate: date!

  """The status of creating the presigned URL."""
  status: ReportLinkStatusEnum!
}

"""
Boolean expression to filter rows from the table "runtime.reconciliation_link". All fields are combined with a logical 'AND'.
"""
input ReconciliationReportLinkBoolExp {
  _and: [ReconciliationReportLinkBoolExp!]
  _not: ReconciliationReportLinkBoolExp
  _or: [ReconciliationReportLinkBoolExp!]
  createdAt: TimestamptzComparisonExp
  endDate: DateComparisonExp
  errMessage: StringComparisonExp
  id: BigintComparisonExp
  link: StringComparisonExp
  merchantId: BigintComparisonExp
  startDate: DateComparisonExp
  status: ReportLinkStatusEnumComparisonExp
}

"""
Ordering options when selecting data from "runtime.reconciliation_link".
"""
input ReconciliationReportLinkOrderBy {
  createdAt: OrderBy
  endDate: OrderBy
  errMessage: OrderBy
  id: OrderBy
  link: OrderBy
  merchantId: OrderBy
  startDate: OrderBy
  status: OrderBy
}

"""
select columns of table "runtime.reconciliation_link"
"""
enum ReconciliationReportLinkSelectColumn {
  """column name"""
  createdAt

  """column name"""
  endDate

  """column name"""
  errMessage

  """column name"""
  id

  """column name"""
  link

  """column name"""
  merchantId

  """column name"""
  startDate

  """column name"""
  status
}

"""
select columns of table "reconciliation.generated_report"
"""
enum ReconciliationSelectColumn {
  """column name"""
  createdAt

  """column name"""
  endDate

  """column name"""
  isAuto

  """column name"""
  merchantId

  """column name"""
  startDate
}

"""aggregate stddev on columns"""
type ReconciliationStddevFields {
  merchantId: Float
}

"""aggregate stddev_pop on columns"""
type ReconciliationStddevPopFields {
  merchantId: Float
}

"""aggregate stddev_samp on columns"""
type ReconciliationStddevSampFields {
  merchantId: Float
}

"""aggregate sum on columns"""
type ReconciliationSumFields {
  merchantId: bigint
}

"""aggregate var_pop on columns"""
type ReconciliationVarPopFields {
  merchantId: Float
}

"""aggregate var_samp on columns"""
type ReconciliationVarSampFields {
  merchantId: Float
}

"""aggregate variance on columns"""
type ReconciliationVarianceFields {
  merchantId: Float
}

"""A refund requested"""
type Refund {
  createdAt: timestamptz!
  createdBy: String
  errorMessage: String
  generatedFrom: String
  merchantId: bigint!
  message: String!
  paymentId: bigint!

  """List of statuses the refund is currently on"""
  status(
    """distinct select on columns"""
    distinctOn: [CurrentRefundStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentRefundStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentRefundStatusBoolExp
  ): [CurrentRefundStatus!]

  """List of statuses the payment has been on"""
  statusHistory(
    """distinct select on columns"""
    distinctOn: [CurrentRefundStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CurrentRefundStatusOrderBy!]

    """filter the rows returned"""
    where: CurrentRefundStatusBoolExp
  ): [CurrentRefundStatus!]
  totalAmount: bigint!

  """The ID corresponding to the refund"""
  waitToken: uuid!
}

"""
aggregated selection of "payment_gateway.refund"
"""
type RefundAggregate {
  aggregate: RefundAggregateFields
  nodes: [Refund!]!
}

"""
aggregate fields of "payment_gateway.refund"
"""
type RefundAggregateFields {
  avg: RefundAvgFields
  count(columns: [RefundSelectColumn!], distinct: Boolean): Int!
  max: RefundMaxFields
  min: RefundMinFields
  stddev: RefundStddevFields
  stddevPop: RefundStddevPopFields
  stddevSamp: RefundStddevSampFields
  sum: RefundSumFields
  varPop: RefundVarPopFields
  varSamp: RefundVarSampFields
  variance: RefundVarianceFields
}

"""
order by aggregate values of table "payment_gateway.refund"
"""
input RefundAggregateOrderBy {
  avg: RefundAvgOrderBy
  count: OrderBy
  max: RefundMaxOrderBy
  min: RefundMinOrderBy
  stddev: RefundStddevOrderBy
  stddev_pop: RefundStddevPopOrderBy
  stddev_samp: RefundStddevSampOrderBy
  sum: RefundSumOrderBy
  var_pop: RefundVarPopOrderBy
  var_samp: RefundVarSampOrderBy
  variance: RefundVarianceOrderBy
}

"""aggregate avg on columns"""
type RefundAvgFields {
  merchantId: Float
  paymentId: Float
  totalAmount: Float
}

"""
order by avg() on columns of table "payment_gateway.refund"
"""
input RefundAvgOrderBy {
  merchantId: OrderBy
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "payment_gateway.refund". All fields are combined with a logical 'AND'.
"""
input RefundBoolExp {
  _and: [RefundBoolExp!]
  _not: RefundBoolExp
  _or: [RefundBoolExp!]
  createdAt: TimestamptzComparisonExp
  createdBy: StringComparisonExp
  errorMessage: StringComparisonExp
  generatedFrom: StringComparisonExp
  merchantId: BigintComparisonExp
  message: StringComparisonExp
  paymentId: BigintComparisonExp
  status: CurrentRefundStatusBoolExp
  statusHistory: CurrentRefundStatusBoolExp
  totalAmount: BigintComparisonExp
  waitToken: UuidComparisonExp
}

"""aggregate max on columns"""
type RefundMaxFields {
  createdAt: timestamptz
  createdBy: String
  errorMessage: String
  generatedFrom: String
  merchantId: bigint
  message: String
  paymentId: bigint
  totalAmount: bigint

  """The ID corresponding to the refund"""
  waitToken: uuid
}

"""
order by max() on columns of table "payment_gateway.refund"
"""
input RefundMaxOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  errorMessage: OrderBy
  generatedFrom: OrderBy
  merchantId: OrderBy
  message: OrderBy
  paymentId: OrderBy
  totalAmount: OrderBy

  """The ID corresponding to the refund"""
  waitToken: OrderBy
}

"""aggregate min on columns"""
type RefundMinFields {
  createdAt: timestamptz
  createdBy: String
  errorMessage: String
  generatedFrom: String
  merchantId: bigint
  message: String
  paymentId: bigint
  totalAmount: bigint

  """The ID corresponding to the refund"""
  waitToken: uuid
}

"""
order by min() on columns of table "payment_gateway.refund"
"""
input RefundMinOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  errorMessage: OrderBy
  generatedFrom: OrderBy
  merchantId: OrderBy
  message: OrderBy
  paymentId: OrderBy
  totalAmount: OrderBy

  """The ID corresponding to the refund"""
  waitToken: OrderBy
}

"""Ordering options when selecting data from "payment_gateway.refund"."""
input RefundOrderBy {
  createdAt: OrderBy
  createdBy: OrderBy
  errorMessage: OrderBy
  generatedFrom: OrderBy
  merchantId: OrderBy
  message: OrderBy
  paymentId: OrderBy
  statusAggregate: CurrentRefundStatusAggregateOrderBy
  statusHistoryAggregate: CurrentRefundStatusAggregateOrderBy
  totalAmount: OrderBy
  waitToken: OrderBy
}

"""Arguments for performing a refund of a paid payment."""
input RefundPaymentInput {
  """
  The amount to be refunded in minor units.
  So 100,56 kr would be 10056
  """
  amount: Int!

  """
  Who is creating the refund.
  
  Max length: 100.
  """
  createdBy: String

  """
  Optional, where is the refund being created, will default to "Portal" when creating a refund from the kronor portal.
  
  Max length: 100.
  """
  generatedFrom: String

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  A message to show to the customer for the refund.
  Only alphanumeric, Swedish characters, and the following are allowed:
  - ':'
  - ';'
  - '.'
  - ','
  - '?'
  - '!'
  - '('
  - ')'
  - ''
  - '"'
  - ' '
  
  Max length: 50.
  """
  message: String!

  """Generated id for the payment after a successful payment."""
  paymentId: bigint!
}

"""The result of performing a refund of a payment."""
type RefundPaymentResult {
  """
  Once a refund is initiated, you can use this waitToken to check the status of the refund.
  """
  waitToken: String!
}

"""
select columns of table "payment_gateway.refund"
"""
enum RefundSelectColumn {
  """column name"""
  createdAt

  """column name"""
  createdBy

  """column name"""
  errorMessage

  """column name"""
  generatedFrom

  """column name"""
  merchantId

  """column name"""
  message

  """column name"""
  paymentId

  """column name"""
  totalAmount

  """column name"""
  waitToken
}

enum RefundStatusEnum {
  ERROR
  INITIALIZING
  PAID
  WAITING_FOR_REFUND
}

"""
Boolean expression to compare columns of type "RefundStatusEnum". All fields are combined with logical 'AND'.
"""
input RefundStatusEnumComparisonExp {
  _eq: RefundStatusEnum
  _in: [RefundStatusEnum!]
  _isNull: Boolean
  _neq: RefundStatusEnum
  _nin: [RefundStatusEnum!]
}

"""aggregate stddev on columns"""
type RefundStddevFields {
  merchantId: Float
  paymentId: Float
  totalAmount: Float
}

"""
order by stddev() on columns of table "payment_gateway.refund"
"""
input RefundStddevOrderBy {
  merchantId: OrderBy
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""aggregate stddev_pop on columns"""
type RefundStddevPopFields {
  merchantId: Float
  paymentId: Float
  totalAmount: Float
}

"""
order by stddev_pop() on columns of table "payment_gateway.refund"
"""
input RefundStddevPopOrderBy {
  merchantId: OrderBy
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""aggregate stddev_samp on columns"""
type RefundStddevSampFields {
  merchantId: Float
  paymentId: Float
  totalAmount: Float
}

"""
order by stddev_samp() on columns of table "payment_gateway.refund"
"""
input RefundStddevSampOrderBy {
  merchantId: OrderBy
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""aggregate sum on columns"""
type RefundSumFields {
  merchantId: bigint
  paymentId: bigint
  totalAmount: bigint
}

"""
order by sum() on columns of table "payment_gateway.refund"
"""
input RefundSumOrderBy {
  merchantId: OrderBy
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""aggregate var_pop on columns"""
type RefundVarPopFields {
  merchantId: Float
  paymentId: Float
  totalAmount: Float
}

"""
order by var_pop() on columns of table "payment_gateway.refund"
"""
input RefundVarPopOrderBy {
  merchantId: OrderBy
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""aggregate var_samp on columns"""
type RefundVarSampFields {
  merchantId: Float
  paymentId: Float
  totalAmount: Float
}

"""
order by var_samp() on columns of table "payment_gateway.refund"
"""
input RefundVarSampOrderBy {
  merchantId: OrderBy
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""aggregate variance on columns"""
type RefundVarianceFields {
  merchantId: Float
  paymentId: Float
  totalAmount: Float
}

"""
order by variance() on columns of table "payment_gateway.refund"
"""
input RefundVarianceOrderBy {
  merchantId: OrderBy
  paymentId: OrderBy
  totalAmount: OrderBy
}

"""Remove an user from merchant's pool."""
input RemoveUserInput {
  """Email of the user that is making the request."""
  currentUser: String!

  """List of users that should be removed."""
  removeUsers: [String!]!
}

"""Result of the remotion"""
type RemoveUserResult {
  """Result of the operation."""
  success: Boolean!
}

enum ReportLinkStatusEnum {
  """Link creation is done."""
  DONE

  """Something went wrong."""
  ERROR

  """Link been generated."""
  INITIALIZED
}

"""
Boolean expression to compare columns of type "ReportLinkStatusEnum". All fields are combined with logical 'AND'.
"""
input ReportLinkStatusEnumComparisonExp {
  _eq: ReportLinkStatusEnum
  _in: [ReportLinkStatusEnum!]
  _isNull: Boolean
  _neq: ReportLinkStatusEnum
  _nin: [ReportLinkStatusEnum!]
}

"""Log of successful mutations done via the API"""
type RequestLog {
  createdAt: timestamptz!
  idempotencyKey: String!
  merchantId: bigint!
  namespace: String!
  requestParams(
    """JSON select path"""
    path: String
  ): jsonb!
  responseBody(
    """JSON select path"""
    path: String
  ): jsonb
}

"""
Boolean expression to filter rows from the table "runtime.idempotency". All fields are combined with a logical 'AND'.
"""
input RequestLogBoolExp {
  _and: [RequestLogBoolExp!]
  _not: RequestLogBoolExp
  _or: [RequestLogBoolExp!]
  createdAt: TimestamptzComparisonExp
  idempotencyKey: StringComparisonExp
  merchantId: BigintComparisonExp
  namespace: StringComparisonExp
  requestParams: JsonbComparisonExp
  responseBody: JsonbComparisonExp
}

"""Ordering options when selecting data from "runtime.idempotency"."""
input RequestLogOrderBy {
  createdAt: OrderBy
  idempotencyKey: OrderBy
  merchantId: OrderBy
  namespace: OrderBy
  requestParams: OrderBy
  responseBody: OrderBy
}

"""
select columns of table "runtime.idempotency"
"""
enum RequestLogSelectColumn {
  """column name"""
  createdAt

  """column name"""
  idempotencyKey

  """column name"""
  merchantId

  """column name"""
  namespace

  """column name"""
  requestParams

  """column name"""
  responseBody
}

"""Used to resend the invoice email"""
input ResendInvoiceEmailInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  Id of the invoice
  Max length: 64.
  """
  invoiceId: bigint!

  """
  Id of the purchase
  Max length: 64.
  """
  purchaseId: bigint!
}

"""The result of the email resend request."""
type ResendInvoiceEmailResult {
  """What happened with the email resent request."""
  result: Boolean!
}

"""A group of items in a purchase that were returned by the customer"""
type Return {
  createdAt: timestamptz!
  id: bigint!

  """An array relationship"""
  items(
    """distinct select on columns"""
    distinctOn: [ReturnItemSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReturnItemOrderBy!]

    """filter the rows returned"""
    where: ReturnItemBoolExp
  ): [ReturnItem!]!
  merchantId: bigint!
  purchaseId: bigint!

  """Any return fee imposed by the merchant on the customer."""
  returnFee: bigint!

  """Reason for returning the items as returned by the customer, if any"""
  returnReason: String

  """Total amount of the items in the return."""
  totalAmount: bigint!
}

"""
aggregated selection of "marketplace.purchase_return"
"""
type ReturnAggregate {
  aggregate: ReturnAggregateFields
  nodes: [Return!]!
}

"""
aggregate fields of "marketplace.purchase_return"
"""
type ReturnAggregateFields {
  avg: ReturnAvgFields
  count(columns: [ReturnSelectColumn!], distinct: Boolean): Int!
  max: ReturnMaxFields
  min: ReturnMinFields
  stddev: ReturnStddevFields
  stddevPop: ReturnStddevPopFields
  stddevSamp: ReturnStddevSampFields
  sum: ReturnSumFields
  varPop: ReturnVarPopFields
  varSamp: ReturnVarSampFields
  variance: ReturnVarianceFields
}

"""
order by aggregate values of table "marketplace.purchase_return"
"""
input ReturnAggregateOrderBy {
  avg: ReturnAvgOrderBy
  count: OrderBy
  max: ReturnMaxOrderBy
  min: ReturnMinOrderBy
  stddev: ReturnStddevOrderBy
  stddev_pop: ReturnStddevPopOrderBy
  stddev_samp: ReturnStddevSampOrderBy
  sum: ReturnSumOrderBy
  var_pop: ReturnVarPopOrderBy
  var_samp: ReturnVarSampOrderBy
  variance: ReturnVarianceOrderBy
}

"""aggregate avg on columns"""
type ReturnAvgFields {
  id: Float
  merchantId: Float
  purchaseId: Float

  """Any return fee imposed by the merchant on the customer."""
  returnFee: Float

  """Total amount of the items in the return."""
  totalAmount: Float
}

"""
order by avg() on columns of table "marketplace.purchase_return"
"""
input ReturnAvgOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.purchase_return". All fields are combined with a logical 'AND'.
"""
input ReturnBoolExp {
  _and: [ReturnBoolExp!]
  _not: ReturnBoolExp
  _or: [ReturnBoolExp!]
  createdAt: TimestamptzComparisonExp
  id: BigintComparisonExp
  items: ReturnItemBoolExp
  merchantId: BigintComparisonExp
  purchaseId: BigintComparisonExp
  returnFee: BigintComparisonExp
  returnReason: StringComparisonExp
  totalAmount: BigintComparisonExp
}

"""An item in a purchase returned by the customer"""
type ReturnItem {
  id: bigint!

  """An object relationship"""
  item: PurchaseItem!
  merchantId: bigint!

  """Individual price of each item as returned by the customer"""
  pricePerItem: bigint!
  purchaseId: bigint!
  purchaseReturnId: bigint!

  """Number of items returned by the customer."""
  quantity: Int!

  """
  Item identification either provided by the merchant as bar code or generated by us.
  """
  reference: citext!

  """Tax rate for the item returned by the customer"""
  taxRate: smallint!

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: bigint!

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: bigint!
}

"""
order by aggregate values of table "marketplace.purchase_return_item"
"""
input ReturnItemAggregateOrderBy {
  avg: ReturnItemAvgOrderBy
  count: OrderBy
  max: ReturnItemMaxOrderBy
  min: ReturnItemMinOrderBy
  stddev: ReturnItemStddevOrderBy
  stddev_pop: ReturnItemStddevPopOrderBy
  stddev_samp: ReturnItemStddevSampOrderBy
  sum: ReturnItemSumOrderBy
  var_pop: ReturnItemVarPopOrderBy
  var_samp: ReturnItemVarSampOrderBy
  variance: ReturnItemVarianceOrderBy
}

"""
order by avg() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemAvgOrderBy {
  id: OrderBy
  merchantId: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.purchase_return_item". All fields are combined with a logical 'AND'.
"""
input ReturnItemBoolExp {
  _and: [ReturnItemBoolExp!]
  _not: ReturnItemBoolExp
  _or: [ReturnItemBoolExp!]
  id: BigintComparisonExp
  item: PurchaseItemBoolExp
  merchantId: BigintComparisonExp
  pricePerItem: BigintComparisonExp
  purchaseId: BigintComparisonExp
  purchaseReturnId: BigintComparisonExp
  quantity: IntComparisonExp
  reference: CitextComparisonExp
  taxRate: SmallintComparisonExp
  totalAmount: BigintComparisonExp
  totalTaxAmount: BigintComparisonExp
}

"""
order by max() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemMaxOrderBy {
  id: OrderBy
  merchantId: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """
  Item identification either provided by the merchant as bar code or generated by us.
  """
  reference: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
order by min() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemMinOrderBy {
  id: OrderBy
  merchantId: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """
  Item identification either provided by the merchant as bar code or generated by us.
  """
  reference: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
Ordering options when selecting data from "marketplace.purchase_return_item".
"""
input ReturnItemOrderBy {
  id: OrderBy
  item: PurchaseItemOrderBy
  merchantId: OrderBy
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy
  quantity: OrderBy
  reference: OrderBy
  taxRate: OrderBy
  totalAmount: OrderBy
  totalTaxAmount: OrderBy
}

"""
select columns of table "marketplace.purchase_return_item"
"""
enum ReturnItemSelectColumn {
  """column name"""
  id

  """column name"""
  merchantId

  """column name"""
  pricePerItem

  """column name"""
  purchaseId

  """column name"""
  purchaseReturnId

  """column name"""
  quantity

  """column name"""
  reference

  """column name"""
  taxRate

  """column name"""
  totalAmount

  """column name"""
  totalTaxAmount
}

"""
order by stddev() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemStddevOrderBy {
  id: OrderBy
  merchantId: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
order by stddev_pop() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemStddevPopOrderBy {
  id: OrderBy
  merchantId: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
order by stddev_samp() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemStddevSampOrderBy {
  id: OrderBy
  merchantId: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
order by sum() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemSumOrderBy {
  id: OrderBy
  merchantId: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
order by var_pop() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemVarPopOrderBy {
  id: OrderBy
  merchantId: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
order by var_samp() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemVarSampOrderBy {
  id: OrderBy
  merchantId: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""
order by variance() on columns of table "marketplace.purchase_return_item"
"""
input ReturnItemVarianceOrderBy {
  id: OrderBy
  merchantId: OrderBy

  """Individual price of each item as returned by the customer"""
  pricePerItem: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy

  """Number of items returned by the customer."""
  quantity: OrderBy

  """Tax rate for the item returned by the customer"""
  taxRate: OrderBy

  """
  Total amount of the item as returned by the customer, quantity * price_per_item
  """
  totalAmount: OrderBy

  """
  
          Total tax amount on all the items of this type in minor units.
          Example: 1500,25 SEk should be 150025.
          Example 100 SEK should be 10000.
      
  """
  totalTaxAmount: OrderBy
}

"""aggregate max on columns"""
type ReturnMaxFields {
  createdAt: timestamptz
  id: bigint
  merchantId: bigint
  purchaseId: bigint

  """Any return fee imposed by the merchant on the customer."""
  returnFee: bigint

  """Reason for returning the items as returned by the customer, if any"""
  returnReason: String

  """Total amount of the items in the return."""
  totalAmount: bigint
}

"""
order by max() on columns of table "marketplace.purchase_return"
"""
input ReturnMaxOrderBy {
  createdAt: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Reason for returning the items as returned by the customer, if any"""
  returnReason: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""aggregate min on columns"""
type ReturnMinFields {
  createdAt: timestamptz
  id: bigint
  merchantId: bigint
  purchaseId: bigint

  """Any return fee imposed by the merchant on the customer."""
  returnFee: bigint

  """Reason for returning the items as returned by the customer, if any"""
  returnReason: String

  """Total amount of the items in the return."""
  totalAmount: bigint
}

"""
order by min() on columns of table "marketplace.purchase_return"
"""
input ReturnMinOrderBy {
  createdAt: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Reason for returning the items as returned by the customer, if any"""
  returnReason: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""
Ordering options when selecting data from "marketplace.purchase_return".
"""
input ReturnOrderBy {
  createdAt: OrderBy
  id: OrderBy
  itemsAggregate: ReturnItemAggregateOrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
  returnFee: OrderBy
  returnReason: OrderBy
  totalAmount: OrderBy
}

"""
select columns of table "marketplace.purchase_return"
"""
enum ReturnSelectColumn {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  merchantId

  """column name"""
  purchaseId

  """column name"""
  returnFee

  """column name"""
  returnReason

  """column name"""
  totalAmount
}

"""aggregate stddev on columns"""
type ReturnStddevFields {
  id: Float
  merchantId: Float
  purchaseId: Float

  """Any return fee imposed by the merchant on the customer."""
  returnFee: Float

  """Total amount of the items in the return."""
  totalAmount: Float
}

"""
order by stddev() on columns of table "marketplace.purchase_return"
"""
input ReturnStddevOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""aggregate stddev_pop on columns"""
type ReturnStddevPopFields {
  id: Float
  merchantId: Float
  purchaseId: Float

  """Any return fee imposed by the merchant on the customer."""
  returnFee: Float

  """Total amount of the items in the return."""
  totalAmount: Float
}

"""
order by stddev_pop() on columns of table "marketplace.purchase_return"
"""
input ReturnStddevPopOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""aggregate stddev_samp on columns"""
type ReturnStddevSampFields {
  id: Float
  merchantId: Float
  purchaseId: Float

  """Any return fee imposed by the merchant on the customer."""
  returnFee: Float

  """Total amount of the items in the return."""
  totalAmount: Float
}

"""
order by stddev_samp() on columns of table "marketplace.purchase_return"
"""
input ReturnStddevSampOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""aggregate sum on columns"""
type ReturnSumFields {
  id: bigint
  merchantId: bigint
  purchaseId: bigint

  """Any return fee imposed by the merchant on the customer."""
  returnFee: bigint

  """Total amount of the items in the return."""
  totalAmount: bigint
}

"""
order by sum() on columns of table "marketplace.purchase_return"
"""
input ReturnSumOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""aggregate var_pop on columns"""
type ReturnVarPopFields {
  id: Float
  merchantId: Float
  purchaseId: Float

  """Any return fee imposed by the merchant on the customer."""
  returnFee: Float

  """Total amount of the items in the return."""
  totalAmount: Float
}

"""
order by var_pop() on columns of table "marketplace.purchase_return"
"""
input ReturnVarPopOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""aggregate var_samp on columns"""
type ReturnVarSampFields {
  id: Float
  merchantId: Float
  purchaseId: Float

  """Any return fee imposed by the merchant on the customer."""
  returnFee: Float

  """Total amount of the items in the return."""
  totalAmount: Float
}

"""
order by var_samp() on columns of table "marketplace.purchase_return"
"""
input ReturnVarSampOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""aggregate variance on columns"""
type ReturnVarianceFields {
  id: Float
  merchantId: Float
  purchaseId: Float

  """Any return fee imposed by the merchant on the customer."""
  returnFee: Float

  """Total amount of the items in the return."""
  totalAmount: Float
}

"""
order by variance() on columns of table "marketplace.purchase_return"
"""
input ReturnVarianceOrderBy {
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Any return fee imposed by the merchant on the customer."""
  returnFee: OrderBy

  """Total amount of the items in the return."""
  totalAmount: OrderBy
}

"""
Once a notification is sent to this URL, the server must respond with
the string `[accepted]` within 10 seconds to acknowledge the webhook.

Otherwise, the notification will be retried at a later time and all
future notifications will be queued until they can get properly
acknowledged.
"""
input SetWebhookUrlInput {
  """
  URL to which the webhook notifications will be sent
  
  Max length: 1000.
  """
  webhookUrl: String!
}

"""The result of setting a webhook URL."""
type SetWebhookUrlResult {
  """The secret used to sign webhook requests with HMAC"""
  hmacSecret: String!

  """URL to which the webhook notifications will be sent"""
  webhookUrl: String!
}

"""List of generated reports given a date range"""
type Settlement {
  createdAt: timestamptz!

  """
  
      End date till which the reports are generated.
      For daily reports the 'start_date' and 'end_date' are the same.
      
  """
  endDate: date!
  isAuto: Boolean!
  merchantId: bigint!

  """
  
        Start date from which the reports are generated.
        For daily reports the 'start_date' and 'end_date' are the same.
        
  """
  startDate: date!
}

"""
aggregated selection of "settlement.generated_report"
"""
type SettlementAggregate {
  aggregate: SettlementAggregateFields
  nodes: [Settlement!]!
}

"""
aggregate fields of "settlement.generated_report"
"""
type SettlementAggregateFields {
  avg: SettlementAvgFields
  count(columns: [SettlementSelectColumn!], distinct: Boolean): Int!
  max: SettlementMaxFields
  min: SettlementMinFields
  stddev: SettlementStddevFields
  stddevPop: SettlementStddevPopFields
  stddevSamp: SettlementStddevSampFields
  sum: SettlementSumFields
  varPop: SettlementVarPopFields
  varSamp: SettlementVarSampFields
  variance: SettlementVarianceFields
}

"""aggregate avg on columns"""
type SettlementAvgFields {
  merchantId: Float
}

"""
Boolean expression to filter rows from the table "settlement.generated_report". All fields are combined with a logical 'AND'.
"""
input SettlementBoolExp {
  _and: [SettlementBoolExp!]
  _not: SettlementBoolExp
  _or: [SettlementBoolExp!]
  createdAt: TimestamptzComparisonExp
  endDate: DateComparisonExp
  isAuto: BooleanComparisonExp
  merchantId: BigintComparisonExp
  startDate: DateComparisonExp
}

"""aggregate max on columns"""
type SettlementMaxFields {
  createdAt: timestamptz

  """
  
      End date till which the reports are generated.
      For daily reports the 'start_date' and 'end_date' are the same.
      
  """
  endDate: date
  merchantId: bigint

  """
  
        Start date from which the reports are generated.
        For daily reports the 'start_date' and 'end_date' are the same.
        
  """
  startDate: date
}

"""aggregate min on columns"""
type SettlementMinFields {
  createdAt: timestamptz

  """
  
      End date till which the reports are generated.
      For daily reports the 'start_date' and 'end_date' are the same.
      
  """
  endDate: date
  merchantId: bigint

  """
  
        Start date from which the reports are generated.
        For daily reports the 'start_date' and 'end_date' are the same.
        
  """
  startDate: date
}

"""
Ordering options when selecting data from "settlement.generated_report".
"""
input SettlementOrderBy {
  createdAt: OrderBy
  endDate: OrderBy
  isAuto: OrderBy
  merchantId: OrderBy
  startDate: OrderBy
}

"""URL for downloadable CSV settlement reports"""
type SettlementReportLink {
  createdAt: timestamptz!

  """
  
          End date till which the reports are generated.
          For daily reports the 'start_date' and 'end_date' are the same.
          
  """
  endDate: date!

  """An error message that may be present in case we couldn't create a URL."""
  errMessage: String

  """This is the key that we send to query for the links."""
  id: bigint!

  """
  The Amazon S3 presigned URL shared with merchant for them to download the report.
  """
  link: String
  merchantId: bigint!

  """
  
          Start date from which the reports are generated.
          For daily reports the 'start_date' and 'end_date' are the same.
          
  """
  startDate: date!

  """The status of creating the presigned URL."""
  status: ReportLinkStatusEnum!
}

"""
Boolean expression to filter rows from the table "runtime.report_link". All fields are combined with a logical 'AND'.
"""
input SettlementReportLinkBoolExp {
  _and: [SettlementReportLinkBoolExp!]
  _not: SettlementReportLinkBoolExp
  _or: [SettlementReportLinkBoolExp!]
  createdAt: TimestamptzComparisonExp
  endDate: DateComparisonExp
  errMessage: StringComparisonExp
  id: BigintComparisonExp
  link: StringComparisonExp
  merchantId: BigintComparisonExp
  startDate: DateComparisonExp
  status: ReportLinkStatusEnumComparisonExp
}

"""Ordering options when selecting data from "runtime.report_link"."""
input SettlementReportLinkOrderBy {
  createdAt: OrderBy
  endDate: OrderBy
  errMessage: OrderBy
  id: OrderBy
  link: OrderBy
  merchantId: OrderBy
  startDate: OrderBy
  status: OrderBy
}

"""
select columns of table "runtime.report_link"
"""
enum SettlementReportLinkSelectColumn {
  """column name"""
  createdAt

  """column name"""
  endDate

  """column name"""
  errMessage

  """column name"""
  id

  """column name"""
  link

  """column name"""
  merchantId

  """column name"""
  startDate

  """column name"""
  status
}

"""
select columns of table "settlement.generated_report"
"""
enum SettlementSelectColumn {
  """column name"""
  createdAt

  """column name"""
  endDate

  """column name"""
  isAuto

  """column name"""
  merchantId

  """column name"""
  startDate
}

"""aggregate stddev on columns"""
type SettlementStddevFields {
  merchantId: Float
}

"""aggregate stddev_pop on columns"""
type SettlementStddevPopFields {
  merchantId: Float
}

"""aggregate stddev_samp on columns"""
type SettlementStddevSampFields {
  merchantId: Float
}

"""aggregate sum on columns"""
type SettlementSumFields {
  merchantId: bigint
}

"""aggregate var_pop on columns"""
type SettlementVarPopFields {
  merchantId: Float
}

"""aggregate var_samp on columns"""
type SettlementVarSampFields {
  merchantId: Float
}

"""aggregate variance on columns"""
type SettlementVarianceFields {
  merchantId: Float
}

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input SmallintComparisonExp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _isNull: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"""
Boolean expression to compare columns of type "spoken_lang". All fields are combined with logical 'AND'.
"""
input SpokenLangComparisonExp {
  _eq: spoken_lang
  _gt: spoken_lang
  _gte: spoken_lang
  _in: [spoken_lang!]
  _isNull: Boolean
  _lt: spoken_lang
  _lte: spoken_lang
  _neq: spoken_lang
  _nin: [spoken_lang!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input StringComparisonExp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _isNull: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""Webhooks that have been successfully received by merchants"""
type SuccessfulWebhookNotification {
  event: String

  """Same id as in the job_queue.pending_webhook_notification table"""
  id: bigint!
  merchantId: bigint!
  payload(
    """JSON select path"""
    path: String
  ): jsonb!
  paymentId: bigint
  paymentRequestId: uuid
  purchaseId: bigint

  """When the job_queue.pending_webhook_notification was created_at"""
  queuedAt: timestamptz!
  refundId: uuid
  sentAt: timestamptz!
  webhookUrl: String!
}

"""
aggregated selection of "runtime.successful_webhook_notification"
"""
type SuccessfulWebhookNotificationAggregate {
  aggregate: SuccessfulWebhookNotificationAggregateFields
  nodes: [SuccessfulWebhookNotification!]!
}

"""
aggregate fields of "runtime.successful_webhook_notification"
"""
type SuccessfulWebhookNotificationAggregateFields {
  avg: SuccessfulWebhookNotificationAvgFields
  count(columns: [SuccessfulWebhookNotificationSelectColumn!], distinct: Boolean): Int!
  max: SuccessfulWebhookNotificationMaxFields
  min: SuccessfulWebhookNotificationMinFields
  stddev: SuccessfulWebhookNotificationStddevFields
  stddevPop: SuccessfulWebhookNotificationStddevPopFields
  stddevSamp: SuccessfulWebhookNotificationStddevSampFields
  sum: SuccessfulWebhookNotificationSumFields
  varPop: SuccessfulWebhookNotificationVarPopFields
  varSamp: SuccessfulWebhookNotificationVarSampFields
  variance: SuccessfulWebhookNotificationVarianceFields
}

"""aggregate avg on columns"""
type SuccessfulWebhookNotificationAvgFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: Float
  merchantId: Float
  paymentId: Float
  purchaseId: Float
}

"""
Boolean expression to filter rows from the table "runtime.successful_webhook_notification". All fields are combined with a logical 'AND'.
"""
input SuccessfulWebhookNotificationBoolExp {
  _and: [SuccessfulWebhookNotificationBoolExp!]
  _not: SuccessfulWebhookNotificationBoolExp
  _or: [SuccessfulWebhookNotificationBoolExp!]
  event: StringComparisonExp
  id: BigintComparisonExp
  merchantId: BigintComparisonExp
  payload: JsonbComparisonExp
  paymentId: BigintComparisonExp
  paymentRequestId: UuidComparisonExp
  purchaseId: BigintComparisonExp
  queuedAt: TimestamptzComparisonExp
  refundId: UuidComparisonExp
  sentAt: TimestamptzComparisonExp
  webhookUrl: StringComparisonExp
}

"""aggregate max on columns"""
type SuccessfulWebhookNotificationMaxFields {
  event: String

  """Same id as in the job_queue.pending_webhook_notification table"""
  id: bigint
  merchantId: bigint
  paymentId: bigint
  paymentRequestId: uuid
  purchaseId: bigint

  """When the job_queue.pending_webhook_notification was created_at"""
  queuedAt: timestamptz
  refundId: uuid
  sentAt: timestamptz
  webhookUrl: String
}

"""aggregate min on columns"""
type SuccessfulWebhookNotificationMinFields {
  event: String

  """Same id as in the job_queue.pending_webhook_notification table"""
  id: bigint
  merchantId: bigint
  paymentId: bigint
  paymentRequestId: uuid
  purchaseId: bigint

  """When the job_queue.pending_webhook_notification was created_at"""
  queuedAt: timestamptz
  refundId: uuid
  sentAt: timestamptz
  webhookUrl: String
}

"""
Ordering options when selecting data from "runtime.successful_webhook_notification".
"""
input SuccessfulWebhookNotificationOrderBy {
  event: OrderBy
  id: OrderBy
  merchantId: OrderBy
  payload: OrderBy
  paymentId: OrderBy
  paymentRequestId: OrderBy
  purchaseId: OrderBy
  queuedAt: OrderBy
  refundId: OrderBy
  sentAt: OrderBy
  webhookUrl: OrderBy
}

"""
select columns of table "runtime.successful_webhook_notification"
"""
enum SuccessfulWebhookNotificationSelectColumn {
  """column name"""
  event

  """column name"""
  id

  """column name"""
  merchantId

  """column name"""
  payload

  """column name"""
  paymentId

  """column name"""
  paymentRequestId

  """column name"""
  purchaseId

  """column name"""
  queuedAt

  """column name"""
  refundId

  """column name"""
  sentAt

  """column name"""
  webhookUrl
}

"""aggregate stddev on columns"""
type SuccessfulWebhookNotificationStddevFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: Float
  merchantId: Float
  paymentId: Float
  purchaseId: Float
}

"""aggregate stddev_pop on columns"""
type SuccessfulWebhookNotificationStddevPopFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: Float
  merchantId: Float
  paymentId: Float
  purchaseId: Float
}

"""aggregate stddev_samp on columns"""
type SuccessfulWebhookNotificationStddevSampFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: Float
  merchantId: Float
  paymentId: Float
  purchaseId: Float
}

"""aggregate sum on columns"""
type SuccessfulWebhookNotificationSumFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: bigint
  merchantId: bigint
  paymentId: bigint
  purchaseId: bigint
}

"""aggregate var_pop on columns"""
type SuccessfulWebhookNotificationVarPopFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: Float
  merchantId: Float
  paymentId: Float
  purchaseId: Float
}

"""aggregate var_samp on columns"""
type SuccessfulWebhookNotificationVarSampFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: Float
  merchantId: Float
  paymentId: Float
  purchaseId: Float
}

"""aggregate variance on columns"""
type SuccessfulWebhookNotificationVarianceFields {
  """Same id as in the job_queue.pending_webhook_notification table"""
  id: Float
  merchantId: Float
  paymentId: Float
  purchaseId: Float
}

"""Arguments for creating a new PayPal payment"""
input SupplyPayPalPaymentMethodIdInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  The payment id of a PayPal payment, this is obtained when a
  payment request is made. As opposed to a payment_reference which
  is the same across multiple payment attempts, this is unique
  only for each specific payment.
  
  Max length: 64.
  """
  paymentId: String!

  """
  This is obtained from Braintree when you use their client SDK to
  create a payment.
  
  Max length: 64.
  """
  paymentMethodId: String!
}

"""
The result of supplying a PayPal paymentMethodId to a PayPal
payment.
"""
type SupplyPayPalPaymentMethodIdResult {
  """
  Once a payment is initialized, we will start the PayPal payment
  workflow. You can use this id to query the current status of the
  payment.
  """
  paymentId: String!
}

enum SupportedCurrencyEnum {
  """Danish Krone, currency of Denmark"""
  DKK

  """Euro, Currency for the states in Eurozone"""
  EUR

  """Norwegian Krone, currency of Norway"""
  NOK

  """Swedish Krona, currency of Sweden"""
  SEK
}

"""
Boolean expression to compare columns of type "SupportedCurrencyEnum". All fields are combined with logical 'AND'.
"""
input SupportedCurrencyEnumComparisonExp {
  _eq: SupportedCurrencyEnum
  _in: [SupportedCurrencyEnum!]
  _isNull: Boolean
  _neq: SupportedCurrencyEnum
  _nin: [SupportedCurrencyEnum!]
}

"""Additional fee on a purchase after it was captured"""
type Surcharge {
  """Amount of surcharge."""
  amount: bigint!
  createdAt: timestamptz!
  customerId: bigint!
  id: bigint!
  merchantId: bigint!
  purchaseId: bigint

  """Id of the purchase return in case the surcharge refers to a return."""
  purchaseReturnId: bigint

  """
  
      Type of surcharge charged which is one of return_fee, reminder_fee, interest.
      
  """
  surchargeType: SurchargeTypeEnum!
}

"""
order by aggregate values of table "marketplace.surcharge"
"""
input SurchargeAggregateOrderBy {
  avg: SurchargeAvgOrderBy
  count: OrderBy
  max: SurchargeMaxOrderBy
  min: SurchargeMinOrderBy
  stddev: SurchargeStddevOrderBy
  stddev_pop: SurchargeStddevPopOrderBy
  stddev_samp: SurchargeStddevSampOrderBy
  sum: SurchargeSumOrderBy
  var_pop: SurchargeVarPopOrderBy
  var_samp: SurchargeVarSampOrderBy
  variance: SurchargeVarianceOrderBy
}

"""
order by avg() on columns of table "marketplace.surcharge"
"""
input SurchargeAvgOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  customerId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Id of the purchase return in case the surcharge refers to a return."""
  purchaseReturnId: OrderBy
}

"""
Boolean expression to filter rows from the table "marketplace.surcharge". All fields are combined with a logical 'AND'.
"""
input SurchargeBoolExp {
  _and: [SurchargeBoolExp!]
  _not: SurchargeBoolExp
  _or: [SurchargeBoolExp!]
  amount: BigintComparisonExp
  createdAt: TimestamptzComparisonExp
  customerId: BigintComparisonExp
  id: BigintComparisonExp
  merchantId: BigintComparisonExp
  purchaseId: BigintComparisonExp
  purchaseReturnId: BigintComparisonExp
  surchargeType: SurchargeTypeEnumComparisonExp
}

"""
order by max() on columns of table "marketplace.surcharge"
"""
input SurchargeMaxOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  createdAt: OrderBy
  customerId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Id of the purchase return in case the surcharge refers to a return."""
  purchaseReturnId: OrderBy
}

"""
order by min() on columns of table "marketplace.surcharge"
"""
input SurchargeMinOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  createdAt: OrderBy
  customerId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Id of the purchase return in case the surcharge refers to a return."""
  purchaseReturnId: OrderBy
}

"""Ordering options when selecting data from "marketplace.surcharge"."""
input SurchargeOrderBy {
  amount: OrderBy
  createdAt: OrderBy
  customerId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy
  purchaseReturnId: OrderBy
  surchargeType: OrderBy
}

"""
select columns of table "marketplace.surcharge"
"""
enum SurchargeSelectColumn {
  """column name"""
  amount

  """column name"""
  createdAt

  """column name"""
  customerId

  """column name"""
  id

  """column name"""
  merchantId

  """column name"""
  purchaseId

  """column name"""
  purchaseReturnId

  """column name"""
  surchargeType
}

"""
order by stddev() on columns of table "marketplace.surcharge"
"""
input SurchargeStddevOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  customerId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Id of the purchase return in case the surcharge refers to a return."""
  purchaseReturnId: OrderBy
}

"""
order by stddev_pop() on columns of table "marketplace.surcharge"
"""
input SurchargeStddevPopOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  customerId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Id of the purchase return in case the surcharge refers to a return."""
  purchaseReturnId: OrderBy
}

"""
order by stddev_samp() on columns of table "marketplace.surcharge"
"""
input SurchargeStddevSampOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  customerId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Id of the purchase return in case the surcharge refers to a return."""
  purchaseReturnId: OrderBy
}

"""
order by sum() on columns of table "marketplace.surcharge"
"""
input SurchargeSumOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  customerId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Id of the purchase return in case the surcharge refers to a return."""
  purchaseReturnId: OrderBy
}

enum SurchargeTypeEnum {
  """Interest added as per contract."""
  INTEREST

  """Fee for missed payments."""
  REMINDER_FEE

  """Fee for returning items."""
  RETURN_FEE

  """Our fee for providing the service."""
  SERVICE_FEE
}

"""
Boolean expression to compare columns of type "SurchargeTypeEnum". All fields are combined with logical 'AND'.
"""
input SurchargeTypeEnumComparisonExp {
  _eq: SurchargeTypeEnum
  _in: [SurchargeTypeEnum!]
  _isNull: Boolean
  _neq: SurchargeTypeEnum
  _nin: [SurchargeTypeEnum!]
}

"""
order by var_pop() on columns of table "marketplace.surcharge"
"""
input SurchargeVarPopOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  customerId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Id of the purchase return in case the surcharge refers to a return."""
  purchaseReturnId: OrderBy
}

"""
order by var_samp() on columns of table "marketplace.surcharge"
"""
input SurchargeVarSampOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  customerId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Id of the purchase return in case the surcharge refers to a return."""
  purchaseReturnId: OrderBy
}

"""
order by variance() on columns of table "marketplace.surcharge"
"""
input SurchargeVarianceOrderBy {
  """Amount of surcharge."""
  amount: OrderBy
  customerId: OrderBy
  id: OrderBy
  merchantId: OrderBy
  purchaseId: OrderBy

  """Id of the purchase return in case the surcharge refers to a return."""
  purchaseReturnId: OrderBy
}

"""
Describes the schema for the swish payment transaction details to be used by hasura
"""
type SwishDetails {
  """A reference sent from the bank once the payment has been made"""
  bankPaymentReference: String

  """The swish number of the customer"""
  customerSwishNumber: packed_phone_number

  """Date when the payment is created in SWISH"""
  dateCreated: timestamptz

  """Date when SWISH received the payment"""
  datePaid: timestamptz

  """Error code from swish"""
  errorCode: String

  """Error message from swish"""
  errorMessage: String
}

"""
order by aggregate values of table "runtime.transaction_swish_details"
"""
input SwishDetailsAggregateOrderBy {
  count: OrderBy
  max: SwishDetailsMaxOrderBy
  min: SwishDetailsMinOrderBy
}

"""
Boolean expression to filter rows from the table "runtime.transaction_swish_details". All fields are combined with a logical 'AND'.
"""
input SwishDetailsBoolExp {
  _and: [SwishDetailsBoolExp!]
  _not: SwishDetailsBoolExp
  _or: [SwishDetailsBoolExp!]
  bankPaymentReference: StringComparisonExp
  customerSwishNumber: PackedPhoneNumberComparisonExp
  dateCreated: TimestamptzComparisonExp
  datePaid: TimestamptzComparisonExp
  errorCode: StringComparisonExp
  errorMessage: StringComparisonExp
}

"""
order by max() on columns of table "runtime.transaction_swish_details"
"""
input SwishDetailsMaxOrderBy {
  """A reference sent from the bank once the payment has been made"""
  bankPaymentReference: OrderBy

  """Date when the payment is created in SWISH"""
  dateCreated: OrderBy

  """Date when SWISH received the payment"""
  datePaid: OrderBy

  """Error code from swish"""
  errorCode: OrderBy

  """Error message from swish"""
  errorMessage: OrderBy
}

"""
order by min() on columns of table "runtime.transaction_swish_details"
"""
input SwishDetailsMinOrderBy {
  """A reference sent from the bank once the payment has been made"""
  bankPaymentReference: OrderBy

  """Date when the payment is created in SWISH"""
  dateCreated: OrderBy

  """Date when SWISH received the payment"""
  datePaid: OrderBy

  """Error code from swish"""
  errorCode: OrderBy

  """Error message from swish"""
  errorMessage: OrderBy
}

"""
Ordering options when selecting data from "runtime.transaction_swish_details".
"""
input SwishDetailsOrderBy {
  bankPaymentReference: OrderBy
  customerSwishNumber: OrderBy
  dateCreated: OrderBy
  datePaid: OrderBy
  errorCode: OrderBy
  errorMessage: OrderBy
}

"""
select columns of table "runtime.transaction_swish_details"
"""
enum SwishDetailsSelectColumn {
  """column name"""
  bankPaymentReference

  """column name"""
  customerSwishNumber

  """column name"""
  dateCreated

  """column name"""
  datePaid

  """column name"""
  errorCode

  """column name"""
  errorMessage
}

"""Arguments for cancelling a swish payment"""
input SwishPaymentCancelInput {
  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  The payment id to cancel, this is obtained when a payment
  request is made. As opposed to a payment_reference which is
  the same across multiple payment attempts, this is unique only
  for each specific payment.
  
  Max length: 64.
  """
  paymentId: String!

  """
  The payment reference to cancel, this is obtained before we decide
  to make a payment, i.e. when we create a payment session.
  """
  paymentReference: String!
}

"""The result of cancelling a swish payment request."""
type SwishPaymentCancelResult {
  """
  The returned token can be used to query whether the payment has
  been cancelled or not.
  """
  waitToken: String!
}

"""Arguments for creating a new swish payment"""
input SwishPaymentInput {
  """
  The amount the customer pays in minor units.
  So 100,56 kr would be 10056.
  Amount should be between 1 and 999,99,99
  """
  amount: Int!

  """The Swish number of the customer, required for the 'ecom' flow"""
  customerSwishNumber: String

  """
  Payment flow, either 'ecom' or 'mcom'
  
  Max length: 64.
  """
  flow: String!

  """
  Idempotency key is required to prevent double processing a request.
  It is recommended to use a deterministic unique value, such as the combination of
  the order id and the customer id. Avoid using time-based values.
  Only alphanumeric character and the following are allowed:
  - "-"
  - "_"
  - "."
  - ","
  - "["
  - "]"
  - "+"
  
  Max length: 64.
  """
  idempotencyKey: String!

  """
  Merchant's own internal reference that may help the
  merchant in identifying this payment. These have to
  be globally unique but they should be reused for retrying
  a payment.
  
  Max length: 64.
  """
  merchantReference: String!

  """
  A message to show to the customer on their swish payment screen.
  It could be an order id or a reference.
  
  Max length: 50.
  """
  message: String!

  """
  Our system's own internal reference that can be used uniquely
  in identifying this payment.
  """
  paymentReference: String!

  """The url to return to after the payment is done."""
  returnUrl: String!
}

"""The result of initiating a swish payment."""
type SwishPaymentResult {
  """
  Once a payment is initialized, we will start the swish payment
  workflow. You can use this token to query the current status
  of the payment.
  """
  waitToken: String!
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input TimestamptzComparisonExp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _isNull: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""Toggle if a payment method should be available to use"""
input TogglePaymentMethodAvailabilityInput {
  """
  Payment method in the country where it should be enabled/disabled.
  Example: `Sweden`, `Denmark`, `Norway`, `Iceland`, `Finland`
  """
  country: Country!

  """The payment method to enable/disable"""
  paymentMethod: PaymentRequestMethod!

  """Whether or not the payment method should be enabled"""
  shouldBeEnabled: Boolean!
}

"""The result of a togglePaymentMethodAvailability mutation."""
type TogglePaymentMethodAvailabilityResult {
  """Whether or not the payment method is enabled after the mutation"""
  enabled: Boolean!
}

"""
In tenant.tokens we have roles of type text[], but hasura does not likes arrays, so we turn it into a json array here
"""
type Tokens {
  blocked: Boolean
  expirationDate: timestamptz
  merchantId: bigint
  roles(
    """JSON select path"""
    path: String
  ): jsonb
  tokenId: uuid
  tokenName: String
}

"""
Boolean expression to filter rows from the table "tenant.tokens_view". All fields are combined with a logical 'AND'.
"""
input TokensBoolExp {
  _and: [TokensBoolExp!]
  _not: TokensBoolExp
  _or: [TokensBoolExp!]
  blocked: BooleanComparisonExp
  expirationDate: TimestamptzComparisonExp
  merchantId: BigintComparisonExp
  roles: JsonbComparisonExp
  tokenId: UuidComparisonExp
  tokenName: StringComparisonExp
}

"""Ordering options when selecting data from "tenant.tokens_view"."""
input TokensOrderBy {
  blocked: OrderBy
  expirationDate: OrderBy
  merchantId: OrderBy
  roles: OrderBy
  tokenId: OrderBy
  tokenName: OrderBy
}

"""
select columns of table "tenant.tokens_view"
"""
enum TokensSelectColumn {
  """column name"""
  blocked

  """column name"""
  expirationDate

  """column name"""
  merchantId

  """column name"""
  roles

  """column name"""
  tokenId

  """column name"""
  tokenName
}

"""Unblock customer"""
input UnblockCustomerInput {
  """Email of the customer"""
  customerEmail: String

  """SSN of the customer"""
  customerSsn: String
}

"""Unblocked customers"""
type UnblockCustomerResult {
  """IDs of customers that are no longer blocked"""
  affectedCustomerIds: [Int!]!
}

"""Aggregate metrics per merchant per day"""
type UsageMeterDaily {
  currency: currency!
  date: date!
  merchantId: bigint!
  metric: MerchantMetricEnum!
  occurrences: Int!

  """The sum value in minor units"""
  sumValue: bigint!
}

"""
Boolean expression to filter rows from the table "tenant.merchant_daily_metric". All fields are combined with a logical 'AND'.
"""
input UsageMeterDailyBoolExp {
  _and: [UsageMeterDailyBoolExp!]
  _not: UsageMeterDailyBoolExp
  _or: [UsageMeterDailyBoolExp!]
  currency: CurrencyComparisonExp
  date: DateComparisonExp
  merchantId: BigintComparisonExp
  metric: MerchantMetricEnumComparisonExp
  occurrences: IntComparisonExp
  sumValue: BigintComparisonExp
}

"""
Ordering options when selecting data from "tenant.merchant_daily_metric".
"""
input UsageMeterDailyOrderBy {
  currency: OrderBy
  date: OrderBy
  merchantId: OrderBy
  metric: OrderBy
  occurrences: OrderBy
  sumValue: OrderBy
}

"""
select columns of table "tenant.merchant_daily_metric"
"""
enum UsageMeterDailySelectColumn {
  """column name"""
  currency

  """column name"""
  date

  """column name"""
  merchantId

  """column name"""
  metric

  """column name"""
  occurrences

  """column name"""
  sumValue
}

"""Monthly aggregates of metrics, including the current month"""
type UsageMeterMonthly {
  currency: currency
  firstDayOfMonthPeriod: date
  merchantId: bigint
  metric: citext
  month: smallint
  occurrences: Int

  """The sum value in minor units"""
  sumValue: bigint
  year: smallint
}

"""
Boolean expression to filter rows from the table "tenant.merchant_monthly_metric". All fields are combined with a logical 'AND'.
"""
input UsageMeterMonthlyBoolExp {
  _and: [UsageMeterMonthlyBoolExp!]
  _not: UsageMeterMonthlyBoolExp
  _or: [UsageMeterMonthlyBoolExp!]
  currency: CurrencyComparisonExp
  firstDayOfMonthPeriod: DateComparisonExp
  merchantId: BigintComparisonExp
  metric: CitextComparisonExp
  month: SmallintComparisonExp
  occurrences: IntComparisonExp
  sumValue: BigintComparisonExp
  year: SmallintComparisonExp
}

"""
Ordering options when selecting data from "tenant.merchant_monthly_metric".
"""
input UsageMeterMonthlyOrderBy {
  currency: OrderBy
  firstDayOfMonthPeriod: OrderBy
  merchantId: OrderBy
  metric: OrderBy
  month: OrderBy
  occurrences: OrderBy
  sumValue: OrderBy
  year: OrderBy
}

"""
select columns of table "tenant.merchant_monthly_metric"
"""
enum UsageMeterMonthlySelectColumn {
  """column name"""
  currency

  """column name"""
  firstDayOfMonthPeriod

  """column name"""
  merchantId

  """column name"""
  metric

  """column name"""
  month

  """column name"""
  occurrences

  """column name"""
  sumValue

  """column name"""
  year
}

"""
Holds the emails that are allowed to login as the given merchant through google signin.
"""
type UserFromGoogle {
  email: citext!
  imageUrl: String
  merchantId: bigint!
  role: UserRoleEnum!
}

"""
Boolean expression to filter rows from the table "merchant_portal.user_google". All fields are combined with a logical 'AND'.
"""
input UserFromGoogleBoolExp {
  _and: [UserFromGoogleBoolExp!]
  _not: UserFromGoogleBoolExp
  _or: [UserFromGoogleBoolExp!]
  email: CitextComparisonExp
  imageUrl: StringComparisonExp
  merchantId: BigintComparisonExp
  role: UserRoleEnumComparisonExp
}

"""
Ordering options when selecting data from "merchant_portal.user_google".
"""
input UserFromGoogleOrderBy {
  email: OrderBy
  imageUrl: OrderBy
  merchantId: OrderBy
  role: OrderBy
}

"""
select columns of table "merchant_portal.user_google"
"""
enum UserFromGoogleSelectColumn {
  """column name"""
  email

  """column name"""
  imageUrl

  """column name"""
  merchantId

  """column name"""
  role
}

enum UserRoleEnum {
  """Admin users with full access to all features"""
  ADMIN

  """Users with read-only acess to all features"""
  STAFF

  """Admin users with full access to all features"""
  SUPERADMIN
}

"""
Boolean expression to compare columns of type "UserRoleEnum". All fields are combined with logical 'AND'.
"""
input UserRoleEnumComparisonExp {
  _eq: UserRoleEnum
  _in: [UserRoleEnum!]
  _isNull: Boolean
  _neq: UserRoleEnum
  _nin: [UserRoleEnum!]
}

"""Join table for tenant.merchant and merchant_portal.user_email"""
type UserWithPassword {
  email: citext!
  merchantId: bigint!
  role: UserRoleEnum!
}

"""
Boolean expression to filter rows from the table "merchant_portal.merchant_user_email". All fields are combined with a logical 'AND'.
"""
input UserWithPasswordBoolExp {
  _and: [UserWithPasswordBoolExp!]
  _not: UserWithPasswordBoolExp
  _or: [UserWithPasswordBoolExp!]
  email: CitextComparisonExp
  merchantId: BigintComparisonExp
  role: UserRoleEnumComparisonExp
}

"""
Ordering options when selecting data from "merchant_portal.merchant_user_email".
"""
input UserWithPasswordOrderBy {
  email: OrderBy
  merchantId: OrderBy
  role: OrderBy
}

"""
select columns of table "merchant_portal.merchant_user_email"
"""
enum UserWithPasswordSelectColumn {
  """column name"""
  email

  """column name"""
  merchantId

  """column name"""
  role
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input UuidComparisonExp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _isNull: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

"""Describe the schema for Vipps details."""
type VippsDetails {
  cardCountry: String
  cardExpiryDate: date
  cardNumber: String
  cardType: String
  threeDSecureStatus: Boolean
}

"""
order by aggregate values of table "runtime.transaction_vipps_details"
"""
input VippsDetailsAggregateOrderBy {
  count: OrderBy
  max: VippsDetailsMaxOrderBy
  min: VippsDetailsMinOrderBy
}

"""
Boolean expression to filter rows from the table "runtime.transaction_vipps_details". All fields are combined with a logical 'AND'.
"""
input VippsDetailsBoolExp {
  _and: [VippsDetailsBoolExp!]
  _not: VippsDetailsBoolExp
  _or: [VippsDetailsBoolExp!]
  cardCountry: StringComparisonExp
  cardExpiryDate: DateComparisonExp
  cardNumber: StringComparisonExp
  cardType: StringComparisonExp
  threeDSecureStatus: BooleanComparisonExp
}

"""
order by max() on columns of table "runtime.transaction_vipps_details"
"""
input VippsDetailsMaxOrderBy {
  cardCountry: OrderBy
  cardExpiryDate: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
}

"""
order by min() on columns of table "runtime.transaction_vipps_details"
"""
input VippsDetailsMinOrderBy {
  cardCountry: OrderBy
  cardExpiryDate: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
}

"""
Ordering options when selecting data from "runtime.transaction_vipps_details".
"""
input VippsDetailsOrderBy {
  cardCountry: OrderBy
  cardExpiryDate: OrderBy
  cardNumber: OrderBy
  cardType: OrderBy
  threeDSecureStatus: OrderBy
}

"""
select columns of table "runtime.transaction_vipps_details"
"""
enum VippsDetailsSelectColumn {
  """column name"""
  cardCountry

  """column name"""
  cardExpiryDate

  """column name"""
  cardNumber

  """column name"""
  cardType

  """column name"""
  threeDSecureStatus
}

"""Settings for merchant webhook notifications"""
type WebhookURLs {
  faulty: Boolean!
  merchantId: bigint!
  webhookUrl: String!
}

"""
Boolean expression to filter rows from the table "tenant.webhook_settings". All fields are combined with a logical 'AND'.
"""
input WebhookURLsBoolExp {
  _and: [WebhookURLsBoolExp!]
  _not: WebhookURLsBoolExp
  _or: [WebhookURLsBoolExp!]
  faulty: BooleanComparisonExp
  merchantId: BigintComparisonExp
  webhookUrl: StringComparisonExp
}

"""Ordering options when selecting data from "tenant.webhook_settings"."""
input WebhookURLsOrderBy {
  faulty: OrderBy
  merchantId: OrderBy
  webhookUrl: OrderBy
}

"""
select columns of table "tenant.webhook_settings"
"""
enum WebhookURLsSelectColumn {
  """column name"""
  faulty

  """column name"""
  merchantId

  """column name"""
  webhookUrl
}

scalar bigint

scalar citext

scalar country

scalar currency

scalar date

scalar geography

scalar geometry

scalar inet

scalar interval

scalar invoice_transaction_type

scalar jsonb

"""mutation root"""
type mutation_root {
  """Add new users."""
  addNewUser(add: AddUserInput!): AddNewUserResult!

  """Adjust the due date of an invoice."""
  adjustInvoiceDueDate(adjustment: InvoiceDueDateAdjustInput!): InvoiceDueDateAdjustResult!

  """Authorize payment for future instalments"""
  authorizeInstalments(instalment: AuthorizeInstalmentsInput!): AuthorizeInstalmentsResult!

  """Block a customer from making new purchases"""
  blockCustomer(block: BlockCustomerInput!): [BlockCustomerResult!]!

  """Block a customer from making new purchases by customer id"""
  blockCustomerById(block: BlockCustomerByIdInput!): BlockCustomerResult!

  """
  Blocks the specified token, after a successful operation, the given token will no longer work.
  """
  blockToken(token: BlockTokenInput!): BlockTokenResult!

  """Cancel payment request."""
  cancelPayment(cancel: PaymentCancelInput!): PaymentCancelResult!

  """Cancel payment request made using newSwishPayment."""
  cancelSwishPayment(pay: SwishPaymentCancelInput!): SwishPaymentCancelResult!

  """
  Fully capture a payment and consider it paid, refund the user any remaining pre-authorized amount.
  """
  capturePaymentAll(capture: PaymentCaptureAllInput!): PaymentCaptureResult!

  """Delete a webhook URL"""
  deleteWebhookUrl(deleteWebhookUrl: DeleteWebhookUrlInput!): DeleteWebhookUrlResult!

  """Edit a purchase that hasn't been captured yet."""
  editPurchase(edit: PurchaseEditInput!): PurchaseEditResult!

  """Edit the purchase billing or shipping address."""
  editPurchaseAddress(edit: PurchaseEditAddressInput!): PurchaseEditAddressResult!

  """Edit the role of users."""
  editUserRole(edit: EditUserInput!): EditUserResult!

  """Generates a new CSV file containing payment requests."""
  generatePaymentRequestsCSV(generate: GeneratePaymentRequestCSVInput!): GeneratePaymentRequestCSVResult!

  """Generates a new CSV file containing payments."""
  generatePaymentsCSV(generate: GeneratePaymentCSVInput!): GeneratePaymentCSVResult!

  """Generates a new CSV file containing purchases."""
  generatePurchasesCSV(generate: GeneratePurchaseCSVInput!): GeneratePurchaseCSVResult!

  """Generates a new CSV file containing payments reconciliation."""
  generateReconciliationCSV(generate: GenerateReconciliationCSVInput!): GenerateReconciliationCSVResult!

  """Generate settlement and transaction report."""
  generateReport(report: GenerateReportInput!): GenerateReportResult!

  """Create a new payment request to receive money via Finshark"""
  newDirectDebitPayment(pay: DirectDebitPaymentInput!): DirectDebitPaymentResult!

  """Add a note to an invoice."""
  newInvoiceNote(note: InvoiceNoteInput!): InvoiceNoteResult!

  """Add discount for a captured item in an invoice."""
  newItemDiscount(discount: ItemDiscountInput!): ItemDiscountResult!

  """Create a new payment request to receive money via PayPal"""
  newPayPalPayment(pay: PayPalPaymentInput!): PayPalPaymentResult!

  """Capture a payment."""
  newPaymentCapture(capture: PaymentCaptureInput!): PaymentCaptureResult!

  """
  Create a new payment session to start a new stand alone payment. The token from the session can be used in subsequent calls for the payment flow.
  """
  newPaymentSession(payment: PaymentSessionInput!): PaymentSessionResult!

  """Capture a partial or complete purchase."""
  newPurchaseCapture(capture: PurchaseCaptureInput!): PurchaseCaptureResult!

  """Capture a complete purchase."""
  newPurchaseCaptureAll(capture: PurchaseCaptureAllInput!): PurchaseCaptureAllResult!

  """Capture multiple complete purchases."""
  newPurchaseCaptureAllBatch(capture: PurchaseCaptureAllBatchInput!): PurchaseCaptureAllBatchResult!

  """Capture multiple purchases with a date range."""
  newPurchaseCaptureAllRange(capture: PurchaseCaptureAllRangeInput!): PurchaseCaptureAllRangeResult!

  """Capture items in a purchase with their reference."""
  newPurchaseCaptureWithItemReferences(capture: PurchaseCaptureWithItemReferencesInput!): PurchaseCaptureWithItemReferencesResult!

  """
  create a purchase intent that will be paid by the customer in instalments.
  """
  newPurchaseOrderWithInstalments(purchase: PurchaseOrderWithInstalmentsInput!): PurchaseOrderWithInstalmentsResult!

  """create a purchase intent."""
  newPurchaseOrderWithInvoice(purchase: PurchaseOrderWithInvoiceInput!): PurchaseOrderWithInvoiceResult!

  """Return items."""
  newPurchaseReturn(return: PurchaseReturnInput!): PurchaseReturnResult!

  """Return a complete purchase."""
  newPurchaseReturnAll(return: PurchaseReturnAllInput!): PurchaseReturnAllResult!

  """Create a new payment request to receive money via swish"""
  newSwishPayment(pay: SwishPaymentInput!): SwishPaymentResult!

  """Pay the next instalment"""
  payInstalment(instalment: PayInstalmentInput!): PayInstalmentResult!

  """Cancel a purchase that might already have partial captures."""
  purchaseCancel(cancel: PurchaseCancelInput!): PurchaseCancelResult!

  """Cancel a purchase order."""
  purchaseOrderCancel(cancel: PurchaseOrderCancelInput!): PurchaseOrderCancelResult!

  """Refund a payment"""
  refundPayment(refund: RefundPaymentInput!): RefundPaymentResult!

  """Remove users."""
  removeUser(remove: RemoveUserInput!): RemoveUserResult!

  """Sends the invoice email to the customer."""
  resendInvoiceEmail(generate: ResendInvoiceEmailInput!): ResendInvoiceEmailResult!

  """Set the url that will receive webhook notifications"""
  setWebhookUrl(setWebhookUrl: SetWebhookUrlInput!): SetWebhookUrlResult!

  """Supply PaymentMethodId (nonce) to progress PayPal paymeent"""
  supplyPayPalPaymentMethodId(pay: SupplyPayPalPaymentMethodIdInput!): SupplyPayPalPaymentMethodIdResult!

  """Turn payment methods on or off"""
  togglePaymentMethodAvailability(payload: TogglePaymentMethodAvailabilityInput!): TogglePaymentMethodAvailabilityResult!

  """Remove a customer from the blocked list"""
  unblockCustomer(unblock: UnblockCustomerInput!): UnblockCustomerResult!
}

scalar packed_phone_number

type query_root {
  """
  Get the list of Strong Customer Authentication processes and their status
  """
  bankIdAuth(
    """distinct select on columns"""
    distinctOn: [BankIdAuthSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BankIdAuthOrderBy!]

    """filter the rows returned"""
    where: BankIdAuthBoolExp
  ): [BankIdAuth!]!

  """Get the list of CustomerBan directives"""
  customerBans(
    """distinct select on columns"""
    distinctOn: [CustomerBanSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerBanOrderBy!]

    """filter the rows returned"""
    where: CustomerBanBoolExp
  ): [CustomerBan!]!

  """Get additional data associated with payments"""
  customerPaymentData(
    """distinct select on columns"""
    distinctOn: [CustomerPaymentDataSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerPaymentDataOrderBy!]

    """filter the rows returned"""
    where: CustomerPaymentDataBoolExp
  ): [CustomerPaymentData!]!

  """Get the list of customers"""
  customers(
    """distinct select on columns"""
    distinctOn: [CustomerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerOrderBy!]

    """filter the rows returned"""
    where: CustomerBoolExp
  ): [Customer!]!

  """Run aggregation functions on the list of customers"""
  customersAggregate(
    """distinct select on columns"""
    distinctOn: [CustomerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerOrderBy!]

    """filter the rows returned"""
    where: CustomerBoolExp
  ): CustomerAggregate!

  """
  fetch data from the table: "dna.device"
  """
  device(
    """distinct select on columns"""
    distinctOn: [DeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DeviceOrderBy!]

    """filter the rows returned"""
    where: DeviceBoolExp
  ): [Device!]!

  """An array relationship"""
  instalments(
    """distinct select on columns"""
    distinctOn: [InstalmentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InstalmentOrderBy!]

    """filter the rows returned"""
    where: InstalmentBoolExp
  ): [Instalment!]!

  """Get the list of notes added by merchant admins on invoices"""
  invoiceNotes(
    """distinct select on columns"""
    distinctOn: [InvoiceNoteSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceNoteOrderBy!]

    """filter the rows returned"""
    where: InvoiceNoteBoolExp
  ): [InvoiceNote!]!

  """Run aggregation functions on the list of invoice notes"""
  invoiceNotesAggregate(
    """distinct select on columns"""
    distinctOn: [InvoiceNoteSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceNoteOrderBy!]

    """filter the rows returned"""
    where: InvoiceNoteBoolExp
  ): InvoiceNoteAggregate!

  """Get all the informatioin needed to render invoices"""
  invoicePage(
    """distinct select on columns"""
    distinctOn: [InvoicePageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoicePageOrderBy!]

    """filter the rows returned"""
    where: InvoicePageBoolExp
  ): [InvoicePage!]!

  """The list of invoices"""
  invoices(
    """distinct select on columns"""
    distinctOn: [InvoiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceOrderBy!]

    """filter the rows returned"""
    where: InvoiceBoolExp
  ): [Invoice!]!

  """Run aggregation functions on the list of invoices"""
  invoicesAggregate(
    """distinct select on columns"""
    distinctOn: [InvoiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceOrderBy!]

    """filter the rows returned"""
    where: InvoiceBoolExp
  ): InvoiceAggregate!

  """Select a single merchant by Id"""
  merchant(id: bigint!): Merchant

  """Get a single URL containing a downloadable CSV file with payment data"""
  paymentCSV(
    """This is the key that we send to query for the links."""
    id: bigint!
    merchantId: bigint!
  ): PaymentCSV

  """
  fetch data from the table: "payment_gateway.payment_capture" using primary key columns
  """
  paymentCapture(
    id: bigint!

    """Merchant who has created the capture."""
    merchantId: bigint!
  ): PaymentCapture

  """
  fetch aggregated fields from the table: "payment_gateway.payment_capture"
  """
  paymentCaptureAggregate(
    """distinct select on columns"""
    distinctOn: [PaymentCaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCaptureOrderBy!]

    """filter the rows returned"""
    where: PaymentCaptureBoolExp
  ): PaymentCaptureAggregate!

  """
  fetch data from the table: "payment_gateway.payment_capture"
  """
  paymentCaptures(
    """distinct select on columns"""
    distinctOn: [PaymentCaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCaptureOrderBy!]

    """filter the rows returned"""
    where: PaymentCaptureBoolExp
  ): [PaymentCapture!]!

  """
  fetch data from the table: "tenant.payment_method_available"
  """
  paymentMethodStatus(
    """distinct select on columns"""
    distinctOn: [PaymentMethodStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentMethodStatusOrderBy!]

    """filter the rows returned"""
    where: PaymentMethodStatusBoolExp
  ): [PaymentMethodStatus!]!

  """
  Get a single URL containing a downloadable CSV file with payment request data
  """
  paymentRequestCSV(
    """This is the key that we send to query for the links."""
    id: bigint!
    merchantId: bigint!
  ): PaymentRequestCSV

  """Get the list of payment requests"""
  paymentRequests(
    """distinct select on columns"""
    distinctOn: [PaymentRequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentRequestOrderBy!]

    """filter the rows returned"""
    where: PaymentRequestBoolExp
  ): [PaymentRequest!]!

  """
  Get the list of URLs containing downloadable CSV files with payment request data
  """
  paymentRequestsCSV(
    """distinct select on columns"""
    distinctOn: [PaymentRequestCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentRequestCSVOrderBy!]

    """filter the rows returned"""
    where: PaymentRequestCSVBoolExp
  ): [PaymentRequestCSV!]!

  """Get the list of payments"""
  payments(
    """distinct select on columns"""
    distinctOn: [PaymentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentOrderBy!]

    """filter the rows returned"""
    where: PaymentBoolExp
  ): [Payment!]!

  """Run aggregations on the list of payments"""
  paymentsAggregate(
    """distinct select on columns"""
    distinctOn: [PaymentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentOrderBy!]

    """filter the rows returned"""
    where: PaymentBoolExp
  ): PaymentAggregate!

  """
  Get the list of URLs containing downloadable CSV files with payment data
  """
  paymentsCSV(
    """distinct select on columns"""
    distinctOn: [PaymentCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCSVOrderBy!]

    """filter the rows returned"""
    where: PaymentCSVBoolExp
  ): [PaymentCSV!]!

  """
  Run aggregation functions on list of URLs containing downloadable CSV files with payment data
  """
  paymentsCSVAggregate(
    """distinct select on columns"""
    distinctOn: [PaymentCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCSVOrderBy!]

    """filter the rows returned"""
    where: PaymentCSVBoolExp
  ): PaymentCSVAggregate!

  """Get a single purchase by Id"""
  purchase(id: bigint!, merchantId: bigint!): Purchase

  """Get the list of Bulk Capture requests with their status"""
  purchaseBulkCaptureStatuses(
    """distinct select on columns"""
    distinctOn: [PurchaseBulkCaptureStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseBulkCaptureStatusOrderBy!]

    """filter the rows returned"""
    where: PurchaseBulkCaptureStatusBoolExp
  ): [PurchaseBulkCaptureStatus!]!

  """Get the list of unauthenticated orders"""
  purchaseOrders(
    """distinct select on columns"""
    distinctOn: [PurchaseOrderSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseOrderOrderBy!]

    """filter the rows returned"""
    where: PurchaseOrderBoolExp
  ): [PurchaseOrder!]!

  """An array relationship"""
  purchases(
    """distinct select on columns"""
    distinctOn: [PurchaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseOrderBy!]

    """filter the rows returned"""
    where: PurchaseBoolExp
  ): [Purchase!]!

  """An aggregate relationship"""
  purchasesAggregate(
    """distinct select on columns"""
    distinctOn: [PurchaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseOrderBy!]

    """filter the rows returned"""
    where: PurchaseBoolExp
  ): PurchaseAggregate!

  """
  Get the list of URLs containing downloadable CSV files with purchase data
  """
  purchasesCSV(
    """distinct select on columns"""
    distinctOn: [PurchaseCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseCSVOrderBy!]

    """filter the rows returned"""
    where: PurchaseCSVBoolExp
  ): [PurchaseCSV!]!

  """Get the list of downloadable CSV reconciliation reports"""
  reconciliationReports(
    """distinct select on columns"""
    distinctOn: [ReconciliationReportLinkSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReconciliationReportLinkOrderBy!]

    """filter the rows returned"""
    where: ReconciliationReportLinkBoolExp
  ): [ReconciliationReportLink!]!

  """Get the list of generated reconciliation reports"""
  reconciliations(
    """distinct select on columns"""
    distinctOn: [ReconciliationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReconciliationOrderBy!]

    """filter the rows returned"""
    where: ReconciliationBoolExp
  ): [Reconciliation!]!

  """
  Run aggregation function on the list of generated reconciliation reports
  """
  reconciliationsAggregate(
    """distinct select on columns"""
    distinctOn: [ReconciliationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReconciliationOrderBy!]

    """filter the rows returned"""
    where: ReconciliationBoolExp
  ): ReconciliationAggregate!

  """An array relationship"""
  refunds(
    """distinct select on columns"""
    distinctOn: [RefundSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RefundOrderBy!]

    """filter the rows returned"""
    where: RefundBoolExp
  ): [Refund!]!

  """An aggregate relationship"""
  refundsAggregate(
    """distinct select on columns"""
    distinctOn: [RefundSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RefundOrderBy!]

    """filter the rows returned"""
    where: RefundBoolExp
  ): RefundAggregate!

  """Get the list of successful mutations done via the API"""
  requestsLog(
    """distinct select on columns"""
    distinctOn: [RequestLogSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RequestLogOrderBy!]

    """filter the rows returned"""
    where: RequestLogBoolExp
  ): [RequestLog!]!

  """Get the list of downloadable CSV settlement reports"""
  settlementReports(
    """distinct select on columns"""
    distinctOn: [SettlementReportLinkSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SettlementReportLinkOrderBy!]

    """filter the rows returned"""
    where: SettlementReportLinkBoolExp
  ): [SettlementReportLink!]!

  """Get the list of generated settlement reports"""
  settlements(
    """distinct select on columns"""
    distinctOn: [SettlementSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SettlementOrderBy!]

    """filter the rows returned"""
    where: SettlementBoolExp
  ): [Settlement!]!

  """Run aggregation function on the list of generated settlement reports"""
  settlementsAggregate(
    """distinct select on columns"""
    distinctOn: [SettlementSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SettlementOrderBy!]

    """filter the rows returned"""
    where: SettlementBoolExp
  ): SettlementAggregate!

  """Get the list of successful webhook notifications"""
  successfulWebhookNotifications(
    """distinct select on columns"""
    distinctOn: [SuccessfulWebhookNotificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SuccessfulWebhookNotificationOrderBy!]

    """filter the rows returned"""
    where: SuccessfulWebhookNotificationBoolExp
  ): [SuccessfulWebhookNotification!]!

  """
  Run aggregation functions on the list of successful webhook notifications
  """
  successfulWebhookNotificationsAggregate(
    """distinct select on columns"""
    distinctOn: [SuccessfulWebhookNotificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SuccessfulWebhookNotificationOrderBy!]

    """filter the rows returned"""
    where: SuccessfulWebhookNotificationBoolExp
  ): SuccessfulWebhookNotificationAggregate!

  """Get the list of active tokens"""
  tokens(
    """distinct select on columns"""
    distinctOn: [TokensSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [TokensOrderBy!]

    """filter the rows returned"""
    where: TokensBoolExp
  ): [Tokens!]!

  """
  fetch data from the table: "tenant.merchant_daily_metric"
  """
  usageMetersDaily(
    """distinct select on columns"""
    distinctOn: [UsageMeterDailySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UsageMeterDailyOrderBy!]

    """filter the rows returned"""
    where: UsageMeterDailyBoolExp
  ): [UsageMeterDaily!]!

  """
  fetch data from the table: "tenant.merchant_monthly_metric"
  """
  usageMetersMonthly(
    """distinct select on columns"""
    distinctOn: [UsageMeterMonthlySelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UsageMeterMonthlyOrderBy!]

    """filter the rows returned"""
    where: UsageMeterMonthlyBoolExp
  ): [UsageMeterMonthly!]!

  """
  fetch data from the table: "merchant_portal.merchant_user_email" using primary key columns
  """
  userWithPassword(email: citext!, merchantId: bigint!): UserWithPassword

  """Get the list of users who authenticate using their Google account"""
  usersFromGoogle(
    """distinct select on columns"""
    distinctOn: [UserFromGoogleSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserFromGoogleOrderBy!]

    """filter the rows returned"""
    where: UserFromGoogleBoolExp
  ): [UserFromGoogle!]!

  """
  fetch data from the table: "merchant_portal.merchant_user_email"
  """
  usersWithPassword(
    """distinct select on columns"""
    distinctOn: [UserWithPasswordSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserWithPasswordOrderBy!]

    """filter the rows returned"""
    where: UserWithPasswordBoolExp
  ): [UserWithPassword!]!
  version: String!

  """
  fetch data from the table: "tenant.webhook_settings" using primary key columns
  """
  webhookURL(merchantId: bigint!, webhookUrl: String!): WebhookURLs

  """
  fetch data from the table: "tenant.webhook_settings"
  """
  webhookURLs(
    """distinct select on columns"""
    distinctOn: [WebhookURLsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [WebhookURLsOrderBy!]

    """filter the rows returned"""
    where: WebhookURLsBoolExp
  ): [WebhookURLs!]!
}

scalar smallint

scalar spoken_lang

input st_d_within_geography_input {
  distance: Float!
  from: geography!
  use_spheroid: Boolean = true
}

input st_d_within_input {
  distance: Float!
  from: geometry!
}

type subscription_root {
  """
  Get the list of Strong Customer Authentication processes and their status
  """
  bankIdAuth(
    """distinct select on columns"""
    distinctOn: [BankIdAuthSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [BankIdAuthOrderBy!]

    """filter the rows returned"""
    where: BankIdAuthBoolExp
  ): [BankIdAuth!]!

  """Get the list of CustomerBan directives"""
  customerBans(
    """distinct select on columns"""
    distinctOn: [CustomerBanSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerBanOrderBy!]

    """filter the rows returned"""
    where: CustomerBanBoolExp
  ): [CustomerBan!]!

  """Get additional data associated with payments"""
  customerPaymentData(
    """distinct select on columns"""
    distinctOn: [CustomerPaymentDataSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerPaymentDataOrderBy!]

    """filter the rows returned"""
    where: CustomerPaymentDataBoolExp
  ): [CustomerPaymentData!]!

  """Get the list of customers"""
  customers(
    """distinct select on columns"""
    distinctOn: [CustomerSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [CustomerOrderBy!]

    """filter the rows returned"""
    where: CustomerBoolExp
  ): [Customer!]!

  """
  fetch data from the table: "dna.device"
  """
  device(
    """distinct select on columns"""
    distinctOn: [DeviceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [DeviceOrderBy!]

    """filter the rows returned"""
    where: DeviceBoolExp
  ): [Device!]!

  """An array relationship"""
  instalments(
    """distinct select on columns"""
    distinctOn: [InstalmentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InstalmentOrderBy!]

    """filter the rows returned"""
    where: InstalmentBoolExp
  ): [Instalment!]!

  """Get the list of notes added by merchant admins on invoices"""
  invoiceNotes(
    """distinct select on columns"""
    distinctOn: [InvoiceNoteSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceNoteOrderBy!]

    """filter the rows returned"""
    where: InvoiceNoteBoolExp
  ): [InvoiceNote!]!

  """Get all the informatioin needed to render invoices"""
  invoicePage(
    """distinct select on columns"""
    distinctOn: [InvoicePageSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoicePageOrderBy!]

    """filter the rows returned"""
    where: InvoicePageBoolExp
  ): [InvoicePage!]!

  """The list of invoices"""
  invoices(
    """distinct select on columns"""
    distinctOn: [InvoiceSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [InvoiceOrderBy!]

    """filter the rows returned"""
    where: InvoiceBoolExp
  ): [Invoice!]!

  """Get a single URL containing a downloadable CSV file with payment data"""
  paymentCSV(
    """This is the key that we send to query for the links."""
    id: bigint!
    merchantId: bigint!
  ): PaymentCSV

  """
  fetch data from the table: "payment_gateway.payment_capture" using primary key columns
  """
  paymentCapture(
    id: bigint!

    """Merchant who has created the capture."""
    merchantId: bigint!
  ): PaymentCapture

  """
  fetch aggregated fields from the table: "payment_gateway.payment_capture"
  """
  paymentCaptureAggregate(
    """distinct select on columns"""
    distinctOn: [PaymentCaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCaptureOrderBy!]

    """filter the rows returned"""
    where: PaymentCaptureBoolExp
  ): PaymentCaptureAggregate!

  """
  fetch data from the table: "payment_gateway.payment_capture"
  """
  paymentCaptures(
    """distinct select on columns"""
    distinctOn: [PaymentCaptureSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCaptureOrderBy!]

    """filter the rows returned"""
    where: PaymentCaptureBoolExp
  ): [PaymentCapture!]!

  """
  fetch data from the table: "tenant.payment_method_available"
  """
  paymentMethodStatus(
    """distinct select on columns"""
    distinctOn: [PaymentMethodStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentMethodStatusOrderBy!]

    """filter the rows returned"""
    where: PaymentMethodStatusBoolExp
  ): [PaymentMethodStatus!]!

  """
  Get a single URL containing a downloadable CSV file with payment request data
  """
  paymentRequestCSV(
    """This is the key that we send to query for the links."""
    id: bigint!
    merchantId: bigint!
  ): PaymentRequestCSV

  """Get the list of payment requests"""
  paymentRequests(
    """distinct select on columns"""
    distinctOn: [PaymentRequestSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentRequestOrderBy!]

    """filter the rows returned"""
    where: PaymentRequestBoolExp
  ): [PaymentRequest!]!

  """
  Get the list of URLs containing downloadable CSV files with payment request data
  """
  paymentRequestsCSV(
    """distinct select on columns"""
    distinctOn: [PaymentRequestCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentRequestCSVOrderBy!]

    """filter the rows returned"""
    where: PaymentRequestCSVBoolExp
  ): [PaymentRequestCSV!]!

  """Get the list of payments"""
  payments(
    """distinct select on columns"""
    distinctOn: [PaymentSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentOrderBy!]

    """filter the rows returned"""
    where: PaymentBoolExp
  ): [Payment!]!

  """
  Get the list of URLs containing downloadable CSV files with payment data
  """
  paymentsCSV(
    """distinct select on columns"""
    distinctOn: [PaymentCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCSVOrderBy!]

    """filter the rows returned"""
    where: PaymentCSVBoolExp
  ): [PaymentCSV!]!

  """
  Run aggregation functions on list of URLs containing downloadable CSV files with payment data
  """
  paymentsCSVAggregate(
    """distinct select on columns"""
    distinctOn: [PaymentCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PaymentCSVOrderBy!]

    """filter the rows returned"""
    where: PaymentCSVBoolExp
  ): PaymentCSVAggregate!

  """Get a single purchase by Id"""
  purchase(id: bigint!, merchantId: bigint!): Purchase

  """Get the list of Bulk Capture requests with their status"""
  purchaseBulkCaptureStatuses(
    """distinct select on columns"""
    distinctOn: [PurchaseBulkCaptureStatusSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseBulkCaptureStatusOrderBy!]

    """filter the rows returned"""
    where: PurchaseBulkCaptureStatusBoolExp
  ): [PurchaseBulkCaptureStatus!]!

  """Get the list of unauthenticated orders"""
  purchaseOrders(
    """distinct select on columns"""
    distinctOn: [PurchaseOrderSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseOrderOrderBy!]

    """filter the rows returned"""
    where: PurchaseOrderBoolExp
  ): [PurchaseOrder!]!

  """An array relationship"""
  purchases(
    """distinct select on columns"""
    distinctOn: [PurchaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseOrderBy!]

    """filter the rows returned"""
    where: PurchaseBoolExp
  ): [Purchase!]!

  """An aggregate relationship"""
  purchasesAggregate(
    """distinct select on columns"""
    distinctOn: [PurchaseSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseOrderBy!]

    """filter the rows returned"""
    where: PurchaseBoolExp
  ): PurchaseAggregate!

  """
  Get the list of URLs containing downloadable CSV files with purchase data
  """
  purchasesCSV(
    """distinct select on columns"""
    distinctOn: [PurchaseCSVSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [PurchaseCSVOrderBy!]

    """filter the rows returned"""
    where: PurchaseCSVBoolExp
  ): [PurchaseCSV!]!

  """Get the list of downloadable CSV reconciliation reports"""
  reconciliationReports(
    """distinct select on columns"""
    distinctOn: [ReconciliationReportLinkSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReconciliationReportLinkOrderBy!]

    """filter the rows returned"""
    where: ReconciliationReportLinkBoolExp
  ): [ReconciliationReportLink!]!

  """Get the list of generated reconciliation reports"""
  reconciliations(
    """distinct select on columns"""
    distinctOn: [ReconciliationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [ReconciliationOrderBy!]

    """filter the rows returned"""
    where: ReconciliationBoolExp
  ): [Reconciliation!]!

  """An array relationship"""
  refunds(
    """distinct select on columns"""
    distinctOn: [RefundSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [RefundOrderBy!]

    """filter the rows returned"""
    where: RefundBoolExp
  ): [Refund!]!

  """Get the list of downloadable CSV settlement reports"""
  settlementReports(
    """distinct select on columns"""
    distinctOn: [SettlementReportLinkSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SettlementReportLinkOrderBy!]

    """filter the rows returned"""
    where: SettlementReportLinkBoolExp
  ): [SettlementReportLink!]!

  """Get the list of generated settlement reports"""
  settlements(
    """distinct select on columns"""
    distinctOn: [SettlementSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SettlementOrderBy!]

    """filter the rows returned"""
    where: SettlementBoolExp
  ): [Settlement!]!

  """Get the list of successful webhook notifications"""
  successfulWebhookNotifications(
    """distinct select on columns"""
    distinctOn: [SuccessfulWebhookNotificationSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [SuccessfulWebhookNotificationOrderBy!]

    """filter the rows returned"""
    where: SuccessfulWebhookNotificationBoolExp
  ): [SuccessfulWebhookNotification!]!

  """
  fetch data from the table: "merchant_portal.merchant_user_email" using primary key columns
  """
  userWithPassword(email: citext!, merchantId: bigint!): UserWithPassword

  """
  fetch data from the table: "merchant_portal.merchant_user_email"
  """
  usersWithPassword(
    """distinct select on columns"""
    distinctOn: [UserWithPasswordSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [UserWithPasswordOrderBy!]

    """filter the rows returned"""
    where: UserWithPasswordBoolExp
  ): [UserWithPassword!]!

  """
  fetch data from the table: "tenant.webhook_settings" using primary key columns
  """
  webhookURL(merchantId: bigint!, webhookUrl: String!): WebhookURLs

  """
  fetch data from the table: "tenant.webhook_settings"
  """
  webhookURLs(
    """distinct select on columns"""
    distinctOn: [WebhookURLsSelectColumn!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    orderBy: [WebhookURLsOrderBy!]

    """filter the rows returned"""
    where: WebhookURLsBoolExp
  ): [WebhookURLs!]!
}

scalar timestamptz

scalar uuid

